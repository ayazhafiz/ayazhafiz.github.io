

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?" />

<link rel="alternate" type="application/atom+xml" title="cc - Ayaz Hafiz" href="/feed-rrs2.xml">


<title>
  
    Pattern Matching With a Typechecker
  
</title>
<meta name="description" content="Solving problems without leaving the TypeScript type system." />

<link
  rel="canonical"
  href="/articles/20/pattern-matching-with-a-typechecker"
/>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    TeX: {
      Macros: {
        co: "\\colon",
        msf: "\\mathsf",
        Ra: "\\Rightarrow",
        Def: "\\text{Definition.}",
        Thm: "\\text{Theorem.}",
        Pf: "\\text{Proof.}",
        eps: "\\epsilon",
        lam: "\\lambda",
        lt: "<",
        
      },
    }
  });
  MathJax.Hub.Queue(function () {
    document.body.setAttribute('render-done', '');
  });
</script>

<script
  type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"
></script>

<link
  rel="stylesheet"
  type="text/css"
  href="/css/shiki.css?1676911955025339700"
/>




    <link
      rel="stylesheet"
      type="text/css"
      href="/css/post.css?1676911955025339700"
    />
  </head>

  <style></style>

  <body>
    <div class="container post">
      <div class="panel">
        <div class="column-right pattern matching with a typechecker-main">
          <section class="nav">
  <a class="nav-link" href="/about">about</a
  ><a class="nav-link" href="/cc">cc</a
  ><a class="nav-link" href="/visual">visual</a>
</section>
 <h1 class="title">Pattern Matching With a Typechecker</h1>
<p class="byline">December 27, 2020</p>

<article class="post">
  
  <p>I've been doing the 2015 Advent of Code puzzles, and today I came across <a href="https://adventofcode.com/2015/day/16">Day 16 - Aunt Sue</a>.
The premise of the problem is you have a bunch of aunts named Sue, each of which
you know some facts about, and you are searching for the aunt that matches a
set of predetermined facts. The second part of the problem adds additional
constraints that make the fact matching conditional rather than singleton.</p>
<p>This is a pretty simple pattern matching problem. While I was thinking about
about it, I realized that it could be solved entirely within TypeScript's type
system!</p>
<p>In this cc, we will cover how to do so - part 1 is pretty
straightforward, part 2 requires some construction and is more
interesting. The article will not attempt to assume you are previously familiar
with TypeScript's type system, introducing semantics where needed. Understanding
of subtyping is assumed.</p>
<p>The basis for this construction is TypeScript's treatment of
primitive literals as subtypes of their primitive type (i.e. <code>1 &lt;: number</code>), a
feature I am not aware any other mainstream programming languages have<span class="note"><label for="number" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="number" class="margin-toggle" /><span class="sidenote">This feature is not strictly needed (i.e. you could form a
similar construction in other languages by creating fresh types for the natural
numbers), but it makes application of the approach much easier.</span>.</p>
<h3 id="prelude" tabindex="-1"><a class="header-anchor" href="#prelude" aria-hidden="true"></a>Prelude</h3>
<p>As a quick note on notation, we use <code>S &lt;: T</code> to mean <code>S</code>
is a subtype of <code>T</code> and <code>S &lt;/: T</code> to mean <code>S</code> is not a subtype of <code>T</code>.</p>
<p>TypeScript union types are of the form <code>T|U</code> and are inhabited by values that
have type <code>T</code> or <code>U</code>. For example, <code>number|string</code> is inhabited by all string
and numbers. Clearly, <code>T &lt;: T|U, U &lt;: T|U</code>, and <code>T|U &lt;/: T</code> and <code>T|U &lt;/: U</code>.</p>
<p>TypeScript intersection types are of the form <code>T&amp;U</code> and are inhabited by values that
have type <code>T</code> and <code>U</code>. For example, <code>{a: number}&amp;{b: number}</code> is inhabited by
all records with fields <code>a</code> and <code>b</code>, each of which is a <code>number</code>.
<code>T&amp;U &lt;: T, T&amp;U &lt;: U</code>, and <code>T &lt;/: T&amp;U</code> and <code>U &lt;/: T&amp;U</code>.</p>
<h2 id="part-1" tabindex="-1"><a class="header-anchor" href="#part-1" aria-hidden="true"></a>Part 1</h2>
<blockquote>
<p>If you would like to follow along with this solution, I have provided a
<a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAKgFhAygV2gXigbwFBSgYzgEsAbAEwCcIA7ALigGYAaXAgQ2AGd6B2FvTmwC2AexAQy3KACZ+UMCKEQKbakVVTmrNgGsiwNlIAMcgG5EAXpxKH6J1gHMR5AGZFOcegFY5wKhE05fDYKKVlWSAoXZCUpAEYWAF8AbmxsUEgoFACAdX04ADlhAKgMHDwoAG1EKCJqKB0IEBEXLNROAF16TGpi+kREgDJszmqO1JT08GgAQRISeCR20rbc-KLYysbm1pG84ELiztSM6ABZDkI6h2yVgFEADz82fGAAHjmFhBGmKAAFELAdQkN6LbIAPnBlQA5L0lNDxmlTqtOCtylA4t0nK53J4oABOZLsUJ2ImCUTiST0fGTPDSbqRaKxbxEvwQAL0AAcROxZDcHi5tMYDMUylU6moYSJun0tgxrP8Ui8QoALFjnHzcfQ4kZpXoDFL5MomRyCUKvN1giSoF4iYyYqaAGx62VSGmpPCO9U4gUY3XsLjUolWqScoU8bps03SMnCMQSKQ8Hka-l4nVCzmWkKhu3Gh1SZ1QXmp7VC-FZwNQFV20UqNQaUlQKPGIU6yOK+gxgjEchUOh+2MUhPaoytzFYGUGke5qL5+jVqDmKw2eKt+kT-VyuIK9nGZM+vEMVsMBl55lQQvFrUD4mh1tqrDBSvcqCTuW2xeWaxy0cejEWx9sy5HdTQYQd4ypG1Wy9LAl2-Atgw4BD5FrcUGz9VsIw3V16ELJ9DXtc93VYOJM0fHtKBoIMixTa8uzfeJfxI8ssGbegwKNWdz39K9fUdIVpCMbo4JXdiXSnKB-TYjEBPHTARLlDiQ14cTFIE9dMEI00k27UhKP7bcUKUOsJUTAST1Yjsb2UglVMYgSH0wBiWRog9cKJBSCwEgDMHJCDNBAnNP2Xd8BJg+Sv1Eqsa2MtDJU7QLSz-aQsMwGzCVczVfS7aSVQEsiIpC5DeLTf0tLM5KWMK+D3KMsV63ixg7NwoUGCEyzd0bPzKSVZqzT-Bg5M87UZxNPcmys-iBo0mydOG+VdN7KiMIGizqqiwybMM8reFaxz5oy6SdT64i8AYHznKa4KaptRDrXTAbwvwsTFv06juuHRhWtS+aPwUWKGsTO6vIGgqtv9S6P3msMBqqyHEts16+07VV2vWn9EMrHTLqYvAVTk9KEeOzixsFP8VQ0y6F2krsSvY1U1rphbnoWy6YdYFVHKZl9Loy+a8vJnydqupnqas3Gq3C6SdOFwzudVVL-vq0zp1vFSJs6mRVQKmm+s2oCq1VKqmb+s9tL69m8C8NHeY8yK5UOqzpHNAmDf9D7IP9aHzQ06SyrN5ClZM9CBdYLw1vm-XK0LS6jz-LxHI9oLLsM-nzR8pnieFrsg7i+z46lqyMuFjiTfNVLY9GudJMxsJzQK4WF354GybD43aN9HSriW-s-tQwHW89NGtqJqvzwe1hHTk3LwJ6+cW4vIVHUpzdGIRrt5qmyfGY7w8x-N66Nolx1HNzgfbqR5biZs4+fMj-0bJfEul6eijkYv5vX1Xkcl9S7u3ovPvIGasvp-kdAVbmC88JvyvkvKqv0gEvXSuGNGTMH5IVqsLCWPBp5O1np9JSBs4jhhmhgq6bM7ZFV2n+Hga1K6HzlLTXeLUaGn37irG8SdqIs0tlAHgd97bANmnrbBr89Lv0IdHShN046sB4KlJmMt2HoWJn7cMBUDrBhgf2HSR1sFVWkoWM+HCXxcJkn+TkaMEGX37EY5RjVlQWNdtaPmgjqK8wzBpeahDrQ82-uY1gnII5uOihraMtckqBMcv-CRfUvYhOIRYnyLNCzWMus7CxT0DYcUujpeWFjUpmJfN4-cWU8S8M5BokJC4YnLXQVjDM7c3KI2MSo92cY56STLGjQxfUfEVVYPiOSZicn+JlgHH+f58SkOtEogGHDVFOzLGtMxm1tFIOyWWROHTPp+Jwnw6RUUJb4gzswg5NiEogK3ngfEWTrQcWFhlFOxyK7+IyuDQ5W5jk6ysguSBdVg6NR4GWKqZi7HzPQvEqhfDWxGBtmMxBUBikhNkXgHUzjeok2roZNRf4dQr32eC5WbSEYSx1GtaSDyJkXxZqdP0XMzlZ2pXsiSZKjCnOaakkJH4aawvCq0xqGVVn+y4qaCeaKjB-wNsi6FC50mwrBmQniZzdHi1hVVGyDz7HIV5XitsWBG6lJLBfZ5Y4MUvUNQCvO84xykMrEw5pxMcZjjWiza+6ya5hNXHqxyzzPkBUysaslcQfIjKNdeLl0LEkkTiHcgNwseWTTHK8-ZQqdmQRfPkmNDdtUuVllJKy0a0VxCaWUzB1KlIeqLRiQS7ZNZrPEctLVELGrXJrXJXJC9iYHTXL7X5Ft8GQXFTW11ZCanSv9dSNc0SiEPyraStcHKy0XwFZi3VJFpDhUzpOpFIi1w-WqQvJ5-jq1xGkBAs5T8K1HrXKW41xdc0tOpaetqdaxU7uLhW48BMPWFmkjKm6vC4gMBmfEHdlbG06OPKO2ZWjIMjSxeeNtwHHL-vA4OuueLzoVjdIihcq7qEkQYPy6lEN-EAaishhgCizmJs1lCm6wKsM-PrYirs4NjygvTUFf5uKSIqisQkkVpNEZoPvHJYWXcDbvLIY4-jfbNZdjMext294YNgcQ++r++zT2c2EiEmTsGrXn2HXEFUQtH1Ke4+rWpUG8UqnCpvI94bO73lSrrBhGnaX3gbtSx2mt8OPrk2ilUXGhwZrgz3BDPa8XWxwy9DzadYtyUUSIhGqL-waUtfNKT1pQ5ovDiKFtUg5X+IY1FDLIbtnhaColoTrYvACOhVJrGMViUOIa1uxlZVH2pwSQ1qV1ojHUtVZrOlIaWOmg-GYjKTNKteCqgR0Jl1I2AegqglVkWAH1JbHiqe+noUfhxhhlGe2CUSRqR68rak9srOszIRFyrmnjZPlmFxO6WVymQ46UN93XHQs-aKpU0E415sfQuIp0FBtr00wGsF0Ec3FeAoG68-nTQvfgSE7G-iOJmPyxiHgw8yEOuXddkrmEJPXpR76a+ZDKs8A0ql7TEk8KqbxbQt7uHqd4mx-s4LBOGWcoiZ6727OhYjeF7T+6ZKeDhRmzuwLSOVokXkaeIHjY-Zdpl1U6F0D4PnNWZhTH0KXy2dqnxtFljOfRZCX+wtrZORDSE4i-pkTLcKdNKYv7C8mMkSCdbwBnnLmSYd6hqy03vfM5-A75JE7ufI9yg7uX93LyMvXg7xWz7159V95bgqZiPw2WG+rrWeLORhf8sjubiL+clvhfslTlZDKG7xUMt9mKU4uZ562aZB2ZGkrwz39TFrqWlf2ZV-Ep9R8fa2+-fHJams3Wb-d13i9W+g5XdS1bUUMnMQPSbgdAYQbMUVe9qPBFH254xPiDVZDj2Eq1wJOFfej5tcBYaJmdLBJO4Byd5bOOn9zt3xhcN4QkJZBI1pZZZ8m091kojAw8Asd1ecJIv92V29kdHku0n8ushcvUXJH4n8U0JIOJoYEZeFBIdcbp8MJdz9JlWBBJb8z9JMu8p1kp9V0ZDQWZ6IT1wC4gO0T10sF5d86Qz1vRl06NTQydCMRC6EcdEU+tDtZIp8S9m12tkIb5ZIl1jUo4udNVZIcDl0H0ldCwzFeDodzc8FYdTt6DSIX9FIWDd1aCoI2Db9KxAcRNctgdkpa0DUgsFdhd+dpBpBcF6Mc8HDh0gigDODskd1AjpAd5mkqUS9kC5R8cgjqtK8HsQEm4sd1IfJpJC83ZHt1JC5FNwjhNq420gjzDHDpJ78Wd1IL1HUC160KjuJ1INUPUdI8cHCqjX1YIDN5DoCDJwDBo7Datw8TpzIoiXJP8iZzJgloUOIPMzd+p6CGAMjOkr0S8ds7BzJxcS8cili+pAjiMis1CXISknCv9qN4sFppZYjzIwYPVCjKwId7tTiDErJRkG9eiHINtntR4rCAk6R8YA8c5es-9hCZAKZuh0lBDsiHJFiboY5-ErMatpCYSEDJCa8fcHItDrwmUS8oYQlyCHM4SytHssDkoVRCl7tM0zl0EhsHJfMdjhjVY9EHJFst8TiAjvJBNms+px1KxAivBhl7sx8JIcUrJyCvAstmU39rUaUiFvJZCdMWjTRhTNBvJlCRNG8P8zkv9GsA8xZWMnC0ivBk8MTRNGSpjkovB98bp3Dq4SdjVoTpAvBWSRN9Yz8W96CFt0DPU0E-8MtN00ZmCQE5ZGSwpzVPUCi-jkpl4KT9k5oUVFTz5AjHQKVC10N49QF6DXtsIJJUzZV2SulEzftrSJDxoqYwoSMS9ZtDSF5yDHQajxkS8s5H0WzT8ayEVgS0jHRFtH0mSud80BJCduhhV5CRzWD6CcFkyJJQCD8j9vBxyZirpVi01rSIiOcDVqUVNpcHDyCeAZ17kyyiTvTwD+E7j6jgC8Dyy5zwoVsyylyl9xzFZH07dWiQzxyez1Z815jkoeBGDA4uz09kordfClcZNKw2jtJ8of8l8ntDD0yOFAjOR5TDi-9PDZy6R-dAIz8nN7z0LTzgEjoFd8pKzMi-luthc0jOQrTMiyN9lLt9d0L3MczgTS5ut8pEcLibx6EbJ3Ty9Ay5l+KaLmiBJ8Q0YpzgSZy1i6Q28iyMZjMOESyqCpK7VDRSC8zAj8RkTKNUL0JnT2jKpfV-FWcjNfopKCTfRmKUDhdwDbkxDtCB8rkpLM8S9WdnwjLW0pLFVYLei2MpKQL54nDl9tyJY2oASUKoAwU+SBojBYypDzkLdGAjBGcmy4r7sG0os19WA2ph9A8IzIdErsSeMsrNzWo0C9y2SQEPxRZqqslKxV91Koor82oPyldqCvKhDqq-zEZny8z8c2ohyldXzX88zh1Bph4rs6Kc9Wo+DLQq17K5QKNGFFqZoXiF4UqRrgM1dLyESls6VBpNiCEHCcoi5FrY9rR9SwcldprY07iiV39aoqqBo4gpV7VczZZFqCpO8uKd1HrQrzksEF1poYrjUTCU9fLydpoQjwk8y9c8qoqgiXLrwNTDQ2ZWp4jzjXqsj5cg8QTGBpByqwqmYXqlS20QN8jLCltuLHUcb6yRMJLl0vypscaiD7CQFTdiccaArkJ5pVrMMCrpBuSVDyi+lWp+jMBq8ibDIVtpbKcsL7yozml+cGAQN0bO4P09ZpbXUPVebfEEYRqNiA8FCUTwaCrsMsAmYDysaT1paDDjUjt-FqzcLGBbiCLMUiKKbpaBb3E5C8yTqGA4Yg6uCyyOqBNta8QesldtiRMTqwSOocTVKVEHCNbYTbbaL7ySDqk9pR0Wq-9cqAFqa9NaqRMIM8r3jrToSNjklf1s8pq9pSjEb6aM69ouaYcctAKCqVQvTq5JTGEkC9pxaRMGTEjHiBo4sU6StYaXJTVp7laRNCiz80rzp1zkaAEXxOTp67trSUjBb87p7okPVGzml2yV7WpjTZ6ENLUtpr7GLOltpp807GpeFzoOLNY8kc7nVp7-qBCibLKBkzoAyBjji8yd7flWpHR68pSUrLrNYMtiNxTrTKaTNijHoNIw1IyrazoszxjGxjqhSYHdTq4jD+L1q3QYHF92qF4erLyYGN92kqzyiYG-4PUjibpXaWKYH89I9stbcYGx7q5V657sqqzvo4Hub5oc5n1vpYzebWsLlnCCqGdCGn0S9uD1Tvpszvy36uc5tvpT79dx1DzgS67rzyJ9duiPjHLvonyeC-8STFCBpVds7mkoGkGXdvomjl1u0wDgq3GvizSe6DGbVQYZL6Tcz10zpHcY7g9qUI9rSTqMK7i86o1hbVzQYiqf71aLZWpOQTG8rU9mje64nY9vqnDoaD7CmN93VTGLrCmvrxoE07SCrKk8alTD6uo-tCmQnU7bYiaP7pKA9MbVZHlWolK0o79JbgTpre9vaXoiKWZkH9KNGLzB6O7YYyHzwh6YdYnGATkumMz6GfHYZ+VH1-tuG+o678QajiZeMllYYB7zwu4z6HCTqb8FyvsQCHCr8BNIbUcqSQFoSBMf1GmibxnS8OYMqfnxHH557DZyYjADK1rEU8n-HUZBd-GWHMi2qbtYWLpAGiLhY20BNLn46gqVz8y8ZJUEmsjP5clUYBrNnx4UqMsBNjdGMkWGHB7VR2DRYkCEZ+d8ZFG3LGryZRClnHC2mib8d8Y0WA1O0JHMjyWzNAy4L1DZ0BWLNuqgSyWBX6mtXap5UpXPKRMammK4kBXnj9cX6GzwMBW71gXVXOkkjx7VQfDZazkzHu7cjyZgjJz7sCWhE+bA2PcNN-ksEvWiqPWXT0svWzrIJt8VLFbA3abvGnDMXtCvWN80cNMY3A2ur+K502LEVeEKYBqTXA9ViFWxb4X-yrnhdyWZaUkgSNDyYxjrG8rPtMVJmu3MKV60t7y6UVRNbG3QkAKiaAWzbb6NyVq-8FWbaODZizltHFyGYn7zr7z7aWEOYva0oPmnC47+LOWGBXmxUsmsjZoGYRH2W-9USdHyZo7wGkKm7saX3l7q4+3g9L9VQs6Znjbc6EyOZx3zaM6p6wP9oQkN2vkl2APaHh7wqa2x3yTlKA0dLM4APHS6HwmL5d6wOA7irn0y2SmAOBnojrQGrL1VQZ7MBNckafzBZv3uJmzymqw5TJ3TTPdEUx3CsPH-GMW+pyWE4NHV8HXLW6PM2tMVXM4JZzNt3IIuGd8b1BYLXsUyOAFpTNZK3PSDrq4UrDM7xBZXDxpVjRtQJVRYGNGtTy0tHrOEaA1VixHB5JZMqL7hWVHRWCGZWeHiDtmOZCzV3PUltXOHy8YfsGX9nGwWYfON93aFo-byZWyDOH37yjbvUgvL3xHBK2cgvuWKsfckXq1aTwys8Z2CnyZ5zBPtC8Xn7T38bRX1HauI03Ki2OZdyfX8moWyzmvSLlmsdpyFYkO10i4jyFZHHfimOVGAX3HfJ7sa3togsFZJsDTASoWFZ72tMi9PntZwzH143zxEux34nAIi6T2PttYstetr2vGObyZ8Luu2aR3s5tYZ1Aq8ytP35TuG7IW-VhntZHM0zg7zyFPOQOH9clGj7MntYBqenOEPjtZCuHYRPwKOZRm32op-Otw+ujZEKooJ7l0junQjZI2XpVkkXyX1mMObdDtmyjZzKWKzmiax3jmsfcenC7qYW8ZnL53Q2F6LKjYu6E86at8jYAGdMgS8cjYQbr2XGZFzRn9zv1vYrVj2YUggA">TypeScript playground</a> with all the code. To see what types have been
instantiated, simply hover over their name; for example, hovering on <code>MatchingSue</code>
should yield <code>40</code>.</p>
</blockquote>
<p>For the full problem statement, please refer to the AoC (not <a href="https://en.wikipedia.org/wiki/Alexandria_Ocasio-Cortez">AOC</a>)
link above. In short, we have a list of facts about the exact aunt Sue we are
looking for, which we can express a record type:</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type TheSue = {&#10;    children: 3;&#10;    cats: 7;&#10;    samoyeds: 2;&#10;    pomeranians: 3;&#10;    akitas: 0;&#10;    vizslas: 0;&#10;    goldfish: 5;&#10;    trees: 3;&#10;    cars: 2;&#10;    perfumes: 1;&#10;}' >TheSue</data-lsp></span><span style="color: #000000"> = {</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #001080"><data-lsp lsp='(property) children: 3' >children</data-lsp></span><span style="color: #000000">: </span><span style="color: #098658">3</span><span style="color: #000000">,</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #001080"><data-lsp lsp='(property) cats: 7' >cats</data-lsp></span><span style="color: #000000">: </span><span style="color: #098658">7</span><span style="color: #000000">,</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #001080"><data-lsp lsp='(property) samoyeds: 2' >samoyeds</data-lsp></span><span style="color: #000000">: </span><span style="color: #098658">2</span><span style="color: #000000">,</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #001080"><data-lsp lsp='(property) pomeranians: 3' >pomeranians</data-lsp></span><span style="color: #000000">: </span><span style="color: #098658">3</span><span style="color: #000000">,</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #001080"><data-lsp lsp='(property) akitas: 0' >akitas</data-lsp></span><span style="color: #000000">: </span><span style="color: #098658">0</span><span style="color: #000000">,</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #001080"><data-lsp lsp='(property) vizslas: 0' >vizslas</data-lsp></span><span style="color: #000000">: </span><span style="color: #098658">0</span><span style="color: #000000">,</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #001080"><data-lsp lsp='(property) goldfish: 5' >goldfish</data-lsp></span><span style="color: #000000">: </span><span style="color: #098658">5</span><span style="color: #000000">,</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #001080"><data-lsp lsp='(property) trees: 3' >trees</data-lsp></span><span style="color: #000000">: </span><span style="color: #098658">3</span><span style="color: #000000">,</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #001080"><data-lsp lsp='(property) cars: 2' >cars</data-lsp></span><span style="color: #000000">: </span><span style="color: #098658">2</span><span style="color: #000000">,</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #001080"><data-lsp lsp='(property) perfumes: 1' >perfumes</data-lsp></span><span style="color: #000000">: </span><span style="color: #098658">1</span><span style="color: #000000">,</span></div><div class='line'><span style="color: #000000">};</span></div></code></div></pre>
<p>Observe that in <code>children: 3</code>, <code>3</code> is a type, not a value.
It is a subtype of <code>number</code> inhabited by exactly one value, namely the number <code>3</code>.</p>
<p>We are given 500 candidate aunt Sues, each of which we know a subset of facts about.
We can express them all in a record type whose keys are the numbers 1-500 and
whose entries are the facts of the corresponding Sue.
500 Sues are a lot, so the code block below hides the record type; to
see part of it, hover over the <code>Sues</code> type.</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Sues = {&#10;    1: {&#10;        goldfish: 9;&#10;        cars: 0;&#10;        samoyeds: 9;&#10;    };&#10;    2: {&#10;        perfumes: 5;&#10;        trees: 8;&#10;        goldfish: 8;&#10;    };&#10;    3: {&#10;        pomeranians: 2;&#10;        akitas: 1;&#10;        trees: 5;&#10;    };&#10;    4: {&#10;        goldfish: 10;&#10;        akitas: 2;&#10;        perfumes: 9;&#10;    };&#10;    5: {&#10;        cars: 5;&#10;        perfumes: 6;&#10;        akitas: 9;&#10;    };&#10;    6: {&#10;        goldfish: 10;&#10;        cats: 9;&#10;        cars: 8;&#10;    };&#10;    7: {&#10;        trees: 2;&#10;        samoyeds: 7;&#10;        goldfish: 10;&#10;    };&#10;    8: {&#10;        cars: 8;&#10;        perfumes: 6;&#10;        goldfish: 1;&#10;    };&#10;    9: {&#10;        cats: 4;&#10;        pomeranians: 0;&#10;        trees: 0;&#10;    };&#10;    10: {&#10;        trees: 2;&#10;        children: 10;&#10;        samoyeds: 10;&#10;    };&#10;    11: {&#10;        akitas: 10;&#10;        perfumes: 4;&#10;        vizslas: 1;&#10;    };&#10;    12: {&#10;        akitas: 1;&#10;        trees: 0;&#10;        goldfish: 3;&#10;    };&#10;    13: {&#10;        perfumes: 6;&#10;        goldfish: 10;&#10;        cars: 8;&#10;    };&#10;    14: {&#10;        cats: 8;&#10;        akitas: 5;&#10;        vizslas: 0;&#10;    };&#10;    15: {&#10;        cars: 8;&#10;        trees: 3;&#10;        samoyeds: 5;&#10;    };&#10;    16: {&#10;        vizslas: 6;&#10;        cats: 6;&#10;        pomeranians: 10;&#10;    };&#10;    17: {&#10;        akitas: 6;&#10;        cats: 2;&#10;        perfumes: 9;&#10;    };&#10;    18: {&#10;        children: 9;&#10;        goldfish: 2;&#10;        akitas: 10;&#10;    };&#10;    19: {&#10;        trees: 3;&#10;        perfumes: 0;&#10;        goldfish: 6;&#10;    };&#10;    20: {&#10;        vizslas: 3;&#10;        akitas: 0;&#10;        trees: 1;&#10;    };&#10;    21: {&#10;        vizslas: 3;&#10;        cars: 7;&#10;        akitas: 3;&#10;    };&#10;    22: {&#10;...' >Sues</data-lsp></span><span style="color: #000000"> = </span><span style="color: #267F99"><data-lsp lsp='type SuesList = {&#10;    1: {&#10;        goldfish: 9;&#10;        cars: 0;&#10;        samoyeds: 9;&#10;    };&#10;    2: {&#10;        perfumes: 5;&#10;        trees: 8;&#10;        goldfish: 8;&#10;    };&#10;    3: {&#10;        pomeranians: 2;&#10;        akitas: 1;&#10;        trees: 5;&#10;    };&#10;    4: {&#10;        goldfish: 10;&#10;        akitas: 2;&#10;        perfumes: 9;&#10;    };&#10;    5: {&#10;        cars: 5;&#10;        perfumes: 6;&#10;        akitas: 9;&#10;    };&#10;    6: {&#10;        goldfish: 10;&#10;        cats: 9;&#10;        cars: 8;&#10;    };&#10;    7: {&#10;        trees: 2;&#10;        samoyeds: 7;&#10;        goldfish: 10;&#10;    };&#10;    8: {&#10;        cars: 8;&#10;        perfumes: 6;&#10;        goldfish: 1;&#10;    };&#10;    9: {&#10;        cats: 4;&#10;        pomeranians: 0;&#10;        trees: 0;&#10;    };&#10;    10: {&#10;        trees: 2;&#10;        children: 10;&#10;        samoyeds: 10;&#10;    };&#10;    11: {&#10;        akitas: 10;&#10;        perfumes: 4;&#10;        vizslas: 1;&#10;    };&#10;    12: {&#10;        akitas: 1;&#10;        trees: 0;&#10;        goldfish: 3;&#10;    };&#10;    13: {&#10;        perfumes: 6;&#10;        goldfish: 10;&#10;        cars: 8;&#10;    };&#10;    14: {&#10;        cats: 8;&#10;        akitas: 5;&#10;        vizslas: 0;&#10;    };&#10;    15: {&#10;        cars: 8;&#10;        trees: 3;&#10;        samoyeds: 5;&#10;    };&#10;    16: {&#10;        vizslas: 6;&#10;        cats: 6;&#10;        pomeranians: 10;&#10;    };&#10;    17: {&#10;        akitas: 6;&#10;        cats: 2;&#10;        perfumes: 9;&#10;    };&#10;    18: {&#10;        children: 9;&#10;        goldfish: 2;&#10;        akitas: 10;&#10;    };&#10;    19: {&#10;        trees: 3;&#10;        perfumes: 0;&#10;        goldfish: 6;&#10;    };&#10;    20: {&#10;        vizslas: 3;&#10;        akitas: 0;&#10;        trees: 1;&#10;    };&#10;    21: {&#10;        vizslas: 3;&#10;        cars: 7;&#10;        akitas: 3;&#10;    };&#10;    22: {&#10;...' >SuesList</data-lsp></span><span style="color: #000000">;</span></div></code></div></pre>
<p>The record of facts for each aunt Sue is indexed by a numeric reference (Sue 1,
Sue 2), etc. Observe that the fields of facts known for each Sue is a subset of
facts we know about the <code>TheSue</code>. Only one of these candidates' facts exactly
match the corresponding facts associated with <code>TheSue</code>.</p>
<p>This means that not every Sue is a supertype of <code>TheSue</code>; for example, <code>Sues[1]</code>,
which has type <code>{goldfish: 9, cars: 0, samoyeds: 9}</code>, is not a subtype of <code>TheSue</code>
because (for one) <code>TheSue['goldfish'] = 5 &lt;/: 9 = Sues[1]['goldfish']</code>.</p>
<p>To check the subtype relation, we can query TypeScript's typechecker via
<a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#conditional-types">conditional types</a>.
The conditional type</p>
<pre class="shiki light-plus" style="background-color: #FFFFFF; color: #000000"><div class="language-id">typescript</div><div class='code-container'><code><div class='line'><span style="color: #0070C1">S</span><span style="color: #000000"> </span><span style="color: #001080">extends</span><span style="color: #000000"> </span><span style="color: #0070C1">T</span><span style="color: #000000"> ? </span><span style="color: #0070C1">A</span><span style="color: #000000"> : </span><span style="color: #0070C1">B</span></div></code></div></pre>
<p>Means if <code>S</code> is a subtype of (extends) <code>T</code> yield <code>A</code>; else, yield <code>B</code>. We define
a <code>Subtype</code> predicate that yields <code>true</code> or <code>false</code> types based on the existence
of subtyping relations. We use this to write subtyping tests checked by the compiler.</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Subtype&lt;S, T> = S extends T ? true : false' >Subtype</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) S in type Subtype&lt;S, T>' >S</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type Subtype&lt;S, T>' >T</data-lsp></span><span style="color: #000000">&gt; = </span><span style="color: #267F99"><data-lsp lsp='(type parameter) S in type Subtype&lt;S, T>' >S</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type Subtype&lt;S, T>' >T</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99">true</span><span style="color: #000000"> : </span><span style="color: #267F99">false</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const subtype_test1: true' >subtype_test1</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type Subtype&lt;S, T> = S extends T ? true : false' >Subtype</data-lsp></span><span style="color: #000000">&lt;{</span><span style="color: #001080"><data-lsp lsp='(property) a: 1' >a</data-lsp></span><span style="color: #000000">: </span><span style="color: #098658">1</span><span style="color: #000000">, </span><span style="color: #001080"><data-lsp lsp='(property) b: 2' >b</data-lsp></span><span style="color: #000000">: </span><span style="color: #098658">2</span><span style="color: #000000">}, {</span><span style="color: #001080"><data-lsp lsp='(property) a: 1' >a</data-lsp></span><span style="color: #000000">: </span><span style="color: #098658">1</span><span style="color: #000000">}&gt; = </span><span style="color: #0000FF">true</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const subtype_test2: false' >subtype_test2</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type Subtype&lt;S, T> = S extends T ? true : false' >Subtype</data-lsp></span><span style="color: #000000">&lt;{</span><span style="color: #001080"><data-lsp lsp='(property) a: 1' >a</data-lsp></span><span style="color: #000000">: </span><span style="color: #098658">1</span><span style="color: #000000">}, {</span><span style="color: #001080"><data-lsp lsp='(property) a: 1' >a</data-lsp></span><span style="color: #000000">: </span><span style="color: #098658">1</span><span style="color: #000000">, </span><span style="color: #001080"><data-lsp lsp='(property) b: 2' >b</data-lsp></span><span style="color: #000000">: </span><span style="color: #098658">2</span><span style="color: #000000">}&gt; = </span><span style="color: #0000FF">false</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-err><data-lsp lsp='const subtype_test_bad: false' >subtype_test_bad</data-lsp></data-err></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type Subtype&lt;S, T> = S extends T ? true : false' >Subtype</data-lsp></span><span style="color: #000000">&lt;{</span><span style="color: #001080"><data-lsp lsp='(property) a: 1' >a</data-lsp></span><span style="color: #000000">: </span><span style="color: #098658">1</span><span style="color: #000000">}, {</span><span style="color: #001080"><data-lsp lsp='(property) a: 1' >a</data-lsp></span><span style="color: #000000">: </span><span style="color: #098658">1</span><span style="color: #000000">, </span><span style="color: #001080"><data-lsp lsp='(property) b: 2' >b</data-lsp></span><span style="color: #000000">: </span><span style="color: #098658">2</span><span style="color: #000000">}&gt; = </span><span style="color: #0000FF">true</span><span style="color: #000000">;</span></div><span class="error"><span>Type 'true' is not assignable to type 'false'.</span><span class="code">2322</span></span><span class="error-behind">Type 'true' is not assignable to type 'false'.</span></code></div></pre>
<p>Back to the Sues. if there is an Sue
that matches <code>TheSue</code>, their facts will be a supertype of <code>TheSue</code>, or said
another way, their facts will be a subtype of <code>TheSue</code> with respect to only those
facts (in fact, when only common fields are considered the types must be equal).
So, for each Sue <code>CandSue</code>, we're going to &quot;pick out&quot; fields from <code>TheSue</code> just
enough to match the fields of <code>CandSue</code>, producing a new type <code>TheSueMatcher</code>.
Then, we check the subtype relation <code>CandSue &lt;: TheSueMatcher</code>, and if it holds,
<code>CandSue</code> is the Sue we seek.</p>
<p>What does this subtype check look like? Thanks to TypeScript's optional field
syntax, wherein <code>{a?: number}</code> means &quot;a record with field <code>a</code> of type string, or
no field <code>a</code> at all&quot;, we can write a <code>Partial</code> type constructor<span class="note"><label for="partial" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="partial" class="margin-toggle" /><span class="sidenote"><code>Partial</code> is generally provided directly by the TypeScript standard library.</span> that given a
record type <code>T</code>, will yield a supertype of <code>T</code> where all fields are optional:</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Partial&lt;T> = { [F in keyof T]?: T[F] | undefined; }' >Partial</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type Partial&lt;T>' >T</data-lsp></span><span style="color: #000000">&gt; = {</span></div><div class='line'><span style="color: #000000">  [</span><span style="color: #267F99"><data-lsp lsp='(type parameter) F' >F</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">in</span><span style="color: #000000"> </span><span style="color: #0000FF">keyof</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type Partial&lt;T>' >T</data-lsp></span><span style="color: #000000">]?: </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type Partial&lt;T>' >T</data-lsp></span><span style="color: #000000">[</span><span style="color: #267F99"><data-lsp lsp='(type parameter) F' >F</data-lsp></span><span style="color: #000000">];</span></div><div class='line'><span style="color: #000000">};</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type PartialAnimal = {&#10;    noise?: string | undefined;&#10;}' style='border-bottom: solid 2px lightgrey;'>PartialAnimal</data-lsp></span><span style="color: #000000"> = </span><span style="color: #267F99"><data-lsp lsp='type Partial&lt;T> = { [F in keyof T]?: T[F] | undefined; }' >Partial</data-lsp></span><span style="color: #000000">&lt;{</span><span style="color: #001080"><data-lsp lsp='(property) noise: string' >noise</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99">string</span><span style="color: #000000">}&gt;;</span></div><div class='meta-line'><span class='popover-prefix'>          </span><span class='popover'><div class='arrow'></div>type PartialAnimal = {
    noise?: string | undefined;
}</span></div></code></div></pre>
<p><code>[F in keyof T]?: T[F]</code> is a mapped type that means &quot;for every key <code>K</code> of
(the record type) <code>T</code>, make it an optional field whose value pair has the same
type the value pair corresponding to <code>K</code> had in <code>T</code>&quot;.</p>
<p>Now, we can check if a candidate Sue is the one that we are looking for by
checking whether it is a subtype of <code>Partial&lt;TheSue&gt;</code>. For example, we will have
that</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const subtype_test3: true' >subtype_test3</data-lsp></span></div><div class='line'><span style="color: #000000">  : </span><span style="color: #001080"><data-lsp lsp='type Subtype&lt;S, T> = S extends T ? true : false' >Subtype</data-lsp></span><span style="color: #000000">&lt;{<data-lsp lsp='(property) trees: 9' >trees</data-lsp>: </span><span style="color: #098658">9</span><span style="color: #000000">, <data-lsp lsp='(property) cars: 4' >cars</data-lsp>: </span><span style="color: #098658">4</span><span style="color: #000000">}, </span><span style="color: #001080"><data-lsp lsp='Make all properties in T optional&#10;&#10;type Partial&lt;T> = { [P in keyof T]?: T[P] | undefined; }' >Partial</data-lsp></span><span style="color: #000000">&lt;{<data-lsp lsp='(property) trees: 9' >trees</data-lsp>: </span><span style="color: #098658">9</span><span style="color: #000000">, <data-lsp lsp='(property) cars: 4' >cars</data-lsp>: </span><span style="color: #098658">4</span><span style="color: #000000">, <data-lsp lsp='(property) akitas: 2' >akitas</data-lsp>: </span><span style="color: #098658">2</span><span style="color: #000000">}&gt;&gt;</span></div><div class='line'><span style="color: #000000">  = </span><span style="color: #0000FF">true</span><span style="color: #000000">;</span></div></code></div></pre>
<p>because
all fields of the subtype match the fields of the supertype, and the
unmatched fields of the supertype (namely <code>akitas</code>) are optional, so they do not have to be
present in the subtype<span class="note"><label for="type" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="type" class="margin-toggle" /><span class="sidenote">Notice that it is also the case that <code>Partial&lt;{trees: 9, cars: 4, akitas: 2}&gt; &lt;: {trees: 9, cars: 4}</code>.
What does this say about the set properties of the TypeScript type system?</span>. Moreover<span class="note"><label for="trees" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="trees" class="margin-toggle" /><span class="sidenote">A natural question is,
why is <code>trees</code> not completely elided during the subtype comparison, forcing
<code>{trees: 1} &lt;: {}</code>? The reason is that the optional syntax (<a href="https://github.com/ayazhafiz/rats#lossy-type-downcasting">tries to be</a>)
structure preserving; informally, the checking algorithm for <code>{a?: T}</code> is &quot;if
<code>a</code> is not present, OK; else the type of <code>a</code> present must match <code>T</code>&quot;. Note that
this is distinct from <code>{a: T|undefined}</code>, which has no type relationship with <code>{a?: T}</code>.</span>,</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const subtype_test4: false' >subtype_test4</data-lsp></span></div><div class='line'><span style="color: #000000">  : </span><span style="color: #001080"><data-lsp lsp='type Subtype&lt;S, T> = S extends T ? true : false' >Subtype</data-lsp></span><span style="color: #000000">&lt;{<data-lsp lsp='(property) trees: 1' >trees</data-lsp>: </span><span style="color: #098658">1</span><span style="color: #000000">, <data-lsp lsp='(property) cars: 4' >cars</data-lsp>: </span><span style="color: #098658">4</span><span style="color: #000000">}, </span><span style="color: #001080"><data-lsp lsp='Make all properties in T optional&#10;&#10;type Partial&lt;T> = { [P in keyof T]?: T[P] | undefined; }' >Partial</data-lsp></span><span style="color: #000000">&lt;{<data-lsp lsp='(property) trees: 9' >trees</data-lsp>: </span><span style="color: #098658">9</span><span style="color: #000000">, <data-lsp lsp='(property) cars: 4' >cars</data-lsp>: </span><span style="color: #098658">4</span><span style="color: #000000">, <data-lsp lsp='(property) akitas: 2' >akitas</data-lsp>: </span><span style="color: #098658">2</span><span style="color: #000000">}&gt;&gt;</span></div><div class='line'><span style="color: #000000">  = </span><span style="color: #0000FF">false</span><span style="color: #000000">;</span></div></code></div></pre>
<p>because, in particular,</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const subtype_test5: false' >subtype_test5</data-lsp></span></div><div class='line'><span style="color: #000000">  : </span><span style="color: #001080"><data-lsp lsp='type Subtype&lt;S, T> = S extends T ? true : false' >Subtype</data-lsp></span><span style="color: #000000">&lt;{<data-lsp lsp='(property) trees: 1' >trees</data-lsp>: </span><span style="color: #098658">1</span><span style="color: #000000">}, {<data-lsp lsp='(property) trees?: 9 | undefined' >trees</data-lsp>?</span><span style="color: #001080">:</span><span style="color: #000000"> </span><span style="color: #098658">9</span><span style="color: #000000">}&gt;</span></div><div class='line'><span style="color: #000000">  = </span><span style="color: #0000FF">false</span><span style="color: #000000">;</span></div></code></div></pre>
<p>So for a single Sue, we can define a type constructor</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type IsTheSue&lt;Sue> = Sue extends Partial&lt;TheSue> ? true : false' >IsTheSue</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) Sue in type IsTheSue&lt;Sue>' >Sue</data-lsp></span><span style="color: #000000">&gt; = </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Sue in type IsTheSue&lt;Sue>' >Sue</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='Make all properties in T optional&#10;&#10;type Partial&lt;T> = { [P in keyof T]?: T[P] | undefined; }' >Partial</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type TheSue = {&#10;    children: 3;&#10;    cats: 7;&#10;    samoyeds: 2;&#10;    pomeranians: 3;&#10;    akitas: 0;&#10;    vizslas: 0;&#10;    goldfish: 5;&#10;    trees: 3;&#10;    cars: 2;&#10;    perfumes: 1;&#10;}' >TheSue</data-lsp></span><span style="color: #000000">&gt; ? </span><span style="color: #267F99">true</span><span style="color: #000000"> : </span><span style="color: #267F99">false</span><span style="color: #000000">;</span></div></code></div></pre>
<p>that will yield <code>true</code> when passed the Sue we're looking for.</p>
<p>But we need a way to perform this check over 500 (!)
candidates, so some control flow or parallel evaluation mechanism is required.
We can get the latter using TypeScript's <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types">distributive conditional
types</a>.
The idea is that when using a union type in a conditional type, the typechecker
will distribute the conditional type over the union's variants. For example<span class="note"><label for="unknownnever" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="unknownnever" class="margin-toggle" /><span class="sidenote"><code>unknown</code> is TypeScript's <a href="https://en.wikipedia.org/wiki/Top_type">Top type</a> - the
type inhabited by every value. <code>never</code> is TypeScript's <a href="https://en.wikipedia.org/wiki/Bottom_type">Bottom type</a> - the type
inhabited by no value. <code>T|never = T</code> because nothing can fit in <code>never</code>, so
the values inhabited in <code>T|never</code> are only those inhabited in <code>T</code>.</span>, consider
<code>AFields</code> below:</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type PickFieldA&lt;T> = T extends {&#10;    a: unknown;&#10;} ? T["a"] : never' >PickFieldA</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type PickFieldA&lt;T>' >T</data-lsp></span><span style="color: #000000">&gt; = </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type PickFieldA&lt;T>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> {</span><span style="color: #001080"><data-lsp lsp='(property) a: unknown' >a</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99">unknown</span><span style="color: #000000">} ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type PickFieldA&lt;T>' >T</data-lsp></span><span style="color: #000000">[</span><span style="color: #A31515">&apos;a&apos;</span><span style="color: #000000">] : </span><span style="color: #267F99">never</span><span style="color: #000000">;</span></div><div class='line'>&nbsp;</div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type AFields = 1 | "s"' >AFields</data-lsp></span><span style="color: #000000"> = </span><span style="color: #267F99"><data-lsp lsp='type PickFieldA&lt;T> = T extends {&#10;    a: unknown;&#10;} ? T["a"] : never' >PickFieldA</data-lsp></span><span style="color: #000000">&lt;{</span><span style="color: #001080"><data-lsp lsp='(property) a: 1' >a</data-lsp></span><span style="color: #000000">: </span><span style="color: #098658">1</span><span style="color: #000000">}|{</span><span style="color: #001080"><data-lsp lsp='(property) b: 2' >b</data-lsp></span><span style="color: #000000">: </span><span style="color: #098658">2</span><span style="color: #000000">}|{</span><span style="color: #001080"><data-lsp lsp='(property) a: "s"' >a</data-lsp></span><span style="color: #000000">: </span><span style="color: #A31515">&apos;s&apos;</span><span style="color: #000000">}&gt;;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const afields_test: true' >afields_test</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type Equals&lt;X, Y> = &lt;T>() => T extends X ? 0 : 1 extends &lt;T>() => T extends Y ? 0 : 1 ? true : false' >Equals</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type AFields = 1 | "s"' >AFields</data-lsp></span><span style="color: #000000">, </span><span style="color: #098658">1</span><span style="color: #000000">|</span><span style="color: #A31515">&apos;s&apos;</span><span style="color: #000000">&gt; = </span><span style="color: #0000FF">true</span><span style="color: #000000">;</span></div></code></div></pre>
<p>The construction of <code>AFields</code> proceeds roughly as follows:</p>
<pre class="shiki light-plus" style="background-color: #FFFFFF; color: #000000"><div class="language-id">text</div><div class='code-container'><code><div class='line'><span style="color: undefined">AFields = (1 | 's') due to the expansion:
    PickFieldA&lt;{a: 1}|{b: 2}|{a: 's'}&gt;
  =   ({a: 1} extends {a: unknown} ? {a: 1}['a'] : never)
    | ({b: 2} extends {a: unknown} ? {b: 2}['a'] : never)
    | ({a: 's'} extends {a: unknown} ? {a: 's'}['a'] : never)
  = 1 | never | 's'
  = 1 | 's'</span></div></code></div></pre>
<p>So we just need to feed a union of the 500 Sues into a conditional subtype check
against <code>Partial&lt;TheSue&gt;</code> (for example, the <code>IsTheSue</code> constructor above), and
we'll get the Sue we're looking for!</p>
<p>We can extract such a union from our <code>Sues</code> record type by mapping over all the keys of
<code>Sues</code>:</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Sues = {&#10;    1: {&#10;        goldfish: 9;&#10;        cars: 0;&#10;        samoyeds: 9;&#10;    };&#10;    2: {&#10;        perfumes: 5;&#10;        trees: 8;&#10;        goldfish: 8;&#10;    };&#10;    3: {&#10;        pomeranians: 2;&#10;        akitas: 1;&#10;        trees: 5;&#10;    };&#10;    4: {&#10;        goldfish: 10;&#10;        akitas: 2;&#10;        perfumes: 9;&#10;    };&#10;    5: {&#10;        cars: 5;&#10;        perfumes: 6;&#10;        akitas: 9;&#10;    };&#10;    6: {&#10;        goldfish: 10;&#10;        cats: 9;&#10;        cars: 8;&#10;    };&#10;    7: {&#10;        trees: 2;&#10;        samoyeds: 7;&#10;        goldfish: 10;&#10;    };&#10;    8: {&#10;        cars: 8;&#10;        perfumes: 6;&#10;        goldfish: 1;&#10;    };&#10;    9: {&#10;        cats: 4;&#10;        pomeranians: 0;&#10;        trees: 0;&#10;    };&#10;    10: {&#10;        trees: 2;&#10;        children: 10;&#10;        samoyeds: 10;&#10;    };&#10;    11: {&#10;        akitas: 10;&#10;        perfumes: 4;&#10;        vizslas: 1;&#10;    };&#10;    12: {&#10;        akitas: 1;&#10;        trees: 0;&#10;        goldfish: 3;&#10;    };&#10;    13: {&#10;        perfumes: 6;&#10;        goldfish: 10;&#10;        cars: 8;&#10;    };&#10;    14: {&#10;        cats: 8;&#10;        akitas: 5;&#10;        vizslas: 0;&#10;    };&#10;    15: {&#10;        cars: 8;&#10;        trees: 3;&#10;        samoyeds: 5;&#10;    };&#10;    16: {&#10;        vizslas: 6;&#10;        cats: 6;&#10;        pomeranians: 10;&#10;    };&#10;    17: {&#10;        akitas: 6;&#10;        cats: 2;&#10;        perfumes: 9;&#10;    };&#10;    18: {&#10;        children: 9;&#10;        goldfish: 2;&#10;        akitas: 10;&#10;    };&#10;    19: {&#10;        trees: 3;&#10;        perfumes: 0;&#10;        goldfish: 6;&#10;    };&#10;    20: {&#10;        vizslas: 3;&#10;        akitas: 0;&#10;        trees: 1;&#10;    };&#10;    21: {&#10;        vizslas: 3;&#10;        cars: 7;&#10;        akitas: 3;&#10;    };&#10;    22: {&#10;...' >SueC</data-lsp>andidates</span><span style="color: #000000"> = </span><span style="color: #267F99">Sues</span><span style="color: #000000">[</span><span style="color: #0000FF">keyof</span><span style="color: #000000"> </span><span style="color: #267F99">Sues</span><span style="color: #000000">];</span></div></code></div></pre>
<p>This says &quot;index <code>Sues</code> by every key of <code>Sues</code>, and give be back all of those
results&quot;. Clearly, this must be a union type, since we are extracting all of 500
individual types.</p>
<p>To understand how this works, let's perform a small expansion. Recall <code>Sues</code> is
of the form</p>
<pre class="shiki light-plus" style="background-color: #FFFFFF; color: #000000"><div class="language-id">typescript</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99">Sues</span><span style="color: #000000"> = {</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #098658">1</span><span style="color: #000000">: {</span><span style="color: #001080">goldfish</span><span style="color: #000000">: </span><span style="color: #098658">9</span><span style="color: #000000">, </span><span style="color: #001080">cars</span><span style="color: #000000">: </span><span style="color: #098658">0</span><span style="color: #000000">, </span><span style="color: #001080">samoyeds</span><span style="color: #000000">: </span><span style="color: #098658">9</span><span style="color: #000000">},</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #098658">2</span><span style="color: #000000">: {</span><span style="color: #001080">perfumes</span><span style="color: #000000">: </span><span style="color: #098658">5</span><span style="color: #000000">, </span><span style="color: #001080">trees</span><span style="color: #000000">: </span><span style="color: #098658">8</span><span style="color: #000000">, </span><span style="color: #001080">goldfish</span><span style="color: #000000">: </span><span style="color: #098658">8</span><span style="color: #000000">},</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #008000">/// 498 more Sues</span></div><div class='line'><span style="color: #000000">};</span></div></code></div></pre>
<p>Now, <code>Sues[keyof Sues]</code> becomes</p>
<pre class="shiki light-plus" style="background-color: #FFFFFF; color: #000000"><div class="language-id">typescript</div><div class='code-container'><code><div class='line'><span style="color: #000000">  </span><span style="color: #001080">Sues</span><span style="color: #000000">[</span><span style="color: #098658">1</span><span style="color: #000000">|</span><span style="color: #098658">2</span><span style="color: #000000">|...|</span><span style="color: #098658">500</span><span style="color: #000000">]</span></div><div class='line'><span style="color: #000000">=   {</span><span style="color: #001080">goldfish:</span><span style="color: #000000"> </span><span style="color: #098658">9</span><span style="color: #000000">, </span><span style="color: #001080">cars:</span><span style="color: #000000"> </span><span style="color: #098658">0</span><span style="color: #000000">, </span><span style="color: #001080">samoyeds:</span><span style="color: #000000"> </span><span style="color: #098658">9</span><span style="color: #000000">}</span></div><div class='line'><span style="color: #000000">  | {perfumes: </span><span style="color: #098658">5</span><span style="color: #000000">, trees: </span><span style="color: #098658">8</span><span style="color: #000000">, goldfish: </span><span style="color: #098658">8</span><span style="color: #000000">}</span></div><div class='line'><span style="color: #000000">  | ...</span></div><div class='line'><span style="color: #000000">  | </span><span style="color: #001080">Sues</span><span style="color: #000000">[</span><span style="color: #098658">500</span><span style="color: #000000">]</span></div></code></div></pre>
<p>We could immediately do <code>IsTheSue&lt;Sues[keyof Sues]&gt;</code>, but this actually is not
very useful! Thanks to distributive conditional types, <code>IsTheSue&lt;Sues[keyof Sues]&gt;</code> would yield <code>false | false | ... | true | ... | false = boolean</code>, and this gives us no information about who the actual Sue we were
looking for is.</p>
<p>What we can do is something like this:</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Sues = {&#10;    1: {&#10;        goldfish: 9;&#10;        cars: 0;&#10;        samoyeds: 9;&#10;    };&#10;    2: {&#10;        perfumes: 5;&#10;        trees: 8;&#10;        goldfish: 8;&#10;    };&#10;    3: {&#10;        pomeranians: 2;&#10;        akitas: 1;&#10;        trees: 5;&#10;    };&#10;    4: {&#10;        goldfish: 10;&#10;        akitas: 2;&#10;        perfumes: 9;&#10;    };&#10;    5: {&#10;        cars: 5;&#10;        perfumes: 6;&#10;        akitas: 9;&#10;    };&#10;    6: {&#10;        goldfish: 10;&#10;        cats: 9;&#10;        cars: 8;&#10;    };&#10;    7: {&#10;        trees: 2;&#10;        samoyeds: 7;&#10;        goldfish: 10;&#10;    };&#10;    8: {&#10;        cars: 8;&#10;        perfumes: 6;&#10;        goldfish: 1;&#10;    };&#10;    9: {&#10;        cats: 4;&#10;        pomeranians: 0;&#10;        trees: 0;&#10;    };&#10;    10: {&#10;        trees: 2;&#10;        children: 10;&#10;        samoyeds: 10;&#10;    };&#10;    11: {&#10;        akitas: 10;&#10;        perfumes: 4;&#10;        vizslas: 1;&#10;    };&#10;    12: {&#10;        akitas: 1;&#10;        trees: 0;&#10;        goldfish: 3;&#10;    };&#10;    13: {&#10;        perfumes: 6;&#10;        goldfish: 10;&#10;        cars: 8;&#10;    };&#10;    14: {&#10;        cats: 8;&#10;        akitas: 5;&#10;        vizslas: 0;&#10;    };&#10;    15: {&#10;        cars: 8;&#10;        trees: 3;&#10;        samoyeds: 5;&#10;    };&#10;    16: {&#10;        vizslas: 6;&#10;        cats: 6;&#10;        pomeranians: 10;&#10;    };&#10;    17: {&#10;        akitas: 6;&#10;        cats: 2;&#10;        perfumes: 9;&#10;    };&#10;    18: {&#10;        children: 9;&#10;        goldfish: 2;&#10;        akitas: 10;&#10;    };&#10;    19: {&#10;        trees: 3;&#10;        perfumes: 0;&#10;        goldfish: 6;&#10;    };&#10;    20: {&#10;        vizslas: 3;&#10;        akitas: 0;&#10;        trees: 1;&#10;    };&#10;    21: {&#10;        vizslas: 3;&#10;        cars: 7;&#10;        akitas: 3;&#10;    };&#10;    22: {&#10;...' >AllT</data-lsp>heSues</span><span style="color: #000000"> = </span><span style="color: #267F99">Sues</span><span style="color: #000000">[</span><span style="color: #0000FF">keyof</span><span style="color: #000000"> </span><span style="color: #267F99">Sues</span><span style="color: #000000">];</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99">MatchingSue</span><span style="color: #000000"> = </span><span style="color: #267F99">Extract</span><span style="color: #000000">&lt;</span><span style="color: #267F99">AllTheSues</span><span style="color: #000000">, </span><span style="color: #267F99">Partial</span><span style="color: #000000">&lt;</span><span style="color: #267F99">TheSue</span><span style="color: #000000">&gt;&gt;;</span></div></code></div></pre>
<p>and <code>MatchingSue</code> would be a union of all Sues whose fields match corresponding
ones in <code>TheSue</code>. To see why, let's expand this a bit:</p>
<pre class="shiki light-plus" style="background-color: #FFFFFF; color: #000000"><div class="language-id">typescript</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99">Extract</span><span style="color: #000000">&lt;</span><span style="color: #267F99">T</span><span style="color: #000000">, </span><span style="color: #267F99">U</span><span style="color: #000000">&gt; = </span><span style="color: #267F99">T</span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">U</span><span style="color: #000000"> ? </span><span style="color: #267F99">T</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000">;</span></div><div class='line'></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99">AllTheSues</span><span style="color: #000000"> = </span><span style="color: #267F99">Sues</span><span style="color: #000000">[</span><span style="color: #0000FF">keyof</span><span style="color: #000000"> </span><span style="color: #267F99">Sues</span><span style="color: #000000">];</span></div><div class='line'><span style="color: #000000">                = {</span><span style="color: #001080">goldfish:</span><span style="color: #000000"> </span><span style="color: #098658">9</span><span style="color: #000000">, </span><span style="color: #001080">cars:</span><span style="color: #000000"> </span><span style="color: #098658">0</span><span style="color: #000000">, </span><span style="color: #001080">samoyeds:</span><span style="color: #000000"> </span><span style="color: #098658">9</span><span style="color: #000000">}|{perfumes: </span><span style="color: #098658">5</span><span style="color: #000000">, trees: </span><span style="color: #098658">8</span><span style="color: #000000">, goldfish: </span><span style="color: #098658">8</span><span style="color: #000000">}|...</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99">MatchingSue</span><span style="color: #000000"> = </span><span style="color: #267F99">Extract</span><span style="color: #000000">&lt;</span><span style="color: #267F99">AllTheSues</span><span style="color: #000000">, </span><span style="color: #267F99">Partial</span><span style="color: #000000">&lt;</span><span style="color: #267F99">TheSue</span><span style="color: #000000">&gt;&gt;;</span></div><div class='line'><span style="color: #000000">                 = </span><span style="color: #001080">never</span><span style="color: #000000">|</span><span style="color: #001080">never</span><span style="color: #000000">|...|{</span><span style="color: #008000">/* some sue that matches */</span><span style="color: #000000">}|...|</span><span style="color: #001080">never</span><span style="color: #000000">|</span><span style="color: #001080">never</span></div><div class='line'><span style="color: #000000">                 = {</span><span style="color: #008000">/* some sue that matches */</span><span style="color: #000000">}</span></div></code></div></pre>
<p>The <code>never</code>s all collapse because they cannot be inhabited by a value and hence
do not contribute to the union type; in the end we have just the Sue(s) we're looking for.</p>
<p>Well actually, we're not quite done, because part 1 of the problem asks us for
the index number of the Sue in <code>Sues</code> that <code>MatchingSue</code> corresponds to. I am not aware of a way of
to perform an inverse lookup of a non-primitive type in a record type, so we
can't find the index of a Sue in <code>Sues</code> after it's been extracted.
However, we can propagate the index of each Sue by adding it as an extra
field on the info we know about each Sue before constructing their union and
performing the matching:</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Sues = {&#10;    1: {&#10;        goldfish: 9;&#10;        cars: 0;&#10;        samoyeds: 9;&#10;    };&#10;    2: {&#10;        perfumes: 5;&#10;        trees: 8;&#10;        goldfish: 8;&#10;    };&#10;    3: {&#10;        pomeranians: 2;&#10;        akitas: 1;&#10;        trees: 5;&#10;    };&#10;    4: {&#10;        goldfish: 10;&#10;        akitas: 2;&#10;        perfumes: 9;&#10;    };&#10;    5: {&#10;        cars: 5;&#10;        perfumes: 6;&#10;        akitas: 9;&#10;    };&#10;    6: {&#10;        goldfish: 10;&#10;        cats: 9;&#10;        cars: 8;&#10;    };&#10;    7: {&#10;        trees: 2;&#10;        samoyeds: 7;&#10;        goldfish: 10;&#10;    };&#10;    8: {&#10;        cars: 8;&#10;        perfumes: 6;&#10;        goldfish: 1;&#10;    };&#10;    9: {&#10;        cats: 4;&#10;        pomeranians: 0;&#10;        trees: 0;&#10;    };&#10;    10: {&#10;        trees: 2;&#10;        children: 10;&#10;        samoyeds: 10;&#10;    };&#10;    11: {&#10;        akitas: 10;&#10;        perfumes: 4;&#10;        vizslas: 1;&#10;    };&#10;    12: {&#10;        akitas: 1;&#10;        trees: 0;&#10;        goldfish: 3;&#10;    };&#10;    13: {&#10;        perfumes: 6;&#10;        goldfish: 10;&#10;        cars: 8;&#10;    };&#10;    14: {&#10;        cats: 8;&#10;        akitas: 5;&#10;        vizslas: 0;&#10;    };&#10;    15: {&#10;        cars: 8;&#10;        trees: 3;&#10;        samoyeds: 5;&#10;    };&#10;    16: {&#10;        vizslas: 6;&#10;        cats: 6;&#10;        pomeranians: 10;&#10;    };&#10;    17: {&#10;        akitas: 6;&#10;        cats: 2;&#10;        perfumes: 9;&#10;    };&#10;    18: {&#10;        children: 9;&#10;        goldfish: 2;&#10;        akitas: 10;&#10;    };&#10;    19: {&#10;        trees: 3;&#10;        perfumes: 0;&#10;        goldfish: 6;&#10;    };&#10;    20: {&#10;        vizslas: 3;&#10;        akitas: 0;&#10;        trees: 1;&#10;    };&#10;    21: {&#10;        vizslas: 3;&#10;        cars: 7;&#10;        akitas: 3;&#10;    };&#10;    22: {&#10;...' >Sues</data-lsp>WithNames</span><span style="color: #000000"> = {</span></div><div class='line'><span style="color: #000000">   [</span><span style="color: #267F99">S</span><span style="color: #000000"> </span><span style="color: #0000FF">in</span><span style="color: #000000"> </span><span style="color: #0000FF">keyof</span><span style="color: #000000"> </span><span style="color: #267F99">Sues</span><span style="color: #000000"><data-lsp lsp='(type parameter) X in type Equals&lt;X, Y>' ></data-lsp>]:<data-lsp lsp='(type parameter) Y in type Equals&lt;X, Y>' > </data-lsp>{</span><span style="color: #001080">name</span><span style="color: #000000">: </span><span style="color: #267F99">S</span><span style="color: #000000">}&</span><span style="color: #267F99">Sues</span><span style="color: #000000">[</span><span style="color: #267F99">S</span><span style="color: #000000">];</span></div><div class='line'><span style="color: #000000">   </span><span style="color: #008000"><data-lsp lsp='(type parameter) T in &lt;T>(): T extends X ? 0 : 1' ></data-lsp><data-lsp lsp='(type parameter) T in &lt;T>(): T extends X ? 0 : 1' ></data-lsp>// pro<data-lsp lsp='(type parameter) X in type Equals&lt;X, Y>' >d</data-lsp>uces rows of form &quot;1: {name: 1, cats: 10, goldfish: 5, ...}&quot;</span></div><div class='line'><span style="color: #000000">};</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99">AllTheSues</span><span style="color: #000000"> = </span><span style="color: #267F99">SuesWithNames</span><span style="color: #000000">[</span><span style="color: #0000FF">keyof</span><span style="color: #000000"> </span><span style="color: #267F99">SuesWithNames</span><span style="color: #000000">];</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99">MatchingSue</span><span style="color: #000000"> = </span><span style="color: #267F99">Extract</span><span style="color: #000000">&lt;</span><span style="color: #267F99">AllTheSues</span><span style="color: #000000">, </span><span style="color: #267F99">Partial</span><span style="color: #000000">&lt;</span><span style="color: #267F99">TheSue</span><span style="color: #000000">&gt;&gt;[</span><span style="color: #A31515">&apos;name&apos;</span><span style="color: #000000">];</span></div><div class='line'><span style="color: #0000FF"><data-lsp lsp='(type parameter) S' ></data-lsp>const</span><span style="color: #000000"> </span><span style="color: #0070C1">matching_sue</span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='(property) name: S extends keyof SuesList' ></data-lsp><data-lsp lsp='(type parameter) S' ></data-lsp>MatchingSue</span><span style="color: #000000"> = </span><span style="color: #098658">40</span><span style="color: #000000">;</span></div></code></div></pre>
<p>Finally, we have the name of the Sue we were looking for!</p>
<h2 id="part-2" tabindex="-1"><a class="header-anchor" href="#part-2" aria-hidden="true"></a>Part 2</h2>
<blockquote>
<p>If you would like to follow along with this solution, I have provided a
<a href="https://www.typescriptlang.org/play?ssl=34&amp;ssc=6&amp;pln=34&amp;pc=14#code/C4TwDgpgBAKgFhAygV2gXigbwFBSgYzgEsAbAEwCcIA7ALigGYAaXAgQ2AGd6B2FvTmwC2AexAQy3KACZ+UMCKEQKbakVVTmrNgGsiwNlIAMcgG5EAXpxKH6J1gHMR5AGZFOcegFY5wKhE05fDYKKVlWSAoXZCUpAEYWAF8AbmxsUEgoACERZxgA4AAeGCgIAA9gGkkoACNckghVJigAUVKKqs5a+sbqAD4oDBLyyupqtoB+KAByAHkAaWmoemmAMQBBAEkAGWnU9PBoGGQwGBEAORji9tHq5GodahEAd2oAbQBdAaGbzqwG6gOYCeKBEaguZRQc6JKBTc7LKDUCCmZSpDLQNiDWAnM6XISFN7TNjTZp+VDNIwAOi8X2SUAA9PTGGl0VCYmdjmBCvCRn9qDEaspmpzfmMuvdHi93h8sZ9vqw8CLeWL-jQgSDobDsWAEXiOSduc03pSTZzmhKnq9aQdMlksXqRJzCgw+vtWSgan42PgiutRdV+UJBRRmnblQGBcp5Xg8A6nesBuGusaTWCIRQoAARIguFzNE2UuMGrJ9GVTTm4q7Z3N9ehIlEUN2HKAAcSoHGU8FUhT9ScRkZD2X9XUDwe+UF7HRVRlhCqgLjYJE40Foc7DU+qM6mZJXrfblQoXeohQ9Xp9PeacT6zVPKnPWUvfVdLObLZg+U4wDiWJyeQKhTbRoDyPQpZCgK9SQoVBn1ZN8P2AaQf3qeCAP3Ts4G7BJwOvedF2XGDX3fAoGCQv9P1QoD0Mw5ppBwhclwgZ8bWgbYAk4EDJ1uEcB1DYd+yDKMfz4rc53o5dljnTi-i3KAdwRVjOHYjDj1vb1fUfG9kE9O8igfbCmNZbYiM-b8MF-EgUIUpTqJkHCdwIzIjPgxCzOQ-8rJArCINwhiHJY4zgBI1yyKKDzlNAjSfPwptMgAYQQfAdEAjtD3C1Y+J0CAQBEFxYAQFAIGFPjMDeXKwSgVYPgmOsB0SaMYxgN5Kr40dISmEqyuoCqPnoZLgPCxrKuFfLUCar5EgAMlmIR9GKZpVj6OcY2WlbVrwegYBi6B4ogRKwu7dK+0y7LcvgJByVgYrStBLrKuq-jgzqwY50GmU+1ajN2uu8rKvofbj1e4bzogMa+km6bZpgebFrW2G4Y2raoAABRCYB1BIABVah8BEahPxUMEJGKcccDwN4kZuqBjpy2AqvoVQQFSFJmKgAqdsS1YiAgchOD65Rrj7FGKDRxcsZxvGvUJshihGxj6rwdmkrQ1Lu2mPwIACEkoEVvmVePaZgi4LWYCfNFmzZhKdE57nJCs-nhg3LohZFzHsdx-G2ClmXgafZ7lsV-7CmmBQlBUNQNC1gO2JA6YnFcdw4GN02X0yC3dqtrmeYFx3kdR9GxfdyWkWls6Ct9tA5zTjnM9ttj+arjObd55XiYM5tFYka2eaxNX-E4aYAB8DY4fuh5D5RVHUPHB9j5wyDcDw9hZ0vUA7sgsQhooV8K7XLc7mvOD6CaOspteu8kHrZKgiBmZZgrODXgB1fQ4HOYQAixUmoDeRBKep3L76X0wNQd+9BECTQbufTgJ5UCcB-taZmrJ1gkAsrLLoGB75Pxfm-WIbx-6s1gVg4EOCAgfDNpkAAshwQgYIHAFSxC0CoOkewoO3pwZozt0bewbhIJ8hIQFKGmGQlO0B76f1YHEegmA47zwTvQAAnHSYIoQ7B0kEKIcQkgFHMzwNIKRkRoixG8HSdWAR6AAA46QyIXiCcxOjGD6MUBPcOeN6DSDpLofQthwImL7t4exAAWKR1i5HgSMB4vQBgwh0gMTEMxUB5H2K8FI5RUgvAxOUIY+JAA2CJXipCJNSHgbJwS542PoHEcJ7AuAKKUSEKQdiilQB4FI0x0SoDqLEBIKQPArFlNCZU+x5iUn1IsRkqIcSpC5KgCEjwFT7HyJGTUqAASYlOLDlPYwviNbGHsZU1pfiZBKOIOQKgdAwlqOEF0rRYS9mSKwJ4qJFSqmxKMSsuk5grA2HiHsvRDzIneLiNs+JVTZkggYHshg+jMmTPoNMsFzy6kqKgI0iRQSsCGwaXkp5UB0lQE+dYbxRg9nJIxaMlFwLNCXI0d0-xTS4glKwAS75cK6nLOmePDZGhnl7Jaf8-JrLqntNefEwpEjhkYpOZQGgtSZn9LmUcqAjzAXEvpYsrAbT6AMHGVkrZcr44KuyfY6QRgpHMu8dqpVAK9WavAsa+5mBzVUvYMi3pVqBWMGNX8zAIqenHNINK85QL5DrMnty5pxqoUasOZUpFBTsUquNeizAyq0l9INSCaZTq4XGtJZgTpmjnW2ssfiywhK0nGsZY6stLL3khtDmG1xirbVxGNXyzAqTZUIubYcgJxqJXVq+d4+F8qQSxvkDCt5PBjXqsHeWwVnLG3OtTTmppDBTXRp2aojpVzC3GPdTisVeAGAOuzT4idEy3lVNtUatd3rO3NI+TWwF-rTkytuWuqNc7a3BofcG31vB7EMGTWexRV8t0XIPd4o9jA80rsYE+odaaXXxFVawBgVbMVatfYG2VBbaWerXe2s9eLF0uL9Sh1d6GB1-qqfBvFZ7UXHtnfRylsqaFvvOdIQJG7v1ErZRR+DaG8ABIdQ+sDLaXmTviUxlZ3r4OrPA-E9x+rZEKohU0gJX7u2-pHhUhNDTAnJu7SW+DYGz19s03mgDCHVPlLrba4TKyq22rdTZ4NJnAntrI5sxFlHH1KbCIEgdtqVPwd08iyzrAAmzu7aR6TgnrUWKSbxsziH50JLYzIJJYnyVVPwzcqpjGknesczq2FUAOWhvI-QKLeAvBfrPbp9lBmtVJOTQVrFUH4jpdrXV3FeadNScvcptZDaasftYF4FzhywM2ctXFpJ7b4OWps1UrD2WmleAHTZxTFm43Ja27F0dvAcNnP3T58Nsnsm8b-Vl-9CWeVNOyQ621inOu1YO5V+x2T5NJcg6F3rw6fvaZO7ZmzbqmtOeycmy7Ta8Ucdw5Bh90O81Q6+yW+bP3MNSvO7ioHUhFPheh+2xHeOOWPYCw+jTrBskDpM196ZZP32tue7Okj5W3mWvE-YngvHu3rb05VznILeevcOSpj7tm-28-vULy18GS1nunU0ngX6VsE7cemtTmbeew+q75yDUuwMbdkzwNHz6KMPrdcT3nOOA14+50LrNlu2uq-bd2tzBvw3jsc7zgdoGzvvrdZJ3ns6b1jecYbktUvWesHMbxjnBBcfvqq+Nw3Xghm5eReZ13mXuvaKaeY71Z6nfItM-9uPeBzGNbz4pwHQr5lF+Tcz85Cv-tFbz1XlFeaNsu6Q-u+D3Gi+YfJe3j1brPNF-bVLpXeeFtg9k+YgPdeg-nMF8slX8fjsZtlXD1D1Lrm7KafI3jEeC-S-JVvvA8iHVS-HzitzlPBkn7l66yPXKm2+4lwsr9se1-Yb+Y0434da7oEYV4T6a5QBObyKDZg5uqt5a7+a3qsDyKj7IqraU5ga24n7Lb-Ym7krjpQ4LIha9ra72aY7e5NrX4JKzpS5p5R7hqd4D4Rr0pGCpb-ZP4jZdal57JGDZ7IbuZZZOaVJ-YeoMGf4H6BZ2B8Ffq2qYHcH7obYwaVLGZg7jo2YQE4oiFGBwG77C6losF4qhZ8FVr754ZgE3IaHP46Gk7kpz4sFE7-bD4SJGA0ZC6grwHCF8GzrU4f5LqComH0r7JYC7bkGhJ4o4ESJxACGAFhH1qMFNr9YxFy7LIqZDatbQF3JfobbjqIHQH3Z3LJrE5QEL76EiFxB5r37hGGpQHd4xHoHOo2bGGHIoF4AxF4Eepgaz41G2J3I7ZUGCE2GFHBE7464LqU7c4p5Bq-Jn4xoAHg6DFUbtHSAOrwYIGEHMEZYqHSClZkEX4x6WGoa-I5FC6KYPoOHbG-It6bELHBp+70rSB6HjH44JGSH7pBESLSBVo6ZQFaGJqPHEar7+bYGV6-L06L4i7Oo86PFjH2ZzZLH57uaQpzEQbBqB4Xq6pu4SInopLTGBGHKXG1qyZxAMBv49aGEZZTEO7B6QqnHv7J40lBpQnLHgTAYHIQZEkWqH57qbY4m95C5zaU6KbmGsE4lmGU50b-ZclTKQoe5g4tEQZbG1o0GkmkFoksmKq0aQp0FHFjJ2ahIloPFoqJ5d7DZYn54C57KibQqKFU7koEHLKZ70oBJ7EQaS56lal5bWn0kUlCEX71EBIgZ54EEMmikv5orWaIkek0o3IIH4lintEBJVpnpM4Om9GAYuntoN5NYCaF5oo7ZYFZYimInOloq6mxldb5Hokhkkq3by5ZYqYWYkoOqe6ZHf4QbAHgReDerxHK5fbJENaOLp7hpOEerKkWokqgGVn6k5lmkkoW4sEbGb7+ETZlntHTalL6EaGIk1ksH1FeB2HIoU52kh6zYkrqnxJ4rG4ZmEYSJeCzqiljk4r94ZYkk3ZbkvHxlMnbobYiEvZmp56REd48kEYuHtG-ZSIKYLETmaB7LZJ-6ekqZra3kqEw4jI55-GZFtHgTZJVGem54sFCl2nrm4WNEXaInvaenvlHlSHzagU3I4UMoDEjlNolrdoSbnn0rZLs55427-aWpS7JF85LLtIC5QHCUOr0UGkKp5Hy68reptkX5pnIoiFq4YXxoyUgj8UeqkVxA8BqH6FpnLKwWHYSLm62kWnLlSHan0o8BVo3mUl9armG4RntE8DeaSnCFfZuXgQ8Ar4sFM4Jluqx68q8UsElr5HTLGntEJ4aX6ZOXDojHiqnpmmall4-L0rF4ckyYMWaXW57I17xUGFnrIWU6qnmLJq2rXkEWZEiHmICnl63lGm9qFUOWekjrbmNmFWeV2n3ES6ZEVUDpS4I7konkWngXgTmIVlH76ndoKEWl6Wn5QXOF5nnqhVqri4QbAUeoebwF7LyIl7z7eWYkVbJHyK+lxHCmZFdlxDyKw7XWJVVkJnnWLkZbBrVHIEHXkWvE2avm1qTV3VAkRWZGRXO4HXuGYUX7IWImqnyK+GCnYU+VOYmqmn7kvLRmoXGr8GAVEV5WfYX5dkmpiE4qjVpFQEo1GBfr+n5EP4AmsAmpVX7H9kX4wYmp5rFqamhmZUM1GA-Fg7RWHKjXl7Y2dE4qWqMZZayYmoBUZYinlXtmU0I1Q0Q5Y1NKrFo0ZYqYbZhaV4o0xErW7VZYZVuL2qKUKknXK72rq4CWal7kZakWrEPV2mraIkqXH4M2VGfn2bNb5Vj72r836EImsVTL41ZHq36XFWC3umamTWrGy21plEvH-EVoR0I3LLEVWVfaO0mrDmJHIb7aN64pepbUgqDW3m+W7Ek3eLa1j5QE52g76ELUVY6U4r9a7HTmzVemRZQE0G7Ec1C1fbmkVYo3fE5ViXqHD1vI4W7G0WzmzbYVeoQnbnXoxpT2i7q3SC+HBVh2Kbdoz3rq43bF213Eo24lMp54tXbWZFs1kmG2k2oXJW6IMC14sGWoN75G32d28mY5eVF1n3WaPWl6ZGO0YZ53vGvHAOs2Rp2HLL9UQaQ5AWRo0YJlk2E5h2gPh6HJ00T1GVJr85g6cUamnVvLd7SA2lkrIow0h0JVS5x2un3013G0DlJqv0ZbTJD5h191Bnj3brNFfbcPPE+3r0F2X1JpVpCaamC7IpkMBIz7UW3nSOynq0BKFl2nrYJkdnxKV0xaWUVYcP-ZoN0oM1eCa0qmZHnFC6O1eB36enPkvrSEoq5q9mU6UE0OvEy7q1Dn8o4paPoNF1E1eDO0TVrXpGEO5qNX+MtoWO5rtUzmWlg5SldG5rA3H0kOjZaWm1eNqMWkRaaUbUmNYNKmKNh1E0fmhEK3+Z7XlGVqxEFGON4r72VrV0UZQOimO0IW8PnpQPzWVrFGcESUwWVr4XxOKll0X7t3ZISl2lgYcUY6Vpz0BbuYY3uPS107FVJOP6amTOPmIlKN742Ftq8ax4iN+YwkM08BrGrVPX6kbaO08AtOAGf1h2V3qUVN2m10yOeH6HS0GXFXUmcZ+bLNtoCkZ0gPeHq32WMOh2MmAuKpNZtreZu33b5aelE3+XFVcG5Or1oltrK0wuilX3Kb9q8aimOl6oQ79qpXo2P1vEBHF3q3ZXvMWlUXxMbE579qXX56plZaO2VWYv3YSX9ojNd172T1rXt3mJxNd2bPeLnGoP9rZnzHpPOpDb9osX51+Ya7+Zx3TVdNe7uNisr0zrHOenWHqNfZs237Qt8Ow1Cvq2HWiVIGS2ZMMsM0XVH21oSH0uZ0j0zr9PiECP10zpCOhKyt+0mUzqB0vHwPjMPoz3yK9UWnGVdaikJvuEmW3njUVZx3w3FX2MUknNAbsHe2hLdEdVrWkXrp1OmUBYxWMBGDm1B0vMLE4XrpcvZtTph2ybrpM2cm0uf3FuAMWv+aNNg79brqj7LIm0BZW1rpGBIuGuanu1ZPoZuHFWgmBuusTtGC7PuNNlpWuu+Unq3YJkb7+PrFAYG2So-mQaK5QGTUnr3qoND32voakl6OkM4vxKu3uMwYnrf0EZJ32Yqa2r-te2UPtJ3MuU+5OYnpTsEvIuwtI7gewPtJtPP5XsDrhbpV1Fwd3UCsqvbr1tkkENGVh3esTYTurFdNhPkfId45we7GlsKrfvtKK5AbSDU2Y07rxOEXvWcd9vxJGsvGUeG5ttPG0cwdNrAcDKcfTMstZu8ucdi3cn+Zg1pGccZswtnrhurvHpb2fs-sV16d3nHqH1YDzV1GL2fpSWPXROutVt32WdeE3P57hZAYv14m3tg1NWOMTvsmQcJU8uONwcMChsKqfPsdgmfrRv2Y7UP2OP-sMCLMMZ56dWieefaeyrascWecsa21F3a3BVAYBJkcvErOasUpEcJKlel0Uu7m3lVsMMucr3MNucTtaZOu2b-4Mep6lfBMVYAtI6std2PsBK94JnR0ZM6alczYx10sTaycKrNeqdSEs0tqlc5NnWZEHtLmlePmuO3kS1INrqmNdMlnuMJf03Ho2NGfIbiYQvoY9k2sGH5FEvHFneIVstI0ddAZBPedwuzOufNH-cD3EPxGePPfSu8kPZ2mXdVc9uHn6smd1X-fYeV5QEruJmwbhVUnNXFlAblMpp60PvG1E+2PxNic+5SNE-eqfV3ahdE9sO1qVcQObtt1E+DdvLB2I9QH-t4WeveLsv+PAtrpTMbMYMmdE+k4vX10xPi-DW1U1d7bpdE+HckUDkYNAYiU+NqelV20691MadW4KtEZHV401e627VwdvOYCSbSeaW9NEYt5y9VOnN8nHoWU3twshWelGPh3oZQt69SEjXBtEbyk-PtdY5EbL0xu1se+Ps8BFPaO92O+1ZAZxVYA9Fufv0-5rrmKtlg5lWa+8dd3-tMsdoNlufjr0aZ9cuT4W0HGZ+u+3sZfCNP2MANXdfW8vlcOZ8-V5Fu-dqPvmJod8OU7XcFKZ8asQOt38Zl+8kV8p96ppZuc9vLVBf1MO81f-vWtkpgtHse-HuOtb8neBVrVdkMAesX00sq9NdAb3X3cE0lGOOPuwHgP0vC2i+TGP9mGIn8da0U-fTowETbFVx0DON-o-225ds+u5yYHkHUf4Fct2OtW8jQTK7ld4SUjL7JNTK5iY3eunbqppkbavdLGfnJ8jxhZ7eJf6p5CujxkMrx8uGpRHjHBkx5udO2OSHjP-1WZKcAmPGSPi8T25y1BqPGSGnRWGK58eMePcxot0Nzy14egSEItInHZp8Gmig43idW7T9ZRM5JfUvwz+6aYP2t-fHhfj95U9FBQnClpTmx6+VRMUZJdo4zh7JtFBg-D3gYw9S4DI6zLfRmHVM5OZRMKDW9k4IqyADJyhguEmW1KaalZMrpTAaEjIHrc+KgSGjtn09KIMlyoTZIW6VT6usaBFpfwVx3+ax1yemmchlInoIU0bO0WSTpumM6mC6BpQn6kQxyFrZkhi7Krho1vbxY7SMQ6QGIIn52kgqt7bQYZxD6nZZB4aclqyS0z1kWsjgoeoEnPodoEyKdC7FgUWEuNS+r-MDosJtoep5B2LXuosMsFPNNGqLeJtoPC5C9kMI-XbosJh5AdGyjORYbL1vYc8F+opLslphgHaNTOUXTMtFmv7P8jcFbAMv4LK7XC-MDeDjppgoY+oju0NdPjjyDK6Dqu8hLNkZi5bVMXiaXIwkZmDIsFe+KqXekZjeoA1FaXNIzBI0K4utZusI1JjIPaYosjM2XAwss1bZGYV+SBB9GOx+aBJzutQvVPvVKb8i7OI7C4p3wm6PMHMhJSkVZkboxtNS8-ZRtFgB7GDE6PlZdvyPB45D1i0vKzA8JuSq9CRlrfkUmwqxD8ghUtfkT8L1QYkLi-I9OnqnyJnlOygSYnoXT7yx13R9XU4V0PmaaZIKrXL8qoPyKkVkyXLYAbZkWyBiCRGWNnl-wWGBiIuIIAtr+SsbuifqYzCkk00DHmiv2UtHyu6NtEv9CuKOd0dILU7W4kR3eORqS2fyqCYR0WS5ixzHTnCu6O5K7l5ibaicTqrQzTHbziyVC4BxjETH8zP6qCxezYskd4mzFdpF8XmakR4N4EuivM8jeJsfyRHhiMWgopAnMzc7+Dk+wIvJoKjy6aYs+PqREs3TeRzjau543LNOzqp-FgsvZXcqZw+6jiVkRVYMfZncG+NE+wWG4pm1dadCgewWSbsMIpHr9gsKZY6q6xNxnDgsrwuFib0FTEFzx-QgLK-xGrBZKxmleDNNyCyaZN+fGZDDhxHFusRM+-UiXNTBzXjOBxE7Ic6l65ptAkN-EnkbTc7f8zKVEgNm3S15ucYMMWGcRSU4ZFc2J83eJOkIdpVCqJa3eegtz+psSMenEhzkJTYn4tt0rGSQVthLYH9cGLxBCT52ZgpAgAA">TypeScript playground</a> with all the code. To see what types have been
instantiated, simply hover over their name; for example, hovering on <code>MatchingSue</code>
should yield <code>241</code>.</p>
</blockquote>
<p>Hopefully Part 1 gave you a feel for the power and expressiveness of
TypeScript's type system, and the relative ease by which we can perform
singleton pattern matching with the TypeScript typechecker.</p>
<p>Part 2 of the problem is a bit more complicated<span class="note"><label for="part2" class="margin-toggle"></label></span><input type="checkbox" id="part2" class="margin-toggle" /><span class="marginnote">Having built familiarity with the type system and with more work to do in this
part, we will move faster in our constructions.</span>.
Copying <a href="https://adventofcode.com/2015/day/16">the problem statement</a>
(not visible unless you have correctly answered Part 1):</p>
<blockquote>
<p>the <code>cats</code> and <code>trees</code> readings indicates that there are greater than that
many ..., while the <code>pomeranians</code> and <code>goldfish</code> readings indicate that there
are fewer than that many ...</p>
</blockquote>
<p>Clearly, we can't compare singularly-inhabited primitive types anymore, as,
for example, the value of <code>cats</code> in the Sue we wish to find can be any value
greater than the value inhabited by <code>TheSue['cats'] = 7</code>.
There is no way to formulate a type <code>GT_N &lt;: number</code> where <code>GT_N</code> is inhabited only by <code>number</code>s greater than some <code>N</code>
-- not directly, anyway. Our approach will be to find a way to mark relevant
fields (e.g. <code>cats</code>, <code>pomeranians</code>) in information known about each Sue as
greater or less than the corresponding field in <code>TheSue</code>, and then perform the
same subtype comparison as we did in Part 1 to find the matching Sue(s).</p>
<p>First, let's think about how we could perform greater/less than comparisons in
the type system. In general, this comparison can be done between two integers by
subtracting them and comparing the result to 0. There is no idea of numeric
subtraction in the TypeScript type system itself, so we need to find some
encoding for numbers on which we can perform an operation corresponding to
subtraction.</p>
<p>With some thought, the most natural idea is to encode natural numbers with
tuples. In TypeScript, a tuple type of the form <code>[T_1, T_2, ..., T_N]</code> holds <code>N</code>
values where the <code>t_i</code><sup>th</sup> value has type <code>T_i</code>. Each tuple type has a <code>length</code>
property whose type the number of type fields; in this case, <code>N</code>.
We will use the <code>length</code> property to encode natural numbers;
shortly, we will see how to exploit tuples for arithmetic operations.</p>
<p>To extract the natural number encoded in a tuple's <code>length</code> property, we define
a type constructor:</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type TupToNum&lt;T extends unknown[]> = T extends {&#10;    length: infer N;&#10;} ? N : never' >TupToNum</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type TupToNum&lt;T extends unknown[]>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">unknown</span><span style="color: #000000">[]&gt; = </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type TupToNum&lt;T extends unknown[]>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> {</span><span style="color: #001080"><data-lsp lsp='(property) length: N' >length</data-lsp></span><span style="color: #000000">: </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) N' >N</data-lsp></span><span style="color: #000000">} ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) N' >N</data-lsp></span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const tup_to_num_test: 3' >tup_to_num_test</data-lsp></span><span style="color: #000000"> : </span><span style="color: #267F99"><data-lsp lsp='type TupToNum&lt;T extends unknown[]> = T extends {&#10;    length: infer N;&#10;} ? N : never' >TupToNum</data-lsp></span><span style="color: #000000">&lt;[</span><span style="color: #A31515">&apos;a&apos;</span><span style="color: #000000">, </span><span style="color: #267F99">true</span><span style="color: #000000">, </span><span style="color: #098658">0.5</span><span style="color: #000000">]&gt; = </span><span style="color: #098658">3</span><span style="color: #000000">;</span></div></code></div></pre>
<p><code>infer</code> is arguably the most powerful construct provided by the TypeScript
typechecker; it instructs the typechecker to construct a constraint to resolve
an uninstantiated type (in this case, <code>N</code>), and to solve the constraint
transparently. The typechecker is basically solving the type of <code>N</code> &quot;for us&quot;;
it's like type reflection inside the type system!
<code>infer</code> will be our best friend for this part.</p>
<p>To encode a number in a tuple, we can define a recursive type constructor that
builds up a tuple until its length is that of the number we wish to encode:</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type NumToTup&lt;N extends number, Tup extends unknown[] = []> = Tup extends {&#10;    length: N;&#10;} ? Tup : NumToTup&lt;N, [...Tup, unknown]>' >NumToTup</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) N in type NumToTup&lt;N extends number, Tup extends unknown[] = []>' >N</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">number</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Tup in type NumToTup&lt;N extends number, Tup extends unknown[] = []>' >Tup</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">unknown</span><span style="color: #000000">[] = []&gt; =</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Tup in type NumToTup&lt;N extends number, Tup extends unknown[] = []>' >Tup</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> {</span><span style="color: #001080"><data-lsp lsp='(property) length: N extends number' >length</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='(type parameter) N in type NumToTup&lt;N extends number, Tup extends unknown[] = []>' >N</data-lsp></span><span style="color: #000000">} ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Tup in type NumToTup&lt;N extends number, Tup extends unknown[] = []>' >Tup</data-lsp></span><span style="color: #000000"> : </span><span style="color: #267F99"><data-lsp lsp='type NumToTup&lt;N extends number, Tup extends unknown[] = []> = Tup extends {&#10;    length: N;&#10;} ? Tup : NumToTup&lt;N, [...Tup, unknown]>' >NumToTup</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) N in type NumToTup&lt;N extends number, Tup extends unknown[] = []>' >N</data-lsp></span><span style="color: #000000">, [...</span><span style="color: #267F99"><data-lsp lsp='(type parameter) Tup in type NumToTup&lt;N extends number, Tup extends unknown[] = []>' >Tup</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99">unknown</span><span style="color: #000000">]&gt;;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const num_to_tup_test: true' >num_to_tup_test</data-lsp></span></div><div class='line'><span style="color: #000000">  : </span><span style="color: #001080"><data-lsp lsp='type Equals&lt;X, Y> = &lt;T>() => T extends X ? 0 : 1 extends &lt;T>() => T extends Y ? 0 : 1 ? true : false' >Equals</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #001080"><data-lsp lsp='type NumToTup&lt;N extends number, Tup extends unknown[] = []> = Tup extends {&#10;    length: N;&#10;} ? Tup : NumToTup&lt;N, [...Tup, unknown]>' >NumToTup</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #098658">3</span><span style="color: #000000">&gt;, [</span><span style="color: #001080">unknown</span><span style="color: #000000">, </span><span style="color: #001080">unknown</span><span style="color: #000000">, </span><span style="color: #001080">unknown</span><span style="color: #000000">]&gt; = </span><span style="color: #0000FF">true</span><span style="color: #000000">;</span></div></code></div></pre>
<p>Now, we can define subtraction between <code>A</code> and <code>B</code> via a type constructor
that queries the typechecker for the elements missing between the elements of
<code>A</code> and <code>B</code> (let's call this <code>Diff</code>), and returns the length of <code>Diff</code>:</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Subtract&lt;A extends number, B extends number> = NumToTup&lt;A, []> extends [...infer Diff, ...NumToTup&lt;B, []>] ? TupToNum&lt;Diff> : never' >Subtract</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) A in type Subtract&lt;A extends number, B extends number>' >A</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">number</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B in type Subtract&lt;A extends number, B extends number>' >B</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">number</span><span style="color: #000000">&gt; =</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99"><data-lsp lsp='type NumToTup&lt;N extends number, Tup extends unknown[] = []> = Tup extends {&#10;    length: N;&#10;} ? Tup : NumToTup&lt;N, [...Tup, unknown]>' >NumToTup</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) A in type Subtract&lt;A extends number, B extends number>' >A</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> [...</span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Diff' >Diff</data-lsp></span><span style="color: #000000">, ...</span><span style="color: #267F99"><data-lsp lsp='type NumToTup&lt;N extends number, Tup extends unknown[] = []> = Tup extends {&#10;    length: N;&#10;} ? Tup : NumToTup&lt;N, [...Tup, unknown]>' >NumToTup</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) B in type Subtract&lt;A extends number, B extends number>' >B</data-lsp></span><span style="color: #000000">&gt;] ? </span><span style="color: #267F99"><data-lsp lsp='type TupToNum&lt;T extends unknown[]> = T extends {&#10;    length: infer N;&#10;} ? N : never' >TupToNum</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) Diff' >Diff</data-lsp></span><span style="color: #000000">&gt;: </span><span style="color: #267F99">never</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const subtract_test: 3' >subtract_test</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type Subtract&lt;A extends number, B extends number> = NumToTup&lt;A, []> extends [...infer Diff, ...NumToTup&lt;B, []>] ? TupToNum&lt;Diff> : never' >Subtract</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #098658">5</span><span style="color: #000000">, </span><span style="color: #098658">2</span><span style="color: #000000">&gt; = </span><span style="color: #098658">3</span><span style="color: #000000">;</span></div></code></div></pre>
<p>Clearly, this only works with natural numbers and when <code>A &gt;= B</code>, but that is
good enough for our purposes of building greater than/less than comparators.
Let's do that now, in both cases performing the comparison between two numbers
by &quot;walking them down&quot; until one hits 0.</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type GreaterThan&lt;A extends number, B extends number> = A extends 0 ? false : B extends 0 ? true : GreaterThan&lt;Subtract&lt;A, 1>, Subtract&lt;B, 1>>' >GreaterThan</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) A in type GreaterThan&lt;A extends number, B extends number>' >A</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">number</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B in type GreaterThan&lt;A extends number, B extends number>' >B</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">number</span><span style="color: #000000">&gt; = </span><span style="color: #267F99"><data-lsp lsp='(type parameter) A in type GreaterThan&lt;A extends number, B extends number>' >A</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #098658">0</span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99">false</span><span style="color: #000000"> :</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B in type GreaterThan&lt;A extends number, B extends number>' >B</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #098658">0</span><span style="color: #000000"> ? </span><span style="color: #267F99">true</span><span style="color: #000000"> : </span><span style="color: #267F99"><data-lsp lsp='type GreaterThan&lt;A extends number, B extends number> = A extends 0 ? false : B extends 0 ? true : GreaterThan&lt;Subtract&lt;A, 1>, Subtract&lt;B, 1>>' >GreaterThan</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type Subtract&lt;A extends number, B extends number> = NumToTup&lt;A, []> extends [...infer Diff, ...NumToTup&lt;B, []>] ? TupToNum&lt;Diff> : never' >Subtract</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) A in type GreaterThan&lt;A extends number, B extends number>' >A</data-lsp></span><span style="color: #000000">, </span><span style="color: #098658">1</span><span style="color: #000000">&gt;, </span><span style="color: #267F99"><data-lsp lsp='type Subtract&lt;A extends number, B extends number> = NumToTup&lt;A, []> extends [...infer Diff, ...NumToTup&lt;B, []>] ? TupToNum&lt;Diff> : never' >Subtract</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) B in type GreaterThan&lt;A extends number, B extends number>' >B</data-lsp></span><span style="color: #000000">, </span><span style="color: #098658">1</span><span style="color: #000000">&gt;&gt;;</span></div><div class='line'>&nbsp;</div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const gt_test1: true' >gt_test1</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type GreaterThan&lt;A extends number, B extends number> = A extends 0 ? false : B extends 0 ? true : GreaterThan&lt;Subtract&lt;A, 1>, Subtract&lt;B, 1>>' >GreaterThan</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #098658">2</span><span style="color: #000000">, </span><span style="color: #098658">1</span><span style="color: #000000">&gt; = </span><span style="color: #0000FF">true</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const gt_test2: false' >gt_test2</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type GreaterThan&lt;A extends number, B extends number> = A extends 0 ? false : B extends 0 ? true : GreaterThan&lt;Subtract&lt;A, 1>, Subtract&lt;B, 1>>' >GreaterThan</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #098658">1</span><span style="color: #000000">, </span><span style="color: #098658">1</span><span style="color: #000000">&gt; = </span><span style="color: #0000FF">false</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const gt_test3: false' >gt_test3</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type GreaterThan&lt;A extends number, B extends number> = A extends 0 ? false : B extends 0 ? true : GreaterThan&lt;Subtract&lt;A, 1>, Subtract&lt;B, 1>>' >GreaterThan</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #098658">1</span><span style="color: #000000">, </span><span style="color: #098658">2</span><span style="color: #000000">&gt; = </span><span style="color: #0000FF">false</span><span style="color: #000000">;</span></div><div class='line'>&nbsp;</div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type LessThan&lt;A extends number, B extends number> = B extends 0 ? false : A extends 0 ? true : LessThan&lt;Subtract&lt;A, 1>, Subtract&lt;B, 1>>' >LessThan</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) A in type LessThan&lt;A extends number, B extends number>' >A</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">number</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B in type LessThan&lt;A extends number, B extends number>' >B</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">number</span><span style="color: #000000">&gt; = </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B in type LessThan&lt;A extends number, B extends number>' >B</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #098658">0</span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99">false</span><span style="color: #000000"> :</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99"><data-lsp lsp='(type parameter) A in type LessThan&lt;A extends number, B extends number>' >A</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #098658">0</span><span style="color: #000000"> ? </span><span style="color: #267F99">true</span><span style="color: #000000"> : </span><span style="color: #267F99"><data-lsp lsp='type LessThan&lt;A extends number, B extends number> = B extends 0 ? false : A extends 0 ? true : LessThan&lt;Subtract&lt;A, 1>, Subtract&lt;B, 1>>' >LessThan</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type Subtract&lt;A extends number, B extends number> = NumToTup&lt;A, []> extends [...infer Diff, ...NumToTup&lt;B, []>] ? TupToNum&lt;Diff> : never' >Subtract</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) A in type LessThan&lt;A extends number, B extends number>' >A</data-lsp></span><span style="color: #000000">, </span><span style="color: #098658">1</span><span style="color: #000000">&gt;, </span><span style="color: #267F99"><data-lsp lsp='type Subtract&lt;A extends number, B extends number> = NumToTup&lt;A, []> extends [...infer Diff, ...NumToTup&lt;B, []>] ? TupToNum&lt;Diff> : never' >Subtract</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) B in type LessThan&lt;A extends number, B extends number>' >B</data-lsp></span><span style="color: #000000">, </span><span style="color: #098658">1</span><span style="color: #000000">&gt;&gt;;</span></div><div class='line'>&nbsp;</div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const lt_test1: true' >lt_test1</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type LessThan&lt;A extends number, B extends number> = B extends 0 ? false : A extends 0 ? true : LessThan&lt;Subtract&lt;A, 1>, Subtract&lt;B, 1>>' >LessThan</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #098658">1</span><span style="color: #000000">, </span><span style="color: #098658">2</span><span style="color: #000000">&gt; = </span><span style="color: #0000FF">true</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const lt_test2: false' >lt_test2</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type LessThan&lt;A extends number, B extends number> = B extends 0 ? false : A extends 0 ? true : LessThan&lt;Subtract&lt;A, 1>, Subtract&lt;B, 1>>' >LessThan</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #098658">1</span><span style="color: #000000">, </span><span style="color: #098658">1</span><span style="color: #000000">&gt; = </span><span style="color: #0000FF">false</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const lt_test3: false' >lt_test3</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type LessThan&lt;A extends number, B extends number> = B extends 0 ? false : A extends 0 ? true : LessThan&lt;Subtract&lt;A, 1>, Subtract&lt;B, 1>>' >LessThan</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #098658">2</span><span style="color: #000000">, </span><span style="color: #098658">1</span><span style="color: #000000">&gt; = </span><span style="color: #0000FF">false</span><span style="color: #000000">;</span></div></code></div></pre>
<p>Okay, now we're ready to apply all this to the problem. First, let's define type
constructors that take a record type of facts we know about a Sue, a field to
verify is greater than/less than that of the corresponding field in <code>TheSue</code>, and
yield an updated record type with a boolean flag indicating the result of the
verification on the checked field name.
If the field we wish to verify against <code>TheSue</code>
isn't present on the Sue record type we pass, we can just return the record type
as it is, since that field can't be matched against <code>TheSue</code> for this Sue anyway.</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type CheckGreaterThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }> = T[F] extends number ? { [f in F]: GreaterThan&lt;T[F], TheSue[F]>; } &amp; Omit&lt;T, F> : T' >CheckGreaterThan</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) F in type CheckGreaterThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }>' >F</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">keyof</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type TheSue = {&#10;    children: 3;&#10;    cats: 7;&#10;    samoyeds: 2;&#10;    pomeranians: 3;&#10;    akitas: 0;&#10;    vizslas: 0;&#10;    goldfish: 5;&#10;    trees: 3;&#10;    cars: 2;&#10;    perfumes: 1;&#10;}' >TheSue</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type CheckGreaterThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> {[</span><span style="color: #267F99"><data-lsp lsp='(type parameter) f' >f</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">in</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) F in type CheckGreaterThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }>' >F</data-lsp></span><span style="color: #000000">]?: </span><span style="color: #267F99">number</span><span style="color: #000000">}&gt; =</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type CheckGreaterThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }>' >T</data-lsp></span><span style="color: #000000">[</span><span style="color: #267F99"><data-lsp lsp='(type parameter) F in type CheckGreaterThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }>' >F</data-lsp></span><span style="color: #000000">] </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">number</span><span style="color: #000000"> ? {[</span><span style="color: #267F99"><data-lsp lsp='(type parameter) f' >f</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">in</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) F in type CheckGreaterThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }>' >F</data-lsp></span><span style="color: #000000">]: </span><span style="color: #267F99"><data-lsp lsp='type GreaterThan&lt;A extends number, B extends number> = A extends 0 ? false : B extends 0 ? true : GreaterThan&lt;Subtract&lt;A, 1>, Subtract&lt;B, 1>>' >GreaterThan</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type CheckGreaterThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }>' >T</data-lsp></span><span style="color: #000000">[</span><span style="color: #267F99"><data-lsp lsp='(type parameter) F in type CheckGreaterThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }>' >F</data-lsp></span><span style="color: #000000">], </span><span style="color: #267F99"><data-lsp lsp='type TheSue = {&#10;    children: 3;&#10;    cats: 7;&#10;    samoyeds: 2;&#10;    pomeranians: 3;&#10;    akitas: 0;&#10;    vizslas: 0;&#10;    goldfish: 5;&#10;    trees: 3;&#10;    cars: 2;&#10;    perfumes: 1;&#10;}' >TheSue</data-lsp></span><span style="color: #000000">[</span><span style="color: #267F99"><data-lsp lsp='(type parameter) F in type CheckGreaterThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }>' >F</data-lsp></span><span style="color: #000000">]&gt;}&</span><span style="color: #267F99"><data-lsp lsp='Construct a type with the properties of T except for those in type K.&#10;&#10;type Omit&lt;T, K extends string | number | symbol> = { [P in Exclude&lt;keyof T, K>]: T[P]; }' >Omit</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type CheckGreaterThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }>' >T</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) F in type CheckGreaterThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }>' >F</data-lsp></span><span style="color: #000000">&gt;</span></div><div class='line'><span style="color: #000000">                        : </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type CheckGreaterThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }>' >T</data-lsp></span><span style="color: #000000">;</span></div><div class='line'>&nbsp;</div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type CheckLessThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }> = T[F] extends number ? { [f in F]: LessThan&lt;T[F], TheSue[F]>; } &amp; Omit&lt;T, F> : T' >CheckLessThan</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) F in type CheckLessThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }>' >F</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">keyof</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type TheSue = {&#10;    children: 3;&#10;    cats: 7;&#10;    samoyeds: 2;&#10;    pomeranians: 3;&#10;    akitas: 0;&#10;    vizslas: 0;&#10;    goldfish: 5;&#10;    trees: 3;&#10;    cars: 2;&#10;    perfumes: 1;&#10;}' >TheSue</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type CheckLessThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> {[</span><span style="color: #267F99"><data-lsp lsp='(type parameter) f' >f</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">in</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) F in type CheckLessThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }>' >F</data-lsp></span><span style="color: #000000">]?: </span><span style="color: #267F99">number</span><span style="color: #000000">}&gt; =</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type CheckLessThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }>' >T</data-lsp></span><span style="color: #000000">[</span><span style="color: #267F99"><data-lsp lsp='(type parameter) F in type CheckLessThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }>' >F</data-lsp></span><span style="color: #000000">] </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">number</span><span style="color: #000000"> ? {[</span><span style="color: #267F99"><data-lsp lsp='(type parameter) f' >f</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">in</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) F in type CheckLessThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }>' >F</data-lsp></span><span style="color: #000000">]: </span><span style="color: #267F99"><data-lsp lsp='type LessThan&lt;A extends number, B extends number> = B extends 0 ? false : A extends 0 ? true : LessThan&lt;Subtract&lt;A, 1>, Subtract&lt;B, 1>>' >LessThan</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type CheckLessThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }>' >T</data-lsp></span><span style="color: #000000">[</span><span style="color: #267F99"><data-lsp lsp='(type parameter) F in type CheckLessThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }>' >F</data-lsp></span><span style="color: #000000">], </span><span style="color: #267F99"><data-lsp lsp='type TheSue = {&#10;    children: 3;&#10;    cats: 7;&#10;    samoyeds: 2;&#10;    pomeranians: 3;&#10;    akitas: 0;&#10;    vizslas: 0;&#10;    goldfish: 5;&#10;    trees: 3;&#10;    cars: 2;&#10;    perfumes: 1;&#10;}' >TheSue</data-lsp></span><span style="color: #000000">[</span><span style="color: #267F99"><data-lsp lsp='(type parameter) F in type CheckLessThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }>' >F</data-lsp></span><span style="color: #000000">]&gt;}&</span><span style="color: #267F99"><data-lsp lsp='Construct a type with the properties of T except for those in type K.&#10;&#10;type Omit&lt;T, K extends string | number | symbol> = { [P in Exclude&lt;keyof T, K>]: T[P]; }' >Omit</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type CheckLessThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }>' >T</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) F in type CheckLessThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }>' >F</data-lsp></span><span style="color: #000000">&gt;</span></div><div class='line'><span style="color: #000000">                        : </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type CheckLessThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }>' >T</data-lsp></span><span style="color: #000000">;</span></div></code></div></pre>
<p>We use <code>[f in F]</code> to extract the properties we want to compare against <code>TheSue</code>.
Since <code>F &lt;: keyof TheSue</code>, in theory we could pass in a union type as <code>F</code> and
get multiple fields to match against (e.g. if <code>F = 'a'|'b'</code>, we have <code>T extends {1?: number, 2?: number}</code>), but in practice we will use single-union types here
(like just one string variant). We cannot say <code>{F?: number}</code> directly, as then
the field we are trying to match would be named <code>F</code> rather than the instantiated
type of <code>F</code>.</p>
<p><code>Omit&lt;T, U&gt;</code> is a type constructor that removes from the record type <code>T</code> those
fields that are a subtype of <code>U</code>. Formally,</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Exclude&lt;T, U> = T extends U ? never : T' >Exclude</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type Exclude&lt;T, U>' >T</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) U in type Exclude&lt;T, U>' >U</data-lsp></span><span style="color: #000000">&gt; = </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type Exclude&lt;T, U>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) U in type Exclude&lt;T, U>' >U</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type Exclude&lt;T, U>' >T</data-lsp></span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Omit&lt;T, U> = { [F in Exclude&lt;keyof T, U>]: T[F]; }' >Omit</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type Omit&lt;T, U>' >T</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) U in type Omit&lt;T, U>' >U</data-lsp></span><span style="color: #000000">&gt; = {</span></div><div class='line'><span style="color: #000000">  [</span><span style="color: #267F99"><data-lsp lsp='(type parameter) F' >F</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">in</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Exclude&lt;T, U> = T extends U ? never : T' >Exclude</data-lsp></span><span style="color: #000000">&lt;(</span><span style="color: #0000FF">keyof</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type Omit&lt;T, U>' >T</data-lsp></span><span style="color: #000000">), </span><span style="color: #267F99"><data-lsp lsp='(type parameter) U in type Omit&lt;T, U>' >U</data-lsp></span><span style="color: #000000">&gt;]: </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type Omit&lt;T, U>' >T</data-lsp></span><span style="color: #000000">[</span><span style="color: #267F99"><data-lsp lsp='(type parameter) F' >F</data-lsp></span><span style="color: #000000">];</span></div><div class='line'><span style="color: #000000">};</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const omit_test: true' >omit_test</data-lsp></span></div><div class='line'><span style="color: #000000">  : </span><span style="color: #001080"><data-lsp lsp='type Equals&lt;X, Y> = &lt;T>() => T extends X ? 0 : 1 extends &lt;T>() => T extends Y ? 0 : 1 ? true : false' >Equals</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #001080"><data-lsp lsp='type Omit&lt;T, U> = { [F in Exclude&lt;keyof T, U>]: T[F]; }' >Omit</data-lsp></span><span style="color: #000000">&lt;{<data-lsp lsp='(property) a: 1' >a</data-lsp>: </span><span style="color: #098658">1</span><span style="color: #000000">, <data-lsp lsp='(property) b: 2' >b</data-lsp>: </span><span style="color: #098658">2</span><span style="color: #000000">, <data-lsp lsp='(property) c: 3' >c</data-lsp>: </span><span style="color: #098658">3</span><span style="color: #000000">}, </span><span style="color: #A31515">&apos;a&apos;</span><span style="color: #000000">|</span><span style="color: #A31515">&apos;c&apos;</span><span style="color: #000000">&gt;, {</span><span style="color: #001080"><data-lsp lsp='(property) b: 2' >b</data-lsp>:</span><span style="color: #000000"> </span><span style="color: #098658">2</span><span style="color: #000000">}&gt; = </span><span style="color: #0000FF">true</span><span style="color: #000000">;</span></div></code></div></pre>
<p>The <code>Omit</code> provided by the TypeScript standard library has a differently-written
definition, but the behavior is the same.</p>
<p>We perform <code>{[f in F]: LessThan&lt;T[F], TheSue[F]&gt;}&amp;Omit&lt;T, F&gt;</code> (and similarly
for <code>GreaterThan</code>) because once we have determined whether the checked field is
indeed <code>LessThan</code> that of <code>TheSue</code>, we would like to return a fresh type with
that data and all other data we already know about this Sue, sans the exact
numeric type we knew about the field we just checked. In constructing
<code>CheckLessThan&lt;'cats', {trees: 2, cats: 5}&gt;</code>, if the less than check yields
<code>false</code>, the constructor yields <code>{cats: false}&amp;{trees: 2}</code> (a type equivalent to
<code>{cats: false, trees: 2}</code>). Keeping the checked field's numeric type
would yield <code>{cats: false}&amp;{trees: 2, cats: 5} = never</code>, as there is no value
that can have a field <code>cats</code> whose value inhabits both <code>false</code> and <code>5</code>.</p>
<p>Next, we define type constructors to take a record type of some Sue facts,
compare its fields against those of <code>TheSue</code> for which we need to know
greater than/less than relations, and yield a record type with that data.</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type PartialUnconstrained&lt;T> = { [P in keyof T]?: any; }' >PartialUnconstrained</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type PartialUnconstrained&lt;T>' >T</data-lsp></span><span style="color: #000000">&gt; = {</span></div><div class='line'><span style="color: #000000">  [</span><span style="color: #267F99"><data-lsp lsp='(type parameter) P' >P</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">in</span><span style="color: #000000"> </span><span style="color: #0000FF">keyof</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type PartialUnconstrained&lt;T>' >T</data-lsp></span><span style="color: #000000">]?: </span><span style="color: #267F99">any</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #000000">};</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type SueCheckFieldsGreater&lt;T extends PartialUnconstrained&lt;TheSue>> = CheckGreaterThan&lt;"cats", T>["trees"] extends number ? {&#10;    trees: GreaterThan&lt;CheckGreaterThan&lt;"cats", T>["trees"], 3>;&#10;} &amp; Omit&lt;...> : CheckGreaterThan&lt;...>' >SueCheckFieldsGreater</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type SueCheckFieldsGreater&lt;T extends PartialUnconstrained&lt;TheSue>>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type PartialUnconstrained&lt;T> = { [P in keyof T]?: any; }' >PartialUnconstrained</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type TheSue = {&#10;    children: 3;&#10;    cats: 7;&#10;    samoyeds: 2;&#10;    pomeranians: 3;&#10;    akitas: 0;&#10;    vizslas: 0;&#10;    goldfish: 5;&#10;    trees: 3;&#10;    cars: 2;&#10;    perfumes: 1;&#10;}' >TheSue</data-lsp></span><span style="color: #000000">&gt;&gt; =</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99"><data-lsp lsp='type CheckGreaterThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }> = T[F] extends number ? { [f in F]: GreaterThan&lt;T[F], TheSue[F]>; } &amp; Omit&lt;T, F> : T' >CheckGreaterThan</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">&apos;trees&apos;</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='type CheckGreaterThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }> = T[F] extends number ? { [f in F]: GreaterThan&lt;T[F], TheSue[F]>; } &amp; Omit&lt;T, F> : T' >CheckGreaterThan</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">&apos;cats&apos;</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type SueCheckFieldsGreater&lt;T extends PartialUnconstrained&lt;TheSue>>' >T</data-lsp></span><span style="color: #000000">&gt;&gt;;</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type SueCheckFieldsLesser&lt;T extends PartialUnconstrained&lt;TheSue>> = CheckLessThan&lt;"goldfish", T>["pomeranians"] extends number ? {&#10;    pomeranians: CheckLessThan&lt;"goldfish", T>["pomeranians"] extends 0 ? true : Subtract&lt;CheckLessThan&lt;"goldfish", T>["pomeranians"], 1> extends 0 ? true : false;&#10;} &amp; Omit&lt;...> : CheckLessThan&lt;...>' >SueCheckFieldsLesser</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type SueCheckFieldsLesser&lt;T extends PartialUnconstrained&lt;TheSue>>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type PartialUnconstrained&lt;T> = { [P in keyof T]?: any; }' >PartialUnconstrained</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type TheSue = {&#10;    children: 3;&#10;    cats: 7;&#10;    samoyeds: 2;&#10;    pomeranians: 3;&#10;    akitas: 0;&#10;    vizslas: 0;&#10;    goldfish: 5;&#10;    trees: 3;&#10;    cars: 2;&#10;    perfumes: 1;&#10;}' >TheSue</data-lsp></span><span style="color: #000000">&gt;&gt; =</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99"><data-lsp lsp='type CheckLessThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }> = T[F] extends number ? { [f in F]: LessThan&lt;T[F], TheSue[F]>; } &amp; Omit&lt;T, F> : T' >CheckLessThan</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">&apos;pomeranians&apos;</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='type CheckLessThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }> = T[F] extends number ? { [f in F]: LessThan&lt;T[F], TheSue[F]>; } &amp; Omit&lt;T, F> : T' >CheckLessThan</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">&apos;goldfish&apos;</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type SueCheckFieldsLesser&lt;T extends PartialUnconstrained&lt;TheSue>>' >T</data-lsp></span><span style="color: #000000">&gt;&gt;;</span></div><div class='line'>&nbsp;</div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type SueCheckFields&lt;T extends PartialUnconstrained&lt;TheSue>> = CheckLessThan&lt;"goldfish", CheckGreaterThan&lt;"trees", CheckGreaterThan&lt;"cats", T>>>["pomeranians"] extends number ? {&#10;    pomeranians: CheckLessThan&lt;...>["pomeranians"] extends 0 ? true : Subtract&lt;...> extends 0 ? true : false;&#10;} &amp; Omit&lt;...> : CheckLessThan&lt;...>' >SueCheckFields</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type SueCheckFields&lt;T extends PartialUnconstrained&lt;TheSue>>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type PartialUnconstrained&lt;T> = { [P in keyof T]?: any; }' >PartialUnconstrained</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type TheSue = {&#10;    children: 3;&#10;    cats: 7;&#10;    samoyeds: 2;&#10;    pomeranians: 3;&#10;    akitas: 0;&#10;    vizslas: 0;&#10;    goldfish: 5;&#10;    trees: 3;&#10;    cars: 2;&#10;    perfumes: 1;&#10;}' >TheSue</data-lsp></span><span style="color: #000000">&gt;&gt; =</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99"><data-lsp lsp='type SueCheckFieldsLesser&lt;T extends PartialUnconstrained&lt;TheSue>> = CheckLessThan&lt;"goldfish", T>["pomeranians"] extends number ? {&#10;    pomeranians: CheckLessThan&lt;"goldfish", T>["pomeranians"] extends 0 ? true : Subtract&lt;CheckLessThan&lt;"goldfish", T>["pomeranians"], 1> extends 0 ? true : false;&#10;} &amp; Omit&lt;...> : CheckLessThan&lt;...>' >SueCheckFieldsLesser</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type SueCheckFieldsGreater&lt;T extends PartialUnconstrained&lt;TheSue>> = CheckGreaterThan&lt;"cats", T>["trees"] extends number ? {&#10;    trees: GreaterThan&lt;CheckGreaterThan&lt;"cats", T>["trees"], 3>;&#10;} &amp; Omit&lt;...> : CheckGreaterThan&lt;...>' >SueCheckFieldsGreater</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type SueCheckFields&lt;T extends PartialUnconstrained&lt;TheSue>>' >T</data-lsp></span><span style="color: #000000">&gt;&gt;;</span></div></code></div></pre>
<p>The <code>any</code> type is inhabited by all values, but is more flexible than the
<code>unknown</code> type in that values of <code>any</code> also inhabit every <em>other</em> type<span class="note"><label for="whyany" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="whyany" class="margin-toggle" /><span class="sidenote"><code>any</code> is an &quot;escape hatch&quot; from the type system, usually used
to deal with the fact that variables are untyped in JavaScript. Here, our
purpose is a little more sinister.</span>.</p>
<p>I leave as an exercise to the reader why the <code>PartialUnconstrained</code> bound is
needed for the above type constructors, and why <code>SueCheckFieldsGreater</code> cannot
be defined as</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type SueCheckFieldsGreater&lt;T extends PartialUnconstrained&lt;TheSue>> = CheckGreaterThan&lt;"trees", T> &amp; CheckGreaterThan&lt;"cats", T>' >SueCheckFieldsGreater</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type SueCheckFieldsGreater&lt;T extends PartialUnconstrained&lt;TheSue>>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type PartialUnconstrained&lt;T> = { [P in keyof T]?: any; }' >PartialUnconstrained</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type TheSue = {&#10;    children: 3;&#10;    cats: 7;&#10;    samoyeds: 2;&#10;    pomeranians: 3;&#10;    akitas: 0;&#10;    vizslas: 0;&#10;    goldfish: 5;&#10;    trees: 3;&#10;    cars: 2;&#10;    perfumes: 1;&#10;}' >TheSue</data-lsp></span><span style="color: #000000">&gt;&gt; =</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99"><data-lsp lsp='type CheckGreaterThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }> = T[F] extends number ? { [f in F]: GreaterThan&lt;T[F], TheSue[F]>; } &amp; Omit&lt;T, F> : T' >CheckGreaterThan</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">&apos;trees&apos;</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type SueCheckFieldsGreater&lt;T extends PartialUnconstrained&lt;TheSue>>' >T</data-lsp></span><span style="color: #000000">&gt;&</span><span style="color: #267F99"><data-lsp lsp='type CheckGreaterThan&lt;F extends keyof TheSue, T extends { [f in F]?: number | undefined; }> = T[F] extends number ? { [f in F]: GreaterThan&lt;T[F], TheSue[F]>; } &amp; Omit&lt;T, F> : T' >CheckGreaterThan</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">&apos;cats&apos;</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type SueCheckFieldsGreater&lt;T extends PartialUnconstrained&lt;TheSue>>' >T</data-lsp></span><span style="color: #000000">&gt;;</span></div></code></div></pre>
<p>and what extra work would need to be done in order to define it in this way.</p>
<p>Next, we need to rewrite <code>TheSue</code> in a manner that it can be matched against the
greater than/less than field constraints we recorded on each Sue record type via
the <code>SueCheckFields</code> constructor. Since for the Sue that we want to find those
greater than/less than field constraints should all be typed as <code>true</code>, let's
redefine <code>TheSue</code> that way:</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type CheckedFields = "trees" | "cats" | "pomeranians" | "goldfish"' >CheckedFields</data-lsp></span><span style="color: #000000"> = </span><span style="color: #A31515">&apos;trees&apos;</span><span style="color: #000000">|</span><span style="color: #A31515">&apos;cats&apos;</span><span style="color: #000000">|</span><span style="color: #A31515">&apos;pomeranians&apos;</span><span style="color: #000000">|</span><span style="color: #A31515">&apos;goldfish&apos;</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type TheSueChecked = Omit&lt;TheSue, CheckedFields> &amp; {&#10;    trees: true;&#10;    cats: true;&#10;    pomeranians: true;&#10;    goldfish: true;&#10;}' >TheSueChecked</data-lsp></span><span style="color: #000000"> = </span><span style="color: #267F99"><data-lsp lsp='Construct a type with the properties of T except for those in type K.&#10;&#10;type Omit&lt;T, K extends string | number | symbol> = { [P in Exclude&lt;keyof T, K>]: T[P]; }' >Omit</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type TheSue = {&#10;    children: 3;&#10;    cats: 7;&#10;    samoyeds: 2;&#10;    pomeranians: 3;&#10;    akitas: 0;&#10;    vizslas: 0;&#10;    goldfish: 5;&#10;    trees: 3;&#10;    cars: 2;&#10;    perfumes: 1;&#10;}' >TheSue</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='type CheckedFields = "trees" | "cats" | "pomeranians" | "goldfish"' >CheckedFields</data-lsp></span><span style="color: #000000">&gt;&{[</span><span style="color: #267F99"><data-lsp lsp='(type parameter) f' >f</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">in</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type CheckedFields = "trees" | "cats" | "pomeranians" | "goldfish"' >CheckedFields</data-lsp></span><span style="color: #000000">]: </span><span style="color: #267F99">true</span><span style="color: #000000">};</span></div></code></div></pre>
<p>Finally, we perform the checking on each Sue, extract a union of them all, and
yield a subtype comparison against <code>TheSueChecked</code> as in Part 1.</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Sues = {&#10;    1: {&#10;        goldfish: 9;&#10;        cars: 0;&#10;        samoyeds: 9;&#10;    };&#10;    2: {&#10;        perfumes: 5;&#10;        trees: 8;&#10;        goldfish: 8;&#10;    };&#10;    3: {&#10;        pomeranians: 2;&#10;        akitas: 1;&#10;        trees: 5;&#10;    };&#10;    4: {&#10;        goldfish: 10;&#10;        akitas: 2;&#10;        perfumes: 9;&#10;    };&#10;    5: {&#10;        cars: 5;&#10;        perfumes: 6;&#10;        akitas: 9;&#10;    };&#10;    6: {&#10;        goldfish: 10;&#10;        cats: 9;&#10;        cars: 8;&#10;    };&#10;    7: {&#10;        trees: 2;&#10;        samoyeds: 7;&#10;        goldfish: 10;&#10;    };&#10;    8: {&#10;        cars: 8;&#10;        perfumes: 6;&#10;        goldfish: 1;&#10;    };&#10;    9: {&#10;        cats: 4;&#10;        pomeranians: 0;&#10;        trees: 0;&#10;    };&#10;    10: {&#10;        trees: 2;&#10;        children: 10;&#10;        samoyeds: 10;&#10;    };&#10;    11: {&#10;        akitas: 10;&#10;        perfumes: 4;&#10;        vizslas: 1;&#10;    };&#10;    12: {&#10;        akitas: 1;&#10;        trees: 0;&#10;        goldfish: 3;&#10;    };&#10;    13: {&#10;        perfumes: 6;&#10;        goldfish: 10;&#10;        cars: 8;&#10;    };&#10;    14: {&#10;        cats: 8;&#10;        akitas: 5;&#10;        vizslas: 0;&#10;    };&#10;    15: {&#10;        cars: 8;&#10;        trees: 3;&#10;        samoyeds: 5;&#10;    };&#10;    16: {&#10;        vizslas: 6;&#10;        cats: 6;&#10;        pomeranians: 10;&#10;    };&#10;    17: {&#10;        akitas: 6;&#10;        cats: 2;&#10;        perfumes: 9;&#10;    };&#10;    18: {&#10;        children: 9;&#10;        goldfish: 2;&#10;        akitas: 10;&#10;    };&#10;    19: {&#10;        trees: 3;&#10;        perfumes: 0;&#10;        goldfish: 6;&#10;    };&#10;    20: {&#10;        vizslas: 3;&#10;        akitas: 0;&#10;        trees: 1;&#10;    };&#10;    21: {&#10;        vizslas: 3;&#10;        cars: 7;&#10;        akitas: 3;&#10;    };&#10;    22: {&#10;...' >Sues</data-lsp>Che<data-lsp lsp='type SuesList = {&#10;    1: {&#10;        goldfish: 9;&#10;        cars: 0;&#10;        samoyeds: 9;&#10;    };&#10;    2: {&#10;        perfumes: 5;&#10;        trees: 8;&#10;        goldfish: 8;&#10;    };&#10;    3: {&#10;        pomeranians: 2;&#10;        akitas: 1;&#10;        trees: 5;&#10;    };&#10;    4: {&#10;        goldfish: 10;&#10;        akitas: 2;&#10;        perfumes: 9;&#10;    };&#10;    5: {&#10;        cars: 5;&#10;        perfumes: 6;&#10;        akitas: 9;&#10;    };&#10;    6: {&#10;        goldfish: 10;&#10;        cats: 9;&#10;        cars: 8;&#10;    };&#10;    7: {&#10;        trees: 2;&#10;        samoyeds: 7;&#10;        goldfish: 10;&#10;    };&#10;    8: {&#10;        cars: 8;&#10;        perfumes: 6;&#10;        goldfish: 1;&#10;    };&#10;    9: {&#10;        cats: 4;&#10;        pomeranians: 0;&#10;        trees: 0;&#10;    };&#10;    10: {&#10;        trees: 2;&#10;        children: 10;&#10;        samoyeds: 10;&#10;    };&#10;    11: {&#10;        akitas: 10;&#10;        perfumes: 4;&#10;        vizslas: 1;&#10;    };&#10;    12: {&#10;        akitas: 1;&#10;        trees: 0;&#10;        goldfish: 3;&#10;    };&#10;    13: {&#10;        perfumes: 6;&#10;        goldfish: 10;&#10;        cars: 8;&#10;    };&#10;    14: {&#10;        cats: 8;&#10;        akitas: 5;&#10;        vizslas: 0;&#10;    };&#10;    15: {&#10;        cars: 8;&#10;        trees: 3;&#10;        samoyeds: 5;&#10;    };&#10;    16: {&#10;        vizslas: 6;&#10;        cats: 6;&#10;        pomeranians: 10;&#10;    };&#10;    17: {&#10;        akitas: 6;&#10;        cats: 2;&#10;        perfumes: 9;&#10;    };&#10;    18: {&#10;        children: 9;&#10;        goldfish: 2;&#10;        akitas: 10;&#10;    };&#10;    19: {&#10;        trees: 3;&#10;        perfumes: 0;&#10;        goldfish: 6;&#10;    };&#10;    20: {&#10;        vizslas: 3;&#10;        akitas: 0;&#10;        trees: 1;&#10;    };&#10;    21: {&#10;        vizslas: 3;&#10;        cars: 7;&#10;        akitas: 3;&#10;    };&#10;    22: {&#10;...' >ckedWith</data-lsp>Names</span><span style="color: #000000"> = {</span></div><div class='line'><span style="color: #000000">  [</span><span style="color: #267F99">S</span><span style="color: #000000"> </span><span style="color: #0000FF">in</span><span style="color: #000000"> </span><span style="color: #0000FF">keyof</span><span style="color: #000000"> </span><span style="color: #267F99">Sues</span><span style="color: #000000">]: {</span><span style="color: #001080">name</span><span style="color: #000000">: </span><span style="color: #267F99">S</span><span style="color: #000000">}&</span><span style="color: #267F99">SueCheckFields</span><span style="color: #000000">&lt;</span><span style="color: #267F99">Sues</span><span style="color: #000000">[</span><span style="color: #267F99">S</span><span style="color: #000000">]&gt;;</span></div><div class='line'><span style="color: #000000">};</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99">AllTheSues<data-lsp lsp='type TupToNum&lt;T extends unknown[]> = T extends {&#10;    length: infer N;&#10;} ? N : never' ></data-lsp><data-lsp lsp='(type parameter) T in type TupToNum&lt;T extends unknown[]>' ></data-lsp></span><span style="color: #000000"> = </span><span style="color: #267F99">SuesCheckedWithNames<data-lsp lsp='(type parameter) T in type TupToNum&lt;T extends unknown[]>' ></data-lsp></span><span style="color: #000000">[</span><span style="color: #0000FF">keyof</span><span style="color: #000000"> </span><span style="color: #267F99">SuesCheckedWithNames<data-lsp lsp='(property) length: N' ></data-lsp><data-lsp lsp='(type parameter) N' ></data-lsp></span><span style="color: #000000">];</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99">MatchingSue<data-lsp lsp='type NumToTup&lt;N extends number, Tup extends unknown[] = []> = Tup extends {&#10;    length: N;&#10;} ? Tup : NumToTup&lt;N, [...Tup, unknown]>' ></data-lsp><data-lsp lsp='(type parameter) N in type NumToTup&lt;N extends number, Tup extends unknown[] = []>' ></data-lsp></span><span style="color: #000000"> = </span><span style="color: #267F99">Extract</span><span style="color: #000000">&lt;</span><span style="color: #267F99">AllTheSues<data-lsp lsp='(type parameter) Tup in type NumToTup&lt;N extends number, Tup extends unknown[] = []>' ></data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99">Partial</span><span style="color: #000000">&lt;</span><span style="color: #267F99">TheSueChecked</span><span style="color: #000000">&gt;&gt;[</span><span style="color: #A31515">&apos;name&apos;</span><span style="color: #000000">];</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1">matching_sue</span><span style="color: #000000">: </span><span style="color: #267F99">MatchingSue<data-lsp lsp='(type parameter) N in type NumToTup&lt;N extends number, Tup extends unknown[] = []>' ></data-lsp></span><span style="color: #000000"> = </span><span style="color: #098658">241</span><span style="color: #000000">;</span></div></code></div></pre>
<p>All done, without leaving the type checker!</p>
<h2 id="epilogue" tabindex="-1"><a class="header-anchor" href="#epilogue" aria-hidden="true"></a>Epilogue</h2>
<p>I hope this cc provided you with a demonstration of the power of TypeScript's
type system, and maybe gave you some ideas of how to exploit it in your own
work.</p>
<p>I am not aware of other type systems in popular programming languages similar to
those of TypeScript's in terms of reflection and the typing of primitive
literals. Our treatment of tuples above was nice for encoding naturals, and can
also give way to a weak kind of dependent typing.</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Init&lt;T> = T extends [...infer I, infer _] ? I : never' >Init</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type Init&lt;T>' >T</data-lsp></span><span style="color: #000000">&gt; = </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type Init&lt;T>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> [...</span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) I' >I</data-lsp></span><span style="color: #000000">, </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) _' >_</data-lsp></span><span style="color: #000000">] ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) I' >I</data-lsp></span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000">;</span></div><div class='line'>&nbsp;</div><div class='line'><span style="color: #0000FF">function</span><span style="color: #000000"> </span><span style="color: #795E26"><data-lsp lsp='function init&lt;T extends unknown[]>(arr: T): Init&lt;T>' >init</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in init&lt;T extends unknown[]>(arr: T): Init&lt;T>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">unknown</span><span style="color: #000000">[]&gt;(</span><span style="color: #001080"><data-lsp lsp='(parameter) arr: T extends unknown[]' >arr</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in init&lt;T extends unknown[]>(arr: T): Init&lt;T>' >T</data-lsp></span><span style="color: #000000">) {</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #AF00DB">return</span><span style="color: #000000"> </span><span style="color: #001080"><data-lsp lsp='(parameter) arr: T extends unknown[]' >arr</data-lsp></span><span style="color: #000000">.</span><span style="color: #795E26"><data-lsp lsp='Returns a copy of a section of an array.&#13;&#10;For both start and end, a negative index can be used to indicate an offset from the end of the array.&#13;&#10;For example, -2 refers to the second to last element of the array.&#10;&#10;(method) Array&lt;unknown>.slice(start?: number | undefined, end?: number | undefined): unknown[]' >slice</data-lsp></span><span style="color: #000000">(</span><span style="color: #098658">0</span><span style="color: #000000">, -</span><span style="color: #098658">1</span><span style="color: #000000">) </span><span style="color: #AF00DB">as</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Init&lt;T> = T extends [...infer I, infer _] ? I : never' >Init</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in init&lt;T extends unknown[]>(arr: T): Init&lt;T>' >T</data-lsp></span><span style="color: #000000">&gt;;</span></div><div class='line'><span style="color: #000000">}</span></div><div class='line'>&nbsp;</div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const a1: [1]' style='border-bottom: solid 2px lightgrey;'>a1</data-lsp></span><span style="color: #000000"> = </span><span style="color: #795E26"><data-lsp lsp='function init&lt;[1, "b"]>(arr: [1, "b"]): [1]' >init</data-lsp></span><span style="color: #000000">([</span><span style="color: #098658">1</span><span style="color: #000000">, </span><span style="color: #A31515">&apos;b&apos;</span><span style="color: #000000">] </span><span style="color: #AF00DB">as</span><span style="color: #000000"> [</span><span style="color: #098658">1</span><span style="color: #000000">, </span><span style="color: #A31515">&apos;b&apos;</span><span style="color: #000000">]);</span></div><div class='meta-line'><span class='popover-prefix'>      </span><span class='popover'><div class='arrow'></div>const a1: [1]</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const aempty: []' style='border-bottom: solid 2px lightgrey;'>aempty</data-lsp></span><span style="color: #000000"> = </span><span style="color: #795E26"><data-lsp lsp='function init&lt;[1]>(arr: [1]): []' >init</data-lsp></span><span style="color: #000000">(</span><span style="color: #001080"><data-lsp lsp='const a1: [1]' >a1</data-lsp></span><span style="color: #000000">);</span></div><div class='meta-line'><span class='popover-prefix'>        </span><span class='popover'><div class='arrow'></div>const aempty: []</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const anever: never' style='border-bottom: solid 2px lightgrey;'>anever</data-lsp></span><span style="color: #000000"> = </span><span style="color: #795E26"><data-lsp lsp='function init&lt;[]>(arr: []): never' >init</data-lsp></span><span style="color: #000000">(</span><span style="color: #001080"><data-lsp lsp='const aempty: []' >aempty</data-lsp></span><span style="color: #000000">);</span></div><div class='meta-line'><span class='popover-prefix'>        </span><span class='popover'><div class='arrow'></div>const anever: never</span></div></code></div></pre>
<p>While intriguing, it is unlikely
that this kind of use case will ever make it as a first-class citizen in the
type system.</p>
<p>The behavior of distributive conditional types may appear to be a little bit
odd, as raw union types certainly don't distribute over type
operations<span class="note"><label for="obj" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="obj" class="margin-toggle" /><span class="sidenote">Values inhabited by <code>Obj</code> include <code>{b: 2}</code>, so <code>Obj</code>
cannot have a property <code>a</code>. In fact, values of type <code>Obj</code> have no typed
properties until narrowed to know they have a field <code>a</code> or <code>b</code>.</span>:</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Obj = {&#10;    a: 1;&#10;} | {&#10;    b: 2;&#10;} | {&#10;    a: 3;&#10;}' >Obj</data-lsp></span><span style="color: #000000"> = {</span><span style="color: #001080"><data-lsp lsp='(property) a: 1' >a</data-lsp></span><span style="color: #000000">: </span><span style="color: #098658">1</span><span style="color: #000000">}|{</span><span style="color: #001080"><data-lsp lsp='(property) b: 2' >b</data-lsp></span><span style="color: #000000">: </span><span style="color: #098658">2</span><span style="color: #000000">}|{</span><span style="color: #001080"><data-lsp lsp='(property) a: 3' >a</data-lsp></span><span style="color: #000000">: </span><span style="color: #098658">3</span><span style="color: #000000">};</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type AsFromRaw = any' >AsFromRaw</data-lsp></span><span style="color: #000000"> = </span><span style="color: #267F99"><data-lsp lsp='type Obj = {&#10;    a: 1;&#10;} | {&#10;    b: 2;&#10;} | {&#10;    a: 3;&#10;}' >Obj</data-lsp></span><span style="color: #000000">[</span><span style="color: #A31515"><data-err>&apos;a&apos;</data-err></span><span style="color: #000000">];</span></div><span class="error"><span>Property 'a' does not exist on type 'Obj'.</span><span class="code">2339</span></span><span class="error-behind">Property 'a' does not exist on type 'Obj'.</span><div class='line'>&nbsp;</div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type PickA&lt;T> = T extends {&#10;    a: number;&#10;} ? T["a"] : never' >PickA</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type PickA&lt;T>' >T</data-lsp></span><span style="color: #000000">&gt; = </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type PickA&lt;T>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> {</span><span style="color: #001080"><data-lsp lsp='(property) a: number' >a</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99">number</span><span style="color: #000000">} ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type PickA&lt;T>' >T</data-lsp></span><span style="color: #000000">[</span><span style="color: #A31515">&apos;a&apos;</span><span style="color: #000000">] : </span><span style="color: #267F99">never</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type AsFromPick = 1 | 3' style='border-bottom: solid 2px lightgrey;'>AsFromPick</data-lsp></span><span style="color: #000000"> = </span><span style="color: #267F99"><data-lsp lsp='type PickA&lt;T> = T extends {&#10;    a: number;&#10;} ? T["a"] : never' >PickA</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type Obj = {&#10;    a: 1;&#10;} | {&#10;    b: 2;&#10;} | {&#10;    a: 3;&#10;}' >Obj</data-lsp></span><span style="color: #000000">&gt;;</span></div><div class='meta-line'><span class='popover-prefix'>         </span><span class='popover'><div class='arrow'></div>type AsFromPick = 1 | 3</span></div></code></div></pre>
<p>There are ways to get around this distributive behavior in conditional types,
but they are outside the scope of this cc. Just know they are out there, and
check them out if you're interested <img class='emoji' alt='slightly_smiling_face' src='https://gitlab.com/ayazhafiz/emoji-img/raw/master/public/emoji/unicode/1f642.png' height=20 width=20></img>.</p>
<p>And don't worry - as all good things do, the TypeScript type system has holes. See
<a href="https://github.com/ayazhafiz/rats">raTS!</a> for some; see the <a href="https://github.com/microsoft/TypeScript/issues">TypeScript issue
tracker</a> for many more.</p>
<p>Anyway, I hope you enjoyed this. Please email me if you have any comments.</p>


</article>

<section class="footer">
  
  <a href="/articles/20/impact-vs-innovation"
    >&laquo; Impact vs Innovation & Industry vs Academia</a
  >
  
  <span
    ><img class='emoji' alt='baby_chick' src='https://gitlab.com/ayazhafiz/emoji-img/raw/master/public/emoji/unicode/1f424.png' height=20 width=20></img>&emsp;
    <span
      >&#8203;
      <script type="math/tex">
        S_1\lt\colon\ S_2,\ T_1\lt\colon\ T_2 \implies S_2\to T_1\lt\colon\ S_1\to T_2
      </script></span
    >
  </span>
  
  <a href="/articles/21/hot-code-reloading">Hot Code Reloading, With Libc or in the Browser &raquo;</a>
  
</section>

<script src="https://utteranc.es/client.js"
        repo="ayazhafiz/gww-utterances"
        issue-term="title"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

<script type="text/javascript">
  function $(query) {
    return document.querySelector(query);
  }

  function $$(query) {
    return Array.from(document.querySelectorAll(query));
  }

  function isFullWidth() {
    return $(".post").classList.contains("full");
  }

  function toggleFullWidth() {
    const isFull = isFullWidth();
    isFull
      ? $(".post").classList.remove("full")
      : $(".post").classList.add("full");
    toggleShowHideNotes(!isFull);
    toggleShowHideNotesSwitch(!isFull);
    return !isFull;
  }

  function toggleShowHideNotes(isFullWidth) {
    const notes = $$(".marginnote").concat($$(".sidenote"));
    notes.forEach(note => {
      isFullWidth
        ? note.classList.add("maybe-hide")
        : note.classList.remove("maybe-hide");
    });
  }

  document.addEventListener("DOMContentLoaded", () => {
    $$(".note").forEach(toggle =>
      toggle.addEventListener("click", () => {
        if (isFullWidth()) {
          toggleFullWidth();
        }
      })
    );
  });
</script>

        </div>
      </div>
    </div>

    <div class="bottom-bar">
    <details>
  <summary>Analytics</summary>
  By visiting this site, you agree to its use of <a href="https://www.cloudflare.com/analytics/"
    >Cloudflare Analytics</a
  >. No identifiable information is transmitted to Cloudflare. See
  <a href="https://www.cloudflare.com/web-analytics/">Cloudflare Analytics user privacy</a>.
</details>

</details>

    </div>
  </body>
</html>
