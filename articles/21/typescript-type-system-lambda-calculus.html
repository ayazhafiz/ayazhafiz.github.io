

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?" />

<link rel="alternate" type="application/atom+xml" title="cc - Ayaz Hafiz" href="/feed-rrs2.xml">


<title>
  
    Emulating the Lambda Calculus in TypeScript's Type System
  
</title>
<meta name="description" content="We show that the TypeScript type system can emulate the lambda calculus, thereby providing a proof that the type system is Turing-complete." />

<link
  rel="canonical"
  href="/articles/21/typescript-type-system-lambda-calculus"
/>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    TeX: {
      Macros: {
        co: "\\colon",
        msf: "\\mathsf",
        Ra: "\\Rightarrow",
        Def: "\\text{Definition.}",
        Thm: "\\text{Theorem.}",
        Pf: "\\text{Proof.}",
        eps: "\\epsilon",
        lam: "\\lambda",
        lt: "<",
        
        lam: "\\lambda",
        
        S: "\\text{S}",
        
      },
    }
  });
  MathJax.Hub.Queue(function () {
    document.body.setAttribute('render-done', '');
  });
</script>

<script
  type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"
></script>

<link
  rel="stylesheet"
  type="text/css"
  href="/css/shiki.css?1669487124422174523"
/>




    <link
      rel="stylesheet"
      type="text/css"
      href="/css/post.css?1669487124422174523"
    />
  </head>

  <style></style>

  <body>
    <div class="container post">
      <div class="panel">
        <div class="column-right Emulating the Lambda Calculus in TypeScript's Type System-main">
          <section class="nav">
  <a class="nav-link" href="/about">about</a
  ><a class="nav-link" href="/cc">cc</a
  ><a class="nav-link" href="/visual">visual</a>
</section>
 <h1 class="title">Emulating the Lambda Calculus in TypeScript's Type System</h1>
<p class="byline">July 28, 2021</p>

<article class="post">
   <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#lambda-calculus-syntax">Lambda calculus syntax</a></li>
<li class="toc-entry toc-h2"><a href="#%24%5Cbeta%24-reduction">$\beta$-reduction</a></li>
<li class="toc-entry toc-h2"><a href="#free-variables">Free variables</a></li>
<li class="toc-entry toc-h2"><a href="#%24%5Calpha%24-conversion">$\alpha$-conversion</a></li>
<li class="toc-entry toc-h2"><a href="#substitution">Substitution</a>
<ul>
<li class="toc-entry toc-h3"><a href="#contexts">Contexts</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#evaluation%3A-%24%5Cbeta%24-normal-form">Evaluation: $\beta$ normal form</a></li>
<li class="toc-entry toc-h2"><a href="#extension%3A-program-equivalence">Extension: Program Equivalence</a>
<ul>
<li class="toc-entry toc-h3"><a href="#%24%5Calpha%24-equivalence">$\alpha$-equivalence</a></li>
<li class="toc-entry toc-h3"><a href="#type-level-numbers">Type-level numbers</a></li>
<li class="toc-entry toc-h3"><a href="#%24%5Calpha%5Cbeta%24-equivalence">$\alpha\beta$-equivalence</a></li>
<li class="toc-entry toc-h3"><a href="#proving-arithmetic-equivalences">Proving arithmetic equivalences</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#notes">Notes</a></li>
</ul> 
  <p>It's been half year since I last wrote about exploiting the TypeScript type
system to <a href="https://ayazhafiz.com/articles/20/pattern-matching-with-a-typechecker">solve non-trivial problems</a>.
Those problems were relatively simple as far as computational complexity goes -
we weren't trying to do everything a Turing machine can do.</p>
<p>This time, we'll solve the computationally-harder problem of emulating the
lambda calculus. The (untyped) lambda calculus is a model of computation equivalent to the
Turing machine model, which means that the lambda calculus can compute anything
a Turing machine can<span class="note"><label for="typed-lambda" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="typed-lambda" class="margin-toggle" /><span class="sidenote">The typed lambda calculus, which only admits
terms that are &quot;well-typed&quot;, is not computationally equivalent to the Turing machine. It turns
out that all well-typed terms in the typed lambda calculus halt. But there are programs for which
a Turing machine does not halt.</span>. In other words, the lambda calculus can simulate any
computer algorithm. So, if we can emulate the lambda calculus in the TypeScript
type system, we will have a proof that the type system is Turing-complete<span class="note"><label for="completeness-proof" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="completeness-proof" class="margin-toggle" /><span class="sidenote">It has been <a href=https://github.com/Microsoft/TypeScript/issues/14833>well-known</a>
for several years that TypeScript's type system is Turing-complete. However, I
am not aware of any prior implementations of the lambda calculus in the type system.
Perhaps this because it is straightforward (as we will see), or Turing machine
emulators are more appealing as proofs.</span>!
Furthermore, our construction will not be esoteric; in fact, it will read
similarly to typical functional implementations of the lambda calculus.</p>
<p>The lambda calculus is one of the most well-studied topics in computer science,
fundamental in computational theory. Almost all functional languages, type systems,
and type-based theorem provers are built on an extension of the lambda calculus
with types, known as the <a href="https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus">simply typed lambda calculus</a>.
The simply typed lambda calculus is part of a beautiful trilogy
known as the <a href="https://ncatlab.org/nlab/show/computational+trilogy">Curry-Howard-Lambek correspondence</a>
that says that computation in the model of typed lambda calculi, mathematical
logic, and category theory are equivalent.</p>
<p>I mention these consequences not because they're particularly important to know,
but to say that applications of the lambda calculus across mathematics and
computer science are well known. Our construction of the lambda
calculus will not be anything new, so if you are already familiar with it,
perhaps only the type-level implementation in TypeScript will be interesting.
Nevertheless, I will not assume existing knowledge of the lambda calculus. I will,
however, assume familiarity with TypeScript's syntax and type system. For a refresher of
the latter and an introduction to computation with the TS type system, see my
<a href="https://ayazhafiz.com/articles/20/pattern-matching-with-a-typechecker">last post</a>
on this topic.</p>
<h2 id="lambda-calculus-syntax" tabindex="-1"><a class="header-anchor" href="#lambda-calculus-syntax" aria-hidden="true"></a>Lambda calculus syntax</h2>
<p>The untyped lambda calculus is a language consisting of three forms:</p>
<div class="mathblock"><script type="math/tex; mode=display">
\begin{align*}
expr ::=&~\;x    &&\text{variable}\\
  &|~(\lam x. {\tt e}) &&\text{abstraction}\\
  &|~({\tt e}\ {\tt e})  &&\text{application}
\end{align*}
</script></div>
<p>An abstraction $(\lam x. {\tt e})$ binds the variable $x$ in the $expr$ ${\tt e}$; that is,
it's a one-parameter function. We can't do anything with an abstraction until we
have something to apply to it, which is what the application form does. As a
consequence of the untyped calculus, the left ${\tt e}$ in the application form can
be an arbitrary $expr$, not necessarily an abstraction.</p>
<p>A program in the untyped lambda calculus is just an expression composed from
these three forms. Here's one:</p>
<div class="mathblock"><script type="math/tex; mode=display">
((\lam x. x)\ ((\lam y. y)\ z))
</script></div>
<p>&quot;Intuitively&quot;, we might reduce this as</p>
<div class="mathblock"><script type="math/tex; mode=display">
((\lam x. x)\ ((\lam y. y)\ z)) \Ra ((\lam x. x)\ z) \Ra z
</script></div>
<p>but there's one
other reduction procedure to $z$ (what is it?). This reduction process is
exactly evaluation of the lambda calculus. Sequences of reductions are also
called normalization, for reasons that will be made apparent later.</p>
<p>This program doesn't communicate anything useful, but as we mentioned before,
the lambda calculus is equivalent to a Turing machine! It's crazy to imagine,
but it might suggest we have our work set out for us if we want to implement it
in the TypeScript type system.</p>
<p>We'll start off with something easy and fun: the syntax, a pretty-printer, and
parser. First, the basic definitions:</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000"> = </span><span style="color: #267F99"><data-lsp lsp='type Var&lt;X extends string> = {&#10;    x: X;&#10;}' >Var</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99">string</span><span style="color: #000000">&gt;|</span><span style="color: #267F99"><data-lsp lsp='type Abs&lt;S extends string, B extends Expr> = {&#10;    s: S;&#10;    b: B;&#10;}' >Abs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99">string</span><span style="color: #000000">, </span><span style="color: #267F99">any</span><span style="color: #000000">&gt;|</span><span style="color: #267F99"><data-lsp lsp='type App&lt;E1 extends Expr, E2 extends Expr> = {&#10;    e1: E1;&#10;    e2: E2;&#10;}' >App</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99">any</span><span style="color: #000000">, </span><span style="color: #267F99">any</span><span style="color: #000000">&gt;;</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Var&lt;X extends string> = {&#10;    x: X;&#10;}' >Var</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) X in type Var&lt;X extends string>' >X</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">string</span><span style="color: #000000">&gt; = {</span><span style="color: #001080"><data-lsp lsp='(property) x: X extends string' >x</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='(type parameter) X in type Var&lt;X extends string>' >X</data-lsp></span><span style="color: #000000">};</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Abs&lt;S extends string, B extends Expr> = {&#10;    s: S;&#10;    b: B;&#10;}' >Abs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) S in type Abs&lt;S extends string, B extends Expr>' >S</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">string</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B in type Abs&lt;S extends string, B extends Expr>' >B</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000">&gt; = {</span><span style="color: #001080"><data-lsp lsp='(property) s: S extends string' >s</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='(type parameter) S in type Abs&lt;S extends string, B extends Expr>' >S</data-lsp></span><span style="color: #000000">, </span><span style="color: #001080"><data-lsp lsp='(property) b: B extends Expr' >b</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B in type Abs&lt;S extends string, B extends Expr>' >B</data-lsp></span><span style="color: #000000">};</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type App&lt;E1 extends Expr, E2 extends Expr> = {&#10;    e1: E1;&#10;    e2: E2;&#10;}' >App</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1 in type App&lt;E1 extends Expr, E2 extends Expr>' >E1</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2 in type App&lt;E1 extends Expr, E2 extends Expr>' >E2</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000">&gt; = {</span><span style="color: #001080"><data-lsp lsp='(property) e1: E1 extends Expr' >e1</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1 in type App&lt;E1 extends Expr, E2 extends Expr>' >E1</data-lsp></span><span style="color: #000000">, </span><span style="color: #001080"><data-lsp lsp='(property) e2: E2 extends Expr' >e2</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2 in type App&lt;E1 extends Expr, E2 extends Expr>' >E2</data-lsp></span><span style="color: #000000">};</span></div></code></div></pre>
<p>Notice the use of <code>any</code> in the definition of <code>Expr</code>. Writing <code>Expr</code> in place of
<code>any</code> would cause <code>Expr</code> to be a self-referential type, which TypeScript <a href="https://github.com/microsoft/TypeScript/issues/14837">no
longer permits</a>.
Fortunately, the use of <code>any</code> here does not detriment our implementation.</p>
<p>Since TypeScript added <a href="https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html">template literal string types</a>,
we can provide a type-level pretty-printer for expressions:</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type StringOfExpr&lt;T extends Expr> = T extends Var&lt;string> ? `${T["x"]}` : T extends Abs&lt;string, any> ? StringOfExpr&lt;T["b"]> extends infer B ? B extends string ? `(\u03BB${T["s"]}. ${B})` : never : never : T extends App&lt;...> ? StringOfExpr&lt;...> extends infer E1 ? E1 extends string ? StringOfExpr&lt;...> extends infer E2 ? E2 extends string ? `(${E1} ${E2})` : never : never : never : never : never' >StringOfExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type StringOfExpr&lt;T extends Expr>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000">&gt;</span></div><div class='line'><span style="color: #000000">    = </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type StringOfExpr&lt;T extends Expr>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Var&lt;X extends string> = {&#10;    x: X;&#10;}' >Var</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99">string</span><span style="color: #000000">&gt; ? </span><span style="color: #A31515">`</span><span style="color: #0000FF">${</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type StringOfExpr&lt;T extends Expr>' >T</data-lsp></span><span style="color: #000000FF">[</span><span style="color: #A31515">&apos;x&apos;</span><span style="color: #000000FF">]</span><span style="color: #0000FF">}</span><span style="color: #A31515">`</span></div><div class='line'><span style="color: #000000">    : </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type StringOfExpr&lt;T extends Expr>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Abs&lt;S extends string, B extends Expr> = {&#10;    s: S;&#10;    b: B;&#10;}' >Abs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99">string</span><span style="color: #000000">, </span><span style="color: #267F99">any</span><span style="color: #000000">&gt; ?</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #267F99"><data-lsp lsp='type StringOfExpr&lt;T extends Expr> = T extends Var&lt;string> ? `${T["x"]}` : T extends Abs&lt;string, any> ? StringOfExpr&lt;T["b"]> extends infer B ? B extends string ? `(\u03BB${T["s"]}. ${B})` : never : never : T extends App&lt;...> ? StringOfExpr&lt;...> extends infer E1 ? E1 extends string ? StringOfExpr&lt;...> extends infer E2 ? E2 extends string ? `(${E1} ${E2})` : never : never : never : never : never' >StringOfExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type StringOfExpr&lt;T extends Expr>' >T</data-lsp></span><span style="color: #000000">[</span><span style="color: #A31515">&apos;b&apos;</span><span style="color: #000000">]&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B' >B</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B' >B</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">string</span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #A31515">`(λ</span><span style="color: #0000FF">${</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type StringOfExpr&lt;T extends Expr>' >T</data-lsp></span><span style="color: #000000FF">[</span><span style="color: #A31515">&apos;s&apos;</span><span style="color: #000000FF">]</span><span style="color: #0000FF">}</span><span style="color: #A31515">. </span><span style="color: #0000FF">${</span><span style="color: #267F99"><data-lsp lsp='(type parameter) B' >B</data-lsp></span><span style="color: #0000FF">}</span><span style="color: #A31515">)`</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span></div><div class='line'><span style="color: #000000">    : </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type StringOfExpr&lt;T extends Expr>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type App&lt;E1 extends Expr, E2 extends Expr> = {&#10;    e1: E1;&#10;    e2: E2;&#10;}' >App</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99">any</span><span style="color: #000000">, </span><span style="color: #267F99">any</span><span style="color: #000000">&gt; ?</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #267F99"><data-lsp lsp='type StringOfExpr&lt;T extends Expr> = T extends Var&lt;string> ? `${T["x"]}` : T extends Abs&lt;string, any> ? StringOfExpr&lt;T["b"]> extends infer B ? B extends string ? `(\u03BB${T["s"]}. ${B})` : never : never : T extends App&lt;...> ? StringOfExpr&lt;...> extends infer E1 ? E1 extends string ? StringOfExpr&lt;...> extends infer E2 ? E2 extends string ? `(${E1} ${E2})` : never : never : never : never : never' >StringOfExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type StringOfExpr&lt;T extends Expr>' >T</data-lsp></span><span style="color: #000000">[</span><span style="color: #A31515">&apos;e1&apos;</span><span style="color: #000000">]&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1' >E1</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1' >E1</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">string</span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #267F99"><data-lsp lsp='type StringOfExpr&lt;T extends Expr> = T extends Var&lt;string> ? `${T["x"]}` : T extends Abs&lt;string, any> ? StringOfExpr&lt;T["b"]> extends infer B ? B extends string ? `(\u03BB${T["s"]}. ${B})` : never : never : T extends App&lt;...> ? StringOfExpr&lt;...> extends infer E1 ? E1 extends string ? StringOfExpr&lt;...> extends infer E2 ? E2 extends string ? `(${E1} ${E2})` : never : never : never : never : never' >StringOfExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type StringOfExpr&lt;T extends Expr>' >T</data-lsp></span><span style="color: #000000">[</span><span style="color: #A31515">&apos;e2&apos;</span><span style="color: #000000">]&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2' >E2</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2' >E2</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">string</span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #A31515">`(</span><span style="color: #0000FF">${</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1' >E1</data-lsp></span><span style="color: #0000FF">}</span><span style="color: #A31515"> </span><span style="color: #0000FF">${</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2' >E2</data-lsp></span><span style="color: #0000FF">}</span><span style="color: #A31515">)`</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span></div><div class='line'><span style="color: #000000">    : </span><span style="color: #267F99">never</span><span style="color: #000000">;</span></div></code></div></pre>
<p>We will see patterns of the form <code>StringOfExpr&lt;T['b']&gt; extends infer B ? B extends string</code>, as above, often in our implementation.
This unravelling of an type to an intermediate inference variable <code>B</code> aids the
typechecker by instructing it to solve for one unconstrained variable at a
time. Without this guidance, the type instantiation space may balloon exponentially,
causing the checker to give up. Usually this ballooning isn't too bad, but
<code>StringOfExpr</code> is a pretty complex type, so nested references can grow quite
large.</p>
<p>Template literal types can be pattern-matched by the typechecker, so we can also
provide a type-level parser for lambda calculus expressions.</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type ParseVar&lt;T> = T extends `${infer X}` ? Var&lt;X> : never' >ParseVar</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type ParseVar&lt;T>' >T</data-lsp></span><span style="color: #000000">&gt; = </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type ParseVar&lt;T>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #A31515">`</span><span style="color: #0000FF">${</span><span style="color: #0000FF">infer</span><span style="color: #000000FF"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) X' >X</data-lsp></span><span style="color: #0000FF">}</span><span style="color: #A31515">`</span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='type Var&lt;X extends string> = {&#10;    x: X;&#10;}' >Var</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) X' >X</data-lsp></span><span style="color: #000000">&gt; : </span><span style="color: #267F99">never</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type ParseAbs&lt;T> = T extends `(\u03BB${infer S}. ${infer B})` ? Abs&lt;S, ParseExpr&lt;B>> : never' >ParseAbs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type ParseAbs&lt;T>' >T</data-lsp></span><span style="color: #000000">&gt; = </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type ParseAbs&lt;T>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #A31515">`(λ</span><span style="color: #0000FF">${</span><span style="color: #0000FF">infer</span><span style="color: #000000FF"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) S' >S</data-lsp></span><span style="color: #0000FF">}</span><span style="color: #A31515">. </span><span style="color: #0000FF">${</span><span style="color: #0000FF">infer</span><span style="color: #000000FF"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B' >B</data-lsp></span><span style="color: #0000FF">}</span><span style="color: #A31515">)`</span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='type Abs&lt;S extends string, B extends Expr> = {&#10;    s: S;&#10;    b: B;&#10;}' >Abs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) S' >S</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='type ParseExpr&lt;T> = ParseAbs&lt;T> extends never ? ParseApp&lt;T> extends never ? ParseVar&lt;T> extends never ? never : ParseVar&lt;T> : ParseApp&lt;T> : ParseAbs&lt;...>' >ParseExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) B' >B</data-lsp></span><span style="color: #000000">&gt;&gt; : </span><span style="color: #267F99">never</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type ParseApp&lt;T> = T extends `(${infer E1} ${infer E2})` ? App&lt;ParseExpr&lt;E1>, ParseExpr&lt;E2>> : never' >ParseApp</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type ParseApp&lt;T>' >T</data-lsp></span><span style="color: #000000">&gt; = </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type ParseApp&lt;T>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #A31515">`(</span><span style="color: #0000FF">${</span><span style="color: #0000FF">infer</span><span style="color: #000000FF"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1' >E1</data-lsp></span><span style="color: #0000FF">}</span><span style="color: #A31515"> </span><span style="color: #0000FF">${</span><span style="color: #0000FF">infer</span><span style="color: #000000FF"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2' >E2</data-lsp></span><span style="color: #0000FF">}</span><span style="color: #A31515">)`</span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='type App&lt;E1 extends Expr, E2 extends Expr> = {&#10;    e1: E1;&#10;    e2: E2;&#10;}' >App</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type ParseExpr&lt;T> = ParseAbs&lt;T> extends never ? ParseApp&lt;T> extends never ? ParseVar&lt;T> extends never ? never : ParseVar&lt;T> : ParseApp&lt;T> : ParseAbs&lt;...>' >ParseExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1' >E1</data-lsp></span><span style="color: #000000">&gt;, </span><span style="color: #267F99"><data-lsp lsp='type ParseExpr&lt;T> = ParseAbs&lt;T> extends never ? ParseApp&lt;T> extends never ? ParseVar&lt;T> extends never ? never : ParseVar&lt;T> : ParseApp&lt;T> : ParseAbs&lt;...>' >ParseExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2' >E2</data-lsp></span><span style="color: #000000">&gt;&gt; : </span><span style="color: #267F99">never</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type ParseExpr&lt;T> = ParseAbs&lt;T> extends never ? ParseApp&lt;T> extends never ? ParseVar&lt;T> extends never ? never : ParseVar&lt;T> : ParseApp&lt;T> : ParseAbs&lt;...>' >ParseExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type ParseExpr&lt;T>' >T</data-lsp></span><span style="color: #000000">&gt; =</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99"><data-lsp lsp='type ParseAbs&lt;T> = T extends `(\u03BB${infer S}. ${infer B})` ? Abs&lt;S, ParseExpr&lt;B>> : never' >ParseAbs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type ParseExpr&lt;T>' >T</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">never</span></div><div class='line'><span style="color: #000000">    ? ( </span><span style="color: #267F99"><data-lsp lsp='type ParseApp&lt;T> = T extends `(${infer E1} ${infer E2})` ? App&lt;ParseExpr&lt;E1>, ParseExpr&lt;E2>> : never' >ParseApp</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type ParseExpr&lt;T>' >T</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">never</span></div><div class='line'><span style="color: #000000">        ? ( </span><span style="color: #267F99"><data-lsp lsp='type ParseVar&lt;T> = T extends `${infer X}` ? Var&lt;X> : never' >ParseVar</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type ParseExpr&lt;T>' >T</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">never</span></div><div class='line'><span style="color: #000000">            ? </span><span style="color: #267F99">never</span></div><div class='line'><span style="color: #000000">            : </span><span style="color: #267F99"><data-lsp lsp='type ParseVar&lt;T> = T extends `${infer X}` ? Var&lt;X> : never' >ParseVar</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type ParseExpr&lt;T>' >T</data-lsp></span><span style="color: #000000">&gt; )</span></div><div class='line'><span style="color: #000000">        : </span><span style="color: #267F99"><data-lsp lsp='type ParseApp&lt;T> = T extends `(${infer E1} ${infer E2})` ? App&lt;ParseExpr&lt;E1>, ParseExpr&lt;E2>> : never' >ParseApp</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type ParseExpr&lt;T>' >T</data-lsp></span><span style="color: #000000">&gt; )</span></div><div class='line'><span style="color: #000000">    : </span><span style="color: #267F99"><data-lsp lsp='type ParseAbs&lt;T> = T extends `(\u03BB${infer S}. ${infer B})` ? Abs&lt;S, ParseExpr&lt;B>> : never' >ParseAbs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type ParseExpr&lt;T>' >T</data-lsp></span><span style="color: #000000">&gt;;</span></div></code></div></pre>
<p>Since our parser is top-down and pattern-based, it is even weaker than a regex-based parser.
Indeed, it fails to properly parse nested applications or abstractions on the left. For example,</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type BadParse = {&#10;    e1: Var&lt;"(λx.">;&#10;    e2: Var&lt;"x) y">;&#10;}' style='border-bottom: solid 2px lightgrey;'>BadParse</data-lsp></span><span style="color: #000000"> = </span><span style="color: #267F99"><data-lsp lsp='type ParseExpr&lt;T> = ParseAbs&lt;T> extends never ? ParseApp&lt;T> extends never ? ParseVar&lt;T> extends never ? never : ParseVar&lt;T> : ParseApp&lt;T> : ParseAbs&lt;...>' >ParseExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"((λx. x) y)"</span><span style="color: #000000">&gt;;</span></div><div class='meta-line'><span class='popover-prefix'>        </span><span class='popover'><div class='arrow'></div>type BadParse = {
    e1: Var&lt;"(λx."&gt;;
    e2: Var&lt;"x) y"&gt;;
}</span></div></code></div></pre>
<p>But this is not a post about parsing. We'll live with this solution, and write
out expressions in the internal syntax when parsing does a bad job.</p>
<h2 id="%24%5Cbeta%24-reduction" tabindex="-1"><a class="header-anchor" href="#%24%5Cbeta%24-reduction" aria-hidden="true"></a>$\beta$-reduction</h2>
<p>The only place where something can get evaluated in an expression is at an
application to an abstraction. The process of evaluating of an abstraction body
with an applied argument is called <strong>$\beta$-reduction</strong>. Explicitly,
$\beta$-reduction is the rule</p>
<div class="mathblock"><script type="math/tex; mode=display">
((\lam x. b)\ a) \Ra [a/x]b
</script></div>
<p>where the <strong>substitution</strong> $[a/x]b$ replaces free occurrences of the variable $x$ in $b$ with $a$.
Expressions to which reductions can be applied are called <b>redex</b>es
(<b>red</b>ucible <b>ex</b>pressions); in particular, expressions to which
$\beta$-reductions can be applied are called $\beta$-redexes.</p>
<p>Performing substitution is a bit tricky, so before we give a type-level
algorithm to do so, we should talk about some subtle cases.</p>
<h2 id="free-variables" tabindex="-1"><a class="header-anchor" href="#free-variables" aria-hidden="true"></a>Free variables</h2>
<p>What do we mean by free occurrences of a variable? Consider
$((\lam x. (x\ (\lam x. x)))\ (y\ z))$. If we were to perform the substitution
$[(y\ z)/x]\hspace{0pt}(x\ (\lam x. x))$ by replacing all occurrences of
$x$ we wouldn't even get a syntactically-valid expression! If we replaced
all variables named $x$ we would get $((y\ z)\ (\lam x. (y\ z)))$, which is
incorrect because the innermost abstraction is no longer the identity function.
Rather, we only want to replace the first variable $x$, as it is free of binding by any
enclosing abstraction. The second variable $x$ is bound to an enclosing abstraction,
so we should not touch it during substitution. Distinguishing between
free and bound variables this way, we see that the correct reduction is $((y\ z)\ (\lam x. x))$.</p>
<p>Discovery of free variables in an expression will be important in for our
evaluator. We can construct a recursive predicate <code>Free</code> that
collects all variables into a union of literals by traversing a type bottom-up.
The only variables we need to exclude from this collection are those bound by an
abstraction.</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Free&lt;T extends Expr> = T extends Var&lt;infer X> ? X : T extends Abs&lt;infer S, infer B> ? Exclude&lt;Free&lt;B>, S> : T extends App&lt;infer E1, infer E2> ? Free&lt;E1> | Free&lt;E2> : never' >Free</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type Free&lt;T extends Expr>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000">&gt;</span></div><div class='line'><span style="color: #000000">    = </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type Free&lt;T extends Expr>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Var&lt;X extends string> = {&#10;    x: X;&#10;}' >Var</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) X' >X</data-lsp></span><span style="color: #000000">&gt; ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) X' >X</data-lsp></span></div><div class='line'><span style="color: #000000">    : </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type Free&lt;T extends Expr>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Abs&lt;S extends string, B extends Expr> = {&#10;    s: S;&#10;    b: B;&#10;}' >Abs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) S' >S</data-lsp></span><span style="color: #000000">, </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B' >B</data-lsp></span><span style="color: #000000">&gt; ? </span><span style="color: #267F99"><data-lsp lsp='Exclude from T those types that are assignable to U&#10;&#10;type Exclude&lt;T, U> = T extends U ? never : T' >Exclude</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type Free&lt;T extends Expr> = T extends Var&lt;infer X> ? X : T extends Abs&lt;infer S, infer B> ? Exclude&lt;Free&lt;B>, S> : T extends App&lt;infer E1, infer E2> ? Free&lt;E1> | Free&lt;E2> : never' >Free</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) B' >B</data-lsp></span><span style="color: #000000">&gt;, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) S' >S</data-lsp></span><span style="color: #000000">&gt;</span></div><div class='line'><span style="color: #000000">    : </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type Free&lt;T extends Expr>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type App&lt;E1 extends Expr, E2 extends Expr> = {&#10;    e1: E1;&#10;    e2: E2;&#10;}' >App</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1' >E1</data-lsp></span><span style="color: #000000">, </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2' >E2</data-lsp></span><span style="color: #000000">&gt; ? </span><span style="color: #267F99"><data-lsp lsp='type Free&lt;T extends Expr> = T extends Var&lt;infer X> ? X : T extends Abs&lt;infer S, infer B> ? Exclude&lt;Free&lt;B>, S> : T extends App&lt;infer E1, infer E2> ? Free&lt;E1> | Free&lt;E2> : never' >Free</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1' >E1</data-lsp></span><span style="color: #000000">&gt;|</span><span style="color: #267F99"><data-lsp lsp='type Free&lt;T extends Expr> = T extends Var&lt;infer X> ? X : T extends Abs&lt;infer S, infer B> ? Exclude&lt;Free&lt;B>, S> : T extends App&lt;infer E1, infer E2> ? Free&lt;E1> | Free&lt;E2> : never' >Free</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2' >E2</data-lsp></span><span style="color: #000000">&gt; : </span><span style="color: #267F99">never</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type FreeTest1 = "x" | "z"' style='border-bottom: solid 2px lightgrey;'>FreeTest1</data-lsp></span><span style="color: #000000"> = </span><span style="color: #267F99"><data-lsp lsp='type Free&lt;T extends Expr> = T extends Var&lt;infer X> ? X : T extends Abs&lt;infer S, infer B> ? Exclude&lt;Free&lt;B>, S> : T extends App&lt;infer E1, infer E2> ? Free&lt;E1> | Free&lt;E2> : never' >Free</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type ParseExpr&lt;T> = ParseAbs&lt;T> extends never ? ParseApp&lt;T> extends never ? ParseVar&lt;T> extends never ? never : ParseVar&lt;T> : ParseApp&lt;T> : ParseAbs&lt;...>' >ParseExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"(x z)"</span><span style="color: #000000">&gt;&gt;;</span></div><div class='meta-line'><span class='popover-prefix'>        </span><span class='popover'><div class='arrow'></div>type FreeTest1 = "x" | "z"</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type FreeTest2 = "x" | "z"' style='border-bottom: solid 2px lightgrey;'>FreeTest2</data-lsp></span><span style="color: #000000"> = </span><span style="color: #267F99"><data-lsp lsp='type Free&lt;T extends Expr> = T extends Var&lt;infer X> ? X : T extends Abs&lt;infer S, infer B> ? Exclude&lt;Free&lt;B>, S> : T extends App&lt;infer E1, infer E2> ? Free&lt;E1> | Free&lt;E2> : never' >Free</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type ParseExpr&lt;T> = ParseAbs&lt;T> extends never ? ParseApp&lt;T> extends never ? ParseVar&lt;T> extends never ? never : ParseVar&lt;T> : ParseApp&lt;T> : ParseAbs&lt;...>' >ParseExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"(λy. (x (y z)))"</span><span style="color: #000000">&gt;&gt;;</span></div><div class='meta-line'><span class='popover-prefix'>        </span><span class='popover'><div class='arrow'></div>type FreeTest2 = "x" | "z"</span></div></code></div></pre>
<h2 id="%24%5Calpha%24-conversion" tabindex="-1"><a class="header-anchor" href="#%24%5Calpha%24-conversion" aria-hidden="true"></a>$\alpha$-conversion</h2>
<p>There's another tricky case in substitution. Consider $[x/y]\hspace{0pt}(\lam x. y)$.
This time, a literal replacement yields the identity function $(\lam x. x)$
rather than a constant function to $x$ in the outer scope. If only the bound $x$
had been named something else, say $x'$, we would end up with the constant
function $(\lam x'. x)$ we expect.</p>
<p>Indeed, there is no reason we can't arbitrarily rename bound variables in such cases.
For example, $(\lam x. (\lam y. (x\ y)))$ and $(\lam x. (\lam z. (x\ z)))$
differ in the name of their second bound variables, but are computationally
equivalent. Renaming bound variables to computationally equivalent expressions
is called <strong>$\alpha$-conversion</strong>. We say that two
expressions are <strong>$\alpha$-equivalent</strong> if they are syntactically equivalent, up to
$\alpha$-conversion. You may be familiar with $\alpha$-conversion and
$\alpha$-equivalence if you've ever renamed a variable in a codebase; hopefully
it didn't cause a failure!</p>
<p>We'll return to $\alpha$-equivalence later on when talking about program
equivalence. Regarding our present issue, it is enough to stipulate that when we
have a $\beta$-redex $((\lambda x. b)\ a)$ where $x\in\text{Free}(a)$, we should
choose a fresh variable name for $x$ and perform $\alpha$-conversion on the
abstraction before proceeding. The only requirement is that we choose a variable
name that is not already free in $a$ or $b$, otherwise we end up with the same
problem again (in the former case) or accidentally binding a free variable
(in the latter case). The popular strategy is to tack on single quotes until these
requirements are met.</p>
<p>Here's a type constructor to find a fresh variable name given a collection (union)
of reserved names.</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Freshen&lt;X extends string, Used> = X extends Used ? Freshen&lt;`${X}&apos;`, Used> : X' >Freshen</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) X in type Freshen&lt;X extends string, Used>' >X</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">string</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Used in type Freshen&lt;X extends string, Used>' >Used</data-lsp></span><span style="color: #000000">&gt; = </span><span style="color: #267F99"><data-lsp lsp='(type parameter) X in type Freshen&lt;X extends string, Used>' >X</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Used in type Freshen&lt;X extends string, Used>' >Used</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='type Freshen&lt;X extends string, Used> = X extends Used ? Freshen&lt;`${X}&apos;`, Used> : X' >Freshen</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">`</span><span style="color: #0000FF">${</span><span style="color: #267F99"><data-lsp lsp='(type parameter) X in type Freshen&lt;X extends string, Used>' >X</data-lsp></span><span style="color: #0000FF">}</span><span style="color: #A31515">&apos;`</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Used in type Freshen&lt;X extends string, Used>' >Used</data-lsp></span><span style="color: #000000">&gt; : </span><span style="color: #267F99"><data-lsp lsp='(type parameter) X in type Freshen&lt;X extends string, Used>' >X</data-lsp></span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const freshen_test1: "x&apos;&apos;"' >freshen_test1</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type Freshen&lt;X extends string, Used> = X extends Used ? Freshen&lt;`${X}&apos;`, Used> : X' >Freshen</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"x"</span><span style="color: #000000">, </span><span style="color: #A31515">"x"</span><span style="color: #000000">|</span><span style="color: #A31515">"y"</span><span style="color: #000000">|</span><span style="color: #A31515">"x&apos;"</span><span style="color: #000000">&gt; = </span><span style="color: #A31515">`x&apos;&apos;`</span><span style="color: #000000">;</span></div></code></div></pre>
<h2 id="substitution" tabindex="-1"><a class="header-anchor" href="#substitution" aria-hidden="true"></a>Substitution</h2>
<p>We now use our notes from the two sections above to come up with a proper
algorithm for the right hand side of $\beta$-reduction, via a type constructor
<code>Subst&lt;X, A, E&gt;</code> that performs the substitution <code>[A/X]E</code>.</p>
<p>In the interest of a
performant type-level algorithm that the typechecker will be willing to compute,
we make some adjustments to the high-level ideas previously discussed.</p>
<p>Rather than explicitly performing alpha conversion on an abstraction body every
time its binder (say $x$) interferes with a free variable in the replacement expression,
we generate a fresh binder name (say $x'$) and store the mapping $x\to x'$ in a
&quot;substitution context&quot; we pass on to substitution of the abstraction
body. Then, whenever we see a variable, if it is in the substitution context
(either because it is the original substitution target, or needs to undergo $\alpha$-conversion),
we replace it with its mapping. Otherwise, the variable is untouched. This
implicit $\alpha$-conversion as we go requires only one pass of the expression,
whereas explicit $\alpha$-conversion everytime it is needed would result in a
quadratic substitution algorithm.</p>
<p>To avoid having to compute the free variables of the expression we wish to
substitute everytime we need to check a binder for $\alpha$-conversion, we
compute the collection of free variables once and pass it down to nested
expressions as needed<span class="note"><label for="alpha-variables" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="alpha-variables" class="margin-toggle" /><span class="sidenote">At an abstraction, why don't
we need to check if the binder is free in the right-hand mappings of all
variables in our context? Hint: Recall that other than the substitution $[X\to A]$,
there is only one other kind of mapping in the context.</span>.</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Subst&lt;X extends string, A extends Expr, E extends Expr> = E extends Var&lt;infer U> ? (X extends U ? A : NotFound) extends infer R ? R extends Expr ? R : E : never : E extends App&lt;infer E1, infer E2> ? Subst_&lt;...> extends infer E11 ? E11 extends Expr ? Subst_&lt;...> extends infer E21 ? E21 extends Expr ? App&lt;...> : never : never : never : never : E extends Abs&lt;...> ? S extends X ? E : S extends Free&lt;...> ? Free&lt;...> | Free&lt;...> extends infer FreeXB ? Freshen&lt;...> extends infer S1 ? S1 extends string ? Subst_&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : never : never : never : Subst_&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : never' >Subst</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) X in type Subst&lt;X extends string, A extends Expr, E extends Expr>' >X</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">string</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) A in type Subst&lt;X extends string, A extends Expr, E extends Expr>' >A</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E in type Subst&lt;X extends string, A extends Expr, E extends Expr>' >E</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000">&gt;</span></div><div class='line'><span style="color: #000000">    = </span><span style="color: #267F99"><data-lsp lsp='type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA> = E extends Var&lt;infer U> ? Find&lt;Expr, U, Subs> extends infer R ? R extends Expr ? R : E : never : E extends App&lt;infer E1, infer E2> ? Subst_&lt;X, E1, Subs, FreeInA> extends infer E11 ? E11 extends Expr ? Subst_&lt;...> extends infer E21 ? E21 extends Expr ? App&lt;...> : never : never : never : never : E extends Abs&lt;...> ? S extends X ? E : S extends FreeInA ? FreeInA | Free&lt;...> extends infer FreeXB ? Freshen&lt;...> extends infer S1 ? S1 extends string ? Subst_&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : never : never : never : Subst_&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : never' >Subst_</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) X in type Subst&lt;X extends string, A extends Expr, E extends Expr>' >X</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E in type Subst&lt;X extends string, A extends Expr, E extends Expr>' >E</data-lsp></span><span style="color: #000000">, [[</span><span style="color: #267F99"><data-lsp lsp='(type parameter) X in type Subst&lt;X extends string, A extends Expr, E extends Expr>' >X</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) A in type Subst&lt;X extends string, A extends Expr, E extends Expr>' >A</data-lsp></span><span style="color: #000000">]], </span><span style="color: #267F99"><data-lsp lsp='type Free&lt;T extends Expr> = T extends Var&lt;infer X> ? X : T extends Abs&lt;infer S, infer B> ? Exclude&lt;Free&lt;B>, S> : T extends App&lt;infer E1, infer E2> ? Free&lt;E1> | Free&lt;E2> : never' >Free</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) A in type Subst&lt;X extends string, A extends Expr, E extends Expr>' >A</data-lsp></span><span style="color: #000000">&gt;&gt;;</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA> = E extends Var&lt;infer U> ? Find&lt;Expr, U, Subs> extends infer R ? R extends Expr ? R : E : never : E extends App&lt;infer E1, infer E2> ? Subst_&lt;X, E1, Subs, FreeInA> extends infer E11 ? E11 extends Expr ? Subst_&lt;...> extends infer E21 ? E21 extends Expr ? App&lt;...> : never : never : never : never : E extends Abs&lt;...> ? S extends X ? E : S extends FreeInA ? FreeInA | Free&lt;...> extends infer FreeXB ? Freshen&lt;...> extends infer S1 ? S1 extends string ? Subst_&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : never : never : never : Subst_&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : never' >Subst_</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) X in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >X</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">string</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >E</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Subs in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >Subs</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Ctx&lt;T> = [string, T][]' >Ctx</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000">&gt;, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) FreeInA in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >FreeInA</data-lsp></span><span style="color: #000000">&gt;</span></div><div class='line'><span style="color: #000000">    = </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >E</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Var&lt;X extends string> = {&#10;    x: X;&#10;}' >Var</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) U' >U</data-lsp></span><span style="color: #000000">&gt; ?</span></div><div class='line'><span style="color: #000000">        (</span><span style="color: #267F99"><data-lsp lsp='type Find&lt;T, X extends string, L extends Ctx&lt;T>> = L extends [[infer Y, infer N], ...infer B] ? Y extends X ? N : B extends Ctx&lt;T> ? Find&lt;T, X, B> : never : NotFound' >Find</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) U' >U</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Subs in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >Subs</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) R' >R</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) R' >R</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) R' >R</data-lsp></span><span style="color: #000000"> : </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >E</data-lsp></span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000">)</span></div><div class='line'><span style="color: #000000">    : </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >E</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type App&lt;E1 extends Expr, E2 extends Expr> = {&#10;    e1: E1;&#10;    e2: E2;&#10;}' >App</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1' >E1</data-lsp></span><span style="color: #000000">, </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2' >E2</data-lsp></span><span style="color: #000000">&gt; ?</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #267F99"><data-lsp lsp='type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA> = E extends Var&lt;infer U> ? Find&lt;Expr, U, Subs> extends infer R ? R extends Expr ? R : E : never : E extends App&lt;infer E1, infer E2> ? Subst_&lt;X, E1, Subs, FreeInA> extends infer E11 ? E11 extends Expr ? Subst_&lt;...> extends infer E21 ? E21 extends Expr ? App&lt;...> : never : never : never : never : E extends Abs&lt;...> ? S extends X ? E : S extends FreeInA ? FreeInA | Free&lt;...> extends infer FreeXB ? Freshen&lt;...> extends infer S1 ? S1 extends string ? Subst_&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : never : never : never : Subst_&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : never' >Subst_</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) X in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >X</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1' >E1</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Subs in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >Subs</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) FreeInA in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >FreeInA</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E11' >E11</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E11' >E11</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #267F99"><data-lsp lsp='type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA> = E extends Var&lt;infer U> ? Find&lt;Expr, U, Subs> extends infer R ? R extends Expr ? R : E : never : E extends App&lt;infer E1, infer E2> ? Subst_&lt;X, E1, Subs, FreeInA> extends infer E11 ? E11 extends Expr ? Subst_&lt;...> extends infer E21 ? E21 extends Expr ? App&lt;...> : never : never : never : never : E extends Abs&lt;...> ? S extends X ? E : S extends FreeInA ? FreeInA | Free&lt;...> extends infer FreeXB ? Freshen&lt;...> extends infer S1 ? S1 extends string ? Subst_&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : never : never : never : Subst_&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : never' >Subst_</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) X in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >X</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2' >E2</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Subs in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >Subs</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) FreeInA in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >FreeInA</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E21' >E21</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E21' >E21</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #267F99"><data-lsp lsp='type App&lt;E1 extends Expr, E2 extends Expr> = {&#10;    e1: E1;&#10;    e2: E2;&#10;}' >App</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E11' >E11</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E21' >E21</data-lsp></span><span style="color: #000000">&gt; : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span></div><div class='line'><span style="color: #000000">    : </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >E</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Abs&lt;S extends string, B extends Expr> = {&#10;    s: S;&#10;    b: B;&#10;}' >Abs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) S' >S</data-lsp></span><span style="color: #000000">, </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B' >B</data-lsp></span><span style="color: #000000">&gt; ? (</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #008000">// Case 1: S = X, shadowing X, so no need to substitute at all.</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #267F99"><data-lsp lsp='(type parameter) S' >S</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) X in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >X</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >E</data-lsp></span><span style="color: #000000"> :</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #008000">// Case 2: S \in Free(A), so naively substituting A in the body will</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #008000">// change what S in A refers to. For example, [x-&gt;s](λs. x) =&gt; λs. s,</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #008000">// which is incorrect. Instead, come up with a fresh name S-&gt;S1.</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #267F99"><data-lsp lsp='(type parameter) S' >S</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) FreeInA in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >FreeInA</data-lsp></span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">            (</span><span style="color: #267F99"><data-lsp lsp='(type parameter) FreeInA in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >FreeInA</data-lsp></span><span style="color: #000000">|</span><span style="color: #267F99"><data-lsp lsp='type Free&lt;T extends Expr> = T extends Var&lt;infer X> ? X : T extends Abs&lt;infer S, infer B> ? Exclude&lt;Free&lt;B>, S> : T extends App&lt;infer E1, infer E2> ? Free&lt;E1> | Free&lt;E2> : never' >Free</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) B' >B</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) FreeXB' >FreeXB</data-lsp></span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">            </span><span style="color: #267F99"><data-lsp lsp='type Freshen&lt;X extends string, Used> = X extends Used ? Freshen&lt;`${X}&apos;`, Used> : X' >Freshen</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) S' >S</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) FreeXB' >FreeXB</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) S1' >S1</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) S1' >S1</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">string</span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">            </span><span style="color: #267F99"><data-lsp lsp='type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA> = E extends Var&lt;infer U> ? Find&lt;Expr, U, Subs> extends infer R ? R extends Expr ? R : E : never : E extends App&lt;infer E1, infer E2> ? Subst_&lt;X, E1, Subs, FreeInA> extends infer E11 ? E11 extends Expr ? Subst_&lt;...> extends infer E21 ? E21 extends Expr ? App&lt;...> : never : never : never : never : E extends Abs&lt;...> ? S extends X ? E : S extends FreeInA ? FreeInA | Free&lt;...> extends infer FreeXB ? Freshen&lt;...> extends infer S1 ? S1 extends string ? Subst_&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : never : never : never : Subst_&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : never' >Subst_</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) X in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >X</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B' >B</data-lsp></span><span style="color: #000000">, [[</span><span style="color: #267F99"><data-lsp lsp='(type parameter) S' >S</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='type Var&lt;X extends string> = {&#10;    x: X;&#10;}' >Var</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) S1' >S1</data-lsp></span><span style="color: #000000">&gt;], ...</span><span style="color: #267F99"><data-lsp lsp='(type parameter) Subs in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >Subs</data-lsp></span><span style="color: #000000">], </span><span style="color: #267F99"><data-lsp lsp='(type parameter) FreeInA in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >FreeInA</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B1' >B1</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B1' >B1</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">            </span><span style="color: #267F99"><data-lsp lsp='type Abs&lt;S extends string, B extends Expr> = {&#10;    s: S;&#10;    b: B;&#10;}' >Abs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) S1' >S1</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B1' >B1</data-lsp></span><span style="color: #000000">&gt; : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000">) :</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #008000">// Case 3: A doesn&apos;t conflict with the introduced binder S, so direct</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #008000">// substitution is fine.</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #267F99"><data-lsp lsp='type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA> = E extends Var&lt;infer U> ? Find&lt;Expr, U, Subs> extends infer R ? R extends Expr ? R : E : never : E extends App&lt;infer E1, infer E2> ? Subst_&lt;X, E1, Subs, FreeInA> extends infer E11 ? E11 extends Expr ? Subst_&lt;...> extends infer E21 ? E21 extends Expr ? App&lt;...> : never : never : never : never : E extends Abs&lt;...> ? S extends X ? E : S extends FreeInA ? FreeInA | Free&lt;...> extends infer FreeXB ? Freshen&lt;...> extends infer S1 ? S1 extends string ? Subst_&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : never : never : never : Subst_&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : never' >Subst_</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) X in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >X</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B' >B</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Subs in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >Subs</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) FreeInA in type Subst_&lt;X extends string, E extends Expr, Subs extends Ctx&lt;Expr>, FreeInA>' >FreeInA</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B1' >B1</data-lsp></span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">            </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B1' >B1</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='type Abs&lt;S extends string, B extends Expr> = {&#10;    s: S;&#10;    b: B;&#10;}' >Abs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) S' >S</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B1' >B1</data-lsp></span><span style="color: #000000">&gt; : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span></div><div class='line'><span style="color: #000000">    )</span></div><div class='line'><span style="color: #000000">    : </span><span style="color: #267F99">never</span></div></code></div></pre>
<p>Let's write some tests to check our work.</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type SubstTest&lt;X extends string, E extends string, B extends string> = Subst_&lt;X, ParseExpr&lt;B>, [[X, ParseExpr&lt;E>]], Free&lt;ParseExpr&lt;E>>> extends infer R ? R extends Expr ? StringOfExpr&lt;R> : never : never' >SubstTest</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) X in type SubstTest&lt;X extends string, E extends string, B extends string>' >X</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">string</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E in type SubstTest&lt;X extends string, E extends string, B extends string>' >E</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">string</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B in type SubstTest&lt;X extends string, E extends string, B extends string>' >B</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">string</span><span style="color: #000000">&gt; =</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99"><data-lsp lsp='type Subst&lt;X extends string, A extends Expr, E extends Expr> = E extends Var&lt;infer U> ? (X extends U ? A : NotFound) extends infer R ? R extends Expr ? R : E : never : E extends App&lt;infer E1, infer E2> ? Subst_&lt;...> extends infer E11 ? E11 extends Expr ? Subst_&lt;...> extends infer E21 ? E21 extends Expr ? App&lt;...> : never : never : never : never : E extends Abs&lt;...> ? S extends X ? E : S extends Free&lt;...> ? Free&lt;...> | Free&lt;...> extends infer FreeXB ? Freshen&lt;...> extends infer S1 ? S1 extends string ? Subst_&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : never : never : never : Subst_&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : never' >Subst</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) X in type SubstTest&lt;X extends string, E extends string, B extends string>' >X</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='type ParseExpr&lt;T> = ParseAbs&lt;T> extends never ? ParseApp&lt;T> extends never ? ParseVar&lt;T> extends never ? never : ParseVar&lt;T> : ParseApp&lt;T> : ParseAbs&lt;...>' >ParseExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E in type SubstTest&lt;X extends string, E extends string, B extends string>' >E</data-lsp></span><span style="color: #000000">&gt;, </span><span style="color: #267F99"><data-lsp lsp='type ParseExpr&lt;T> = ParseAbs&lt;T> extends never ? ParseApp&lt;T> extends never ? ParseVar&lt;T> extends never ? never : ParseVar&lt;T> : ParseApp&lt;T> : ParseAbs&lt;...>' >ParseExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) B in type SubstTest&lt;X extends string, E extends string, B extends string>' >B</data-lsp></span><span style="color: #000000">&gt;&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) R' >R</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) R' >R</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99"><data-lsp lsp='type StringOfExpr&lt;T extends Expr> = T extends Var&lt;string> ? `${T["x"]}` : T extends Abs&lt;string, any> ? StringOfExpr&lt;T["b"]> extends infer B ? B extends string ? `(\u03BB${T["s"]}. ${B})` : never : never : T extends App&lt;...> ? StringOfExpr&lt;...> extends infer E1 ? E1 extends string ? StringOfExpr&lt;...> extends infer E2 ? E2 extends string ? `(${E1} ${E2})` : never : never : never : never : never' >StringOfExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) R' >R</data-lsp></span><span style="color: #000000">&gt; : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const subst_test1: "(λz. y)"' >subst_test1</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type SubstTest&lt;X extends string, E extends string, B extends string> = Subst_&lt;X, ParseExpr&lt;B>, [[X, ParseExpr&lt;E>]], Free&lt;ParseExpr&lt;E>>> extends infer R ? R extends Expr ? StringOfExpr&lt;R> : never : never' >SubstTest</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"x"</span><span style="color: #000000">, </span><span style="color: #A31515">"y"</span><span style="color: #000000">, </span><span style="color: #A31515">"(λz. x)"</span><span style="color: #000000">&gt; = </span><span style="color: #A31515">"(λz. y)"</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const subst_test2: "(λy&apos;. y)"' >subst_test2</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type SubstTest&lt;X extends string, E extends string, B extends string> = Subst_&lt;X, ParseExpr&lt;B>, [[X, ParseExpr&lt;E>]], Free&lt;ParseExpr&lt;E>>> extends infer R ? R extends Expr ? StringOfExpr&lt;R> : never : never' >SubstTest</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"x"</span><span style="color: #000000">, </span><span style="color: #A31515">"y"</span><span style="color: #000000">, </span><span style="color: #A31515">"(λy. x)"</span><span style="color: #000000">&gt; = </span><span style="color: #A31515">"(λy&apos;. y)"</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const subst_test3: "(λx. x)"' >subst_test3</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type SubstTest&lt;X extends string, E extends string, B extends string> = Subst_&lt;X, ParseExpr&lt;B>, [[X, ParseExpr&lt;E>]], Free&lt;ParseExpr&lt;E>>> extends infer R ? R extends Expr ? StringOfExpr&lt;R> : never : never' >SubstTest</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"x"</span><span style="color: #000000">, </span><span style="color: #A31515">"y"</span><span style="color: #000000">, </span><span style="color: #A31515">"(λx. x)"</span><span style="color: #000000">&gt; = </span><span style="color: #A31515">"(λx. x)"</span><span style="color: #000000">;</span></div></code></div></pre>
<h3 id="contexts" tabindex="-1"><a class="header-anchor" href="#contexts" aria-hidden="true"></a>Contexts</h3>
<p>Hopefully, the completist side of you is nagging at this <code>Ctx</code> type constructor -
we mentioned contexts, but how exactly are they implemented? And how does <code>Find</code>
work?</p>
<p>As case 2 of substitution in abstractions hints, we implement contexts
as associative lists backed by type tuples. If you
know associative lists from OCaml or Lisp, this should be familiar.
Each element of the type tuple is a &quot;mapping&quot; represented by a two-element
tuple. For our purposes contexts only need to map from strings to
something else, so we parameterize <code>Ctx</code>s by only the value type.</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Ctx&lt;T> = [string, T][]' >Ctx</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type Ctx&lt;T>' >T</data-lsp></span><span style="color: #000000">&gt; = [</span><span style="color: #267F99">string</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type Ctx&lt;T>' >T</data-lsp></span><span style="color: #000000">][];</span></div></code></div></pre>
<p><code>Find</code> is pretty straightforward, finding the first mapping from the front of
the context. This is why we add new mappings to the front of a context.
Since we can't throw type-level errors, we report failures to find a mapping
for a key with a special <code>NotFound</code> type.</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type NotFound = {&#10;    __brand: &apos;Not found&apos;;&#10;}' >NotFound</data-lsp></span><span style="color: #000000"> = {</span><span style="color: #001080"><data-lsp lsp='(property) __brand: "Not found"' >__brand</data-lsp></span><span style="color: #000000">: </span><span style="color: #A31515">&apos;Not found&apos;</span><span style="color: #000000">}</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Find&lt;T, X extends string, L extends Ctx&lt;T>> = L extends [[infer Y, infer N], ...infer B] ? Y extends X ? N : B extends Ctx&lt;T> ? Find&lt;T, X, B> : never : NotFound' >Find</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type Find&lt;T, X extends string, L extends Ctx&lt;T>>' >T</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) X in type Find&lt;T, X extends string, L extends Ctx&lt;T>>' >X</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">string</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) L in type Find&lt;T, X extends string, L extends Ctx&lt;T>>' >L</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Ctx&lt;T> = [string, T][]' >Ctx</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type Find&lt;T, X extends string, L extends Ctx&lt;T>>' >T</data-lsp></span><span style="color: #000000">&gt;&gt; =</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99"><data-lsp lsp='(type parameter) L in type Find&lt;T, X extends string, L extends Ctx&lt;T>>' >L</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> [[</span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Y' >Y</data-lsp></span><span style="color: #000000">, </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) N' >N</data-lsp></span><span style="color: #000000">], ...</span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B' >B</data-lsp></span><span style="color: #000000">] ?</span></div><div class='line'><span style="color: #000000">    (</span><span style="color: #267F99"><data-lsp lsp='(type parameter) Y' >Y</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) X in type Find&lt;T, X extends string, L extends Ctx&lt;T>>' >X</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) N' >N</data-lsp></span><span style="color: #000000"> : </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B' >B</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Ctx&lt;T> = [string, T][]' >Ctx</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type Find&lt;T, X extends string, L extends Ctx&lt;T>>' >T</data-lsp></span><span style="color: #000000">&gt; ? </span><span style="color: #267F99"><data-lsp lsp='type Find&lt;T, X extends string, L extends Ctx&lt;T>> = L extends [[infer Y, infer N], ...infer B] ? Y extends X ? N : B extends Ctx&lt;T> ? Find&lt;T, X, B> : never : NotFound' >Find</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type Find&lt;T, X extends string, L extends Ctx&lt;T>>' >T</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) X in type Find&lt;T, X extends string, L extends Ctx&lt;T>>' >X</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B' >B</data-lsp></span><span style="color: #000000">&gt; : </span><span style="color: #267F99">never</span><span style="color: #000000">)</span></div><div class='line'><span style="color: #000000">    : </span><span style="color: #267F99"><data-lsp lsp='type NotFound = {&#10;    __brand: &apos;Not found&apos;;&#10;}' >NotFound</data-lsp></span><span style="color: #000000">;</span></div><div class='line'><span style="color: #000000">    </span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const find_test: 7' >find_test</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type Find&lt;T, X extends string, L extends Ctx&lt;T>> = L extends [[infer Y, infer N], ...infer B] ? Y extends X ? N : B extends Ctx&lt;T> ? Find&lt;T, X, B> : never : NotFound' >Find</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99">number</span><span style="color: #000000">, </span><span style="color: #A31515">"a"</span><span style="color: #000000">, [[</span><span style="color: #A31515">"b"</span><span style="color: #000000">, </span><span style="color: #098658">10</span><span style="color: #000000">], [</span><span style="color: #A31515">"a"</span><span style="color: #000000">, </span><span style="color: #098658">7</span><span style="color: #000000">], [</span><span style="color: #A31515">"c"</span><span style="color: #000000">, </span><span style="color: #098658">15</span><span style="color: #000000">]]&gt; = </span><span style="color: #098658">7</span><span style="color: #000000">;</span></div></code></div></pre>
<h2 id="evaluation%3A-%24%5Cbeta%24-normal-form" tabindex="-1"><a class="header-anchor" href="#evaluation%3A-%24%5Cbeta%24-normal-form" aria-hidden="true"></a>Evaluation: $\beta$ normal form</h2>
<p>As we've seen, $\beta$-reduction is the only meaningful computation to make in
an expression. This leads naturally to a notion of the <strong>$\beta$ normal form</strong> of an
expression, in which there no $\beta$-reductions are possible anywhere in the
term - not in either side of applications, nor inside abstractions<span class="note"><label for="weaker-normal" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="weaker-normal" class="margin-toggle" /><span class="sidenote">There are weaker notions of normal form, for example an expression is in <strong>weak head normal form</strong> (whnf)
if there are no $\beta$-reductions possible in the head position (i.e. top-level applications),
but there may be $\beta$-reductions possible inside arguments to applications or
in the bodies of abstractions. Whnf is the reduction strategy
of Haskell's evaluation semantics; this is part of what is necessary for lazy
evaluation and sharing of computational results.</span>.</p>
<p>Let's look at some examples.</p>
<ul>
<li>As we saw before, the expression $((\lam x. x)\ ((\lam y. y)\ z))$ has a
$\beta$-redex in head position. If we apply this reduction we get
$((\lam y. y)\ z)$, which has another $\beta$-redex in head position.
After we apply it, we get $z$, which has no further $\beta$-reduction, and
so $z$ is the $\beta$ normal form of these expressions.</li>
<li>The expression $(x\ ((\lam y. y)\ z))$ does not have a $\beta$-redex in
head position, but there is one in the argument to the top-level
application. We apply the reduction to get $(x\ z)$, which is in $\beta$ normal
form.</li>
<li>The expression $(\lam x. ((\lam y. y)\ z))$ has no $\beta$-redex in head or
argument position, but there is one inside the top-level abstraction.
Applying the reduction yields $(\lam x. z)$, which is in $\beta$ normal form.</li>
</ul>
<p>An important decision to make is what order we should apply $\beta$-reductions
in. As we mentioned when first introducing the $\beta$-reduction,
$((\lam x. x)\ ((\lam y. y)\ z))$ has multiple normalization sequences - either
by applying the reduction in head position first, or the one in argument position first.
Either way we go we, normalization to $\beta$ normal form ends up at the expression
$z$. Unfortunately, in general we may not be so lucky. One example
(taken from <a href="https://en.wikipedia.org/wiki/Beta_normal_form#Reduction_strategies">Wikipedia</a>)
is</p>
<div class="mathblock"><script type="math/tex; mode=display">
((\lam x. z)\ ((\lam w. (w\ w)\ w)\ (\lam w. (w\ w)\ w)))
</script></div>
<p>If we try to apply the $\beta$-redex in argument position first, we step to the expression</p>
<div class="mathblock"><script type="math/tex; mode=display">
((\lam x. z)\ (((\lam w. (w\ w)\ w)\ (\lam w. (w\ w)\ w))\ (\lam w. (w\ w)\ w)))
</script></div>
<p>with a larger redex in argument position. Indeed, if we keep trying to reduce
in argument position, our normalization sequence will never halt. But there is a
$\beta$ normal form for this expression - if only we had reduced the $\beta$-redex
in head position first, we would wind up with just $z$, since $x$ is never
referenced in the left-hand abstraction body.</p>
<p>It turns out that applying $\beta$-reductions in the leftmost, outermost position
before considering arguments to the right or abstraction bodies one level down
is the &quot;best&quot; normalization strategy in the sense that if a $\beta$ normal form for
an expression exists, this strategy always finds it. This evaluation strategy is
appropriately named <strong>normal order</strong>; the seminal result is known as the
<strong>Standardization Theorem</strong>, proven by Curry and Feys in 1958.</p>
<p>With a strategy in our hands, we can now describe an algorithm for evaluating to
$\beta$ normal form explicitly. Given an expression, we first check if the
top-level is a $\beta$-redex. If it is, we perform the $\beta$-reduction and
compute the $\beta$ normal form of the resulting expression.
Otherwise, the top-level expression must be a variable, an abstraction, or an
application with a non-abstraction on the left-hand side, or an abstraction.
In the first case there is nothing more to do. In the second
case, we compute the $\beta$ normal form of the abstraction body and re-package
the abstraction. In the third case, we compute the $\beta$ normal
form of the application argument and re-package the application.</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type BetaNF&lt;E extends Expr> = E extends App&lt;infer F, infer A> ? BetaNF&lt;F> extends infer F ? F extends Expr ? F extends Abs&lt;infer S, infer B> ? Subst_&lt;S, B, [[S, A]], Free&lt;A>> extends infer B1 ? B1 extends Expr ? BetaNF&lt;...> : never : never : BetaNF&lt;...> extends infer A1 ? A1 extends Expr ? App&lt;...> : never : never : never : never : E extends Abs&lt;...> ? BetaNF&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : E' >BetaNF</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E in type BetaNF&lt;E extends Expr>' >E</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000">&gt;</span></div><div class='line'><span style="color: #000000">    = </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E in type BetaNF&lt;E extends Expr>' >E</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type App&lt;E1 extends Expr, E2 extends Expr> = {&#10;    e1: E1;&#10;    e2: E2;&#10;}' >App</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) F' >F</data-lsp></span><span style="color: #000000">, </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) A' >A</data-lsp></span><span style="color: #000000">&gt; ?</span></div><div class='line'><span style="color: #000000">        (</span><span style="color: #267F99"><data-lsp lsp='type BetaNF&lt;E extends Expr> = E extends App&lt;infer F, infer A> ? BetaNF&lt;F> extends infer F ? F extends Expr ? F extends Abs&lt;infer S, infer B> ? Subst_&lt;S, B, [[S, A]], Free&lt;A>> extends infer B1 ? B1 extends Expr ? BetaNF&lt;...> : never : never : BetaNF&lt;...> extends infer A1 ? A1 extends Expr ? App&lt;...> : never : never : never : never : E extends Abs&lt;...> ? BetaNF&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : E' >BetaNF</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) F' >F</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) F' >F</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) F' >F</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">            (</span><span style="color: #267F99"><data-lsp lsp='(type parameter) F' >F</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Abs&lt;S extends string, B extends Expr> = {&#10;    s: S;&#10;    b: B;&#10;}' >Abs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) S' >S</data-lsp></span><span style="color: #000000">, </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B' >B</data-lsp></span><span style="color: #000000">&gt;</span></div><div class='line'><span style="color: #000000">            ? (</span><span style="color: #267F99"><data-lsp lsp='type Subst&lt;X extends string, A extends Expr, E extends Expr> = E extends Var&lt;infer U> ? (X extends U ? A : NotFound) extends infer R ? R extends Expr ? R : E : never : E extends App&lt;infer E1, infer E2> ? Subst_&lt;...> extends infer E11 ? E11 extends Expr ? Subst_&lt;...> extends infer E21 ? E21 extends Expr ? App&lt;...> : never : never : never : never : E extends Abs&lt;...> ? S extends X ? E : S extends Free&lt;...> ? Free&lt;...> | Free&lt;...> extends infer FreeXB ? Freshen&lt;...> extends infer S1 ? S1 extends string ? Subst_&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : never : never : never : Subst_&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : never' >Subst</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) S' >S</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) A' >A</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B' >B</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B1' >B1</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B1' >B1</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='type BetaNF&lt;E extends Expr> = E extends App&lt;infer F, infer A> ? BetaNF&lt;F> extends infer F ? F extends Expr ? F extends Abs&lt;infer S, infer B> ? Subst_&lt;S, B, [[S, A]], Free&lt;A>> extends infer B1 ? B1 extends Expr ? BetaNF&lt;...> : never : never : BetaNF&lt;...> extends infer A1 ? A1 extends Expr ? App&lt;...> : never : never : never : never : E extends Abs&lt;...> ? BetaNF&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : E' >BetaNF</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) B1' >B1</data-lsp></span><span style="color: #000000">&gt; : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000">)</span></div><div class='line'><span style="color: #000000">            : </span><span style="color: #267F99"><data-lsp lsp='type BetaNF&lt;E extends Expr> = E extends App&lt;infer F, infer A> ? BetaNF&lt;F> extends infer F ? F extends Expr ? F extends Abs&lt;infer S, infer B> ? Subst_&lt;S, B, [[S, A]], Free&lt;A>> extends infer B1 ? B1 extends Expr ? BetaNF&lt;...> : never : never : BetaNF&lt;...> extends infer A1 ? A1 extends Expr ? App&lt;...> : never : never : never : never : E extends Abs&lt;...> ? BetaNF&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : E' >BetaNF</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) A' >A</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) A1' >A1</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) A1' >A1</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='type App&lt;E1 extends Expr, E2 extends Expr> = {&#10;    e1: E1;&#10;    e2: E2;&#10;}' >App</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) F' >F</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) A1' >A1</data-lsp></span><span style="color: #000000">&gt; : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000">) : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000">)</span></div><div class='line'><span style="color: #000000">    : </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E in type BetaNF&lt;E extends Expr>' >E</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Abs&lt;S extends string, B extends Expr> = {&#10;    s: S;&#10;    b: B;&#10;}' >Abs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) S' >S</data-lsp></span><span style="color: #000000">, </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B' >B</data-lsp></span><span style="color: #000000">&gt; ?</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #267F99"><data-lsp lsp='type BetaNF&lt;E extends Expr> = E extends App&lt;infer F, infer A> ? BetaNF&lt;F> extends infer F ? F extends Expr ? F extends Abs&lt;infer S, infer B> ? Subst_&lt;S, B, [[S, A]], Free&lt;A>> extends infer B1 ? B1 extends Expr ? BetaNF&lt;...> : never : never : BetaNF&lt;...> extends infer A1 ? A1 extends Expr ? App&lt;...> : never : never : never : never : E extends Abs&lt;...> ? BetaNF&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : E' >BetaNF</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) B' >B</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B1' >B1</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B1' >B1</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='type Abs&lt;S extends string, B extends Expr> = {&#10;    s: S;&#10;    b: B;&#10;}' >Abs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) S' >S</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B1' >B1</data-lsp></span><span style="color: #000000">&gt; : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span></div><div class='line'><span style="color: #000000">    : </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E in type BetaNF&lt;E extends Expr>' >E</data-lsp></span><span style="color: #000000">;</span></div></code></div></pre>
<p>As always, we write some tests to check our implementation:</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type BetaNFTest&lt;E extends Expr> = BetaNF&lt;E> extends infer PE ? PE extends Expr ? StringOfExpr&lt;PE> extends infer R ? R extends string ? StringOfExpr&lt;E> extends infer E ? E extends string ? `${E} => ${R}` : never : never : never : never : never : never' >BetaNFTest</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E in type BetaNFTest&lt;E extends Expr>' >E</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000">&gt; =</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99"><data-lsp lsp='type BetaNF&lt;E extends Expr> = E extends App&lt;infer F, infer A> ? BetaNF&lt;F> extends infer F ? F extends Expr ? F extends Abs&lt;infer S, infer B> ? Subst_&lt;S, B, [[S, A]], Free&lt;A>> extends infer B1 ? B1 extends Expr ? BetaNF&lt;...> : never : never : BetaNF&lt;...> extends infer A1 ? A1 extends Expr ? App&lt;...> : never : never : never : never : E extends Abs&lt;...> ? BetaNF&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : E' >BetaNF</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E in type BetaNFTest&lt;E extends Expr>' >E</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) PE' >PE</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) PE' >PE</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000"> ?  </span><span style="color: #267F99"><data-lsp lsp='type StringOfExpr&lt;T extends Expr> = T extends Var&lt;string> ? `${T["x"]}` : T extends Abs&lt;string, any> ? StringOfExpr&lt;T["b"]> extends infer B ? B extends string ? `(\u03BB${T["s"]}. ${B})` : never : never : T extends App&lt;...> ? StringOfExpr&lt;...> extends infer E1 ? E1 extends string ? StringOfExpr&lt;...> extends infer E2 ? E2 extends string ? `(${E1} ${E2})` : never : never : never : never : never' >StringOfExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) PE' >PE</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) R' >R</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) R' >R</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">string</span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99"><data-lsp lsp='type StringOfExpr&lt;T extends Expr> = T extends Var&lt;string> ? `${T["x"]}` : T extends Abs&lt;string, any> ? StringOfExpr&lt;T["b"]> extends infer B ? B extends string ? `(\u03BB${T["s"]}. ${B})` : never : never : T extends App&lt;...> ? StringOfExpr&lt;...> extends infer E1 ? E1 extends string ? StringOfExpr&lt;...> extends infer E2 ? E2 extends string ? `(${E1} ${E2})` : never : never : never : never : never' >StringOfExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E in type BetaNFTest&lt;E extends Expr>' >E</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E' >E</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E' >E</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">string</span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #A31515">`</span><span style="color: #0000FF">${</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E' >E</data-lsp></span><span style="color: #0000FF">}</span><span style="color: #A31515"> =&gt; </span><span style="color: #0000FF">${</span><span style="color: #267F99"><data-lsp lsp='(type parameter) R' >R</data-lsp></span><span style="color: #0000FF">}</span><span style="color: #A31515">`</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const nf_test1: "(x y) => (x y)"' >nf_test1</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type BetaNFTest&lt;E extends Expr> = BetaNF&lt;E> extends infer PE ? PE extends Expr ? StringOfExpr&lt;PE> extends infer R ? R extends string ? StringOfExpr&lt;E> extends infer E ? E extends string ? `${E} => ${R}` : never : never : never : never : never : never' >BetaNFTest</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type ParseExpr&lt;T> = ParseAbs&lt;T> extends never ? ParseApp&lt;T> extends never ? ParseVar&lt;T> extends never ? never : ParseVar&lt;T> : ParseApp&lt;T> : ParseAbs&lt;...>' >ParseExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"(x y)"</span><span style="color: #000000">&gt;&gt;</span></div><div class='line'><span style="color: #000000">    = </span><span style="color: #A31515">"(x y) =&gt; (x y)"</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const nf_test2: "(x ((λy. y) z)) => (x z)"' >nf_test2</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type BetaNFTest&lt;E extends Expr> = BetaNF&lt;E> extends infer PE ? PE extends Expr ? StringOfExpr&lt;PE> extends infer R ? R extends string ? StringOfExpr&lt;E> extends infer E ? E extends string ? `${E} => ${R}` : never : never : never : never : never : never' >BetaNFTest</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type App&lt;E1 extends Expr, E2 extends Expr> = {&#10;    e1: E1;&#10;    e2: E2;&#10;}' >App</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type Var&lt;X extends string> = {&#10;    x: X;&#10;}' >Var</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"x"</span><span style="color: #000000">&gt;, </span><span style="color: #267F99"><data-lsp lsp='type App&lt;E1 extends Expr, E2 extends Expr> = {&#10;    e1: E1;&#10;    e2: E2;&#10;}' >App</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type Abs&lt;S extends string, B extends Expr> = {&#10;    s: S;&#10;    b: B;&#10;}' >Abs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"y"</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='type Var&lt;X extends string> = {&#10;    x: X;&#10;}' >Var</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"y"</span><span style="color: #000000">&gt;&gt;, </span><span style="color: #267F99"><data-lsp lsp='type Var&lt;X extends string> = {&#10;    x: X;&#10;}' >Var</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"z"</span><span style="color: #000000">&gt;&gt;&gt;&gt;</span></div><div class='line'><span style="color: #000000">    = </span><span style="color: #A31515">"(x ((λy. y) z)) =&gt; (x z)"</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const nf_test3: "(λx. ((λy. y) z)) => (λx. z)"' >nf_test3</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type BetaNFTest&lt;E extends Expr> = BetaNF&lt;E> extends infer PE ? PE extends Expr ? StringOfExpr&lt;PE> extends infer R ? R extends string ? StringOfExpr&lt;E> extends infer E ? E extends string ? `${E} => ${R}` : never : never : never : never : never : never' >BetaNFTest</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type Abs&lt;S extends string, B extends Expr> = {&#10;    s: S;&#10;    b: B;&#10;}' >Abs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"x"</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='type App&lt;E1 extends Expr, E2 extends Expr> = {&#10;    e1: E1;&#10;    e2: E2;&#10;}' >App</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type Abs&lt;S extends string, B extends Expr> = {&#10;    s: S;&#10;    b: B;&#10;}' >Abs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"y"</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='type Var&lt;X extends string> = {&#10;    x: X;&#10;}' >Var</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"y"</span><span style="color: #000000">&gt;&gt;, </span><span style="color: #267F99"><data-lsp lsp='type Var&lt;X extends string> = {&#10;    x: X;&#10;}' >Var</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"z"</span><span style="color: #000000">&gt;&gt;&gt;&gt;</span></div><div class='line'><span style="color: #000000">    = </span><span style="color: #A31515">"(λx. ((λy. y) z)) =&gt; (λx. z)"</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const nf_test4: "((λx. z) ((λw. ((w w) w)) (λw. ((w w) w)))) => z"' >nf_test4</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type BetaNFTest&lt;E extends Expr> = BetaNF&lt;E> extends infer PE ? PE extends Expr ? StringOfExpr&lt;PE> extends infer R ? R extends string ? StringOfExpr&lt;E> extends infer E ? E extends string ? `${E} => ${R}` : never : never : never : never : never : never' >BetaNFTest</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type App&lt;E1 extends Expr, E2 extends Expr> = {&#10;    e1: E1;&#10;    e2: E2;&#10;}' >App</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type Abs&lt;S extends string, B extends Expr> = {&#10;    s: S;&#10;    b: B;&#10;}' >Abs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"x"</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='type Var&lt;X extends string> = {&#10;    x: X;&#10;}' >Var</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"z"</span><span style="color: #000000">&gt;&gt;, </span><span style="color: #267F99"><data-lsp lsp='type App&lt;E1 extends Expr, E2 extends Expr> = {&#10;    e1: E1;&#10;    e2: E2;&#10;}' >App</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type Abs&lt;S extends string, B extends Expr> = {&#10;    s: S;&#10;    b: B;&#10;}' >Abs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"w"</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='type App&lt;E1 extends Expr, E2 extends Expr> = {&#10;    e1: E1;&#10;    e2: E2;&#10;}' >App</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type App&lt;E1 extends Expr, E2 extends Expr> = {&#10;    e1: E1;&#10;    e2: E2;&#10;}' >App</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type Var&lt;X extends string> = {&#10;    x: X;&#10;}' >Var</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"w"</span><span style="color: #000000">&gt;, </span><span style="color: #267F99"><data-lsp lsp='type Var&lt;X extends string> = {&#10;    x: X;&#10;}' >Var</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"w"</span><span style="color: #000000">&gt;&gt;, </span><span style="color: #267F99"><data-lsp lsp='type Var&lt;X extends string> = {&#10;    x: X;&#10;}' >Var</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"w"</span><span style="color: #000000">&gt;&gt;&gt;,</span></div><div class='line'><span style="color: #000000">                                                   </span><span style="color: #267F99"><data-lsp lsp='type Abs&lt;S extends string, B extends Expr> = {&#10;    s: S;&#10;    b: B;&#10;}' >Abs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"w"</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='type App&lt;E1 extends Expr, E2 extends Expr> = {&#10;    e1: E1;&#10;    e2: E2;&#10;}' >App</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type App&lt;E1 extends Expr, E2 extends Expr> = {&#10;    e1: E1;&#10;    e2: E2;&#10;}' >App</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type Var&lt;X extends string> = {&#10;    x: X;&#10;}' >Var</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"w"</span><span style="color: #000000">&gt;, </span><span style="color: #267F99"><data-lsp lsp='type Var&lt;X extends string> = {&#10;    x: X;&#10;}' >Var</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"w"</span><span style="color: #000000">&gt;&gt;, </span><span style="color: #267F99"><data-lsp lsp='type Var&lt;X extends string> = {&#10;    x: X;&#10;}' >Var</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"w"</span><span style="color: #000000">&gt;&gt;&gt;&gt;&gt;&gt;</span></div><div class='line'><span style="color: #000000">    = </span><span style="color: #A31515">"((λx. z) ((λw. ((w w) w)) (λw. ((w w) w)))) =&gt; z"</span><span style="color: #000000">;</span></div></code></div></pre>
<p>That's it! We now have a type-level evaluator for the lambda calculus to
$\beta$ normal form. This is enough to show that TypeScript's type system is
Turing-complete.</p>
<h2 id="extension%3A-program-equivalence" tabindex="-1"><a class="header-anchor" href="#extension%3A-program-equivalence" aria-hidden="true"></a>Extension: Program Equivalence</h2>
<p>One way of viewing an evaluator to $\beta$ normal form is as a checker of
equivalence between expressions, up to $\beta$-reduction.
In general, evaluators of programs in any language never introduce anything &quot;new&quot;;
they simply yield equivalent, (hopefully) simpler forms of their inputs under
some set of evaluation rules.</p>
<p>This is one reason
normal forms need to be described formally and evaluation strategies need to be
chosen carefully. After all, $((\lam x. z)\ ((\lam w. (w\ w)\ w)\ (\lam w. (w\ w)\ w)))$
and $((\lam y. z) a)$ reduce to the same $\beta$ normal form if we use a normal
order evaluation strategy, but are certainly not equivalent if we apply
$\beta$-reductions in argument position first!</p>
<p>As a more familiar example, the TypeScript functions</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">function</span><span style="color: #000000"> </span><span style="color: #795E26"><data-lsp lsp='function strip_impl1(what: string): (from: string) => string' >strip_impl1</data-lsp></span><span style="color: #000000">(</span><span style="color: #001080"><data-lsp lsp='(parameter) what: string' >what</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99">string</span><span style="color: #000000">) {</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #AF00DB">return</span><span style="color: #000000"> </span><span style="color: #0000FF">function</span><span style="color: #000000">(</span><span style="color: #001080"><data-lsp lsp='(parameter) from: string' >from</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99">string</span><span style="color: #000000">) {</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #AF00DB">return</span><span style="color: #000000"> </span><span style="color: #001080"><data-lsp lsp='(parameter) from: string' >from</data-lsp></span><span style="color: #000000">.</span><span style="color: #795E26"><data-lsp lsp='Split a string into substrings using the specified separator and return them as an array.&#10;&#10;(method) String.split(separator: string | RegExp, limit?: number | undefined): string[] (+1 overload)' >split</data-lsp></span><span style="color: #000000">(</span><span style="color: #001080"><data-lsp lsp='(parameter) what: string' >what</data-lsp></span><span style="color: #000000">).</span><span style="color: #795E26"><data-lsp lsp='Adds all the elements of an array into a string, separated by the specified separator string.&#10;&#10;(method) Array&lt;string>.join(separator?: string | undefined): string' >join</data-lsp></span><span style="color: #000000">(</span><span style="color: #A31515">&apos;&apos;</span><span style="color: #000000">);</span></div><div class='line'><span style="color: #000000">  }</span></div><div class='line'><span style="color: #000000">}</span></div><div class='line'>&nbsp;</div><div class='line'><span style="color: #0000FF">function</span><span style="color: #000000"> </span><span style="color: #795E26"><data-lsp lsp='function strip_impl2(what: string): (target: string) => string' >strip_impl2</data-lsp></span><span style="color: #000000">(</span><span style="color: #001080"><data-lsp lsp='(parameter) what: string' >what</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99">string</span><span style="color: #000000">) {</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #AF00DB">return</span><span style="color: #000000"> </span><span style="color: #0000FF">function</span><span style="color: #000000">(</span><span style="color: #001080"><data-lsp lsp='(parameter) target: string' >target</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99">string</span><span style="color: #000000">) {</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #AF00DB">while</span><span style="color: #000000"> (</span><span style="color: #001080"><data-lsp lsp='(parameter) target: string' >target</data-lsp></span><span style="color: #000000">.</span><span style="color: #795E26"><data-lsp lsp='Returns the position of the first occurrence of a substring.&#10;&#10;(method) String.indexOf(searchString: string, position?: number | undefined): number' >indexOf</data-lsp></span><span style="color: #000000">(</span><span style="color: #001080"><data-lsp lsp='(parameter) what: string' >what</data-lsp></span><span style="color: #000000">) &gt;= </span><span style="color: #098658">0</span><span style="color: #000000">) {</span></div><div class='line'><span style="color: #000000">      </span><span style="color: #001080"><data-lsp lsp='(parameter) target: string' >target</data-lsp></span><span style="color: #000000"> = </span><span style="color: #001080"><data-lsp lsp='(parameter) target: string' >target</data-lsp></span><span style="color: #000000">.</span><span style="color: #795E26"><data-lsp lsp='Replaces text in a string, using a regular expression or search string.&#10;&#10;(method) String.replace(searchValue: string | RegExp, replaceValue: string): string (+3 overloads)' >replace</data-lsp></span><span style="color: #000000">(</span><span style="color: #001080"><data-lsp lsp='(parameter) what: string' >what</data-lsp></span><span style="color: #000000">, </span><span style="color: #A31515">&apos;&apos;</span><span style="color: #000000">);</span></div><div class='line'><span style="color: #000000">    }</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #AF00DB">return</span><span style="color: #000000"> </span><span style="color: #001080"><data-lsp lsp='(parameter) target: string' >target</data-lsp></span><span style="color: #000000">;</span></div><div class='line'><span style="color: #000000">  }</span></div><div class='line'><span style="color: #000000">}</span></div></code></div></pre>
<p>are equivalent for all string inputs <code>what</code>, up to $\alpha$-conversion of their
returned closure parameters and reduction of the expressions in the closure bodies. But if
we don't reduce the closure bodies, it is very hard to prove that they produce
the same output for all inputs without enumerating and reducing all string inputs, an impossible task.</p>
<p>It is for this reason we chose to evaluate to $\beta$-normal form, which looks inside abstraction bodies and
unapplied arguments. Furthermore, our normal order evaluation strategy for the lambda calculus yields
a normal form whenever one exists, so two expressions are always comparable
whenever there is some route for their termination.</p>
<p>Can we be confident that two lambda
calculus expressions are equivalent when their $\beta$-normal forms are
equal? Only if by equality we mean equivalence up to $\alpha$-conversion!
After all, we don't want to say
two programs are semantically different just because we changed a variable name.
Since we already have a $\beta$-normal form evaluator, we just need to complete
an algorithm for calculating $\alpha$-equivalence, as promised earlier.</p>
<h3 id="%24%5Calpha%24-equivalence" tabindex="-1"><a class="header-anchor" href="#%24%5Calpha%24-equivalence" aria-hidden="true"></a>$\alpha$-equivalence</h3>
<p>Since $\alpha$-equivalence measures syntactic equality of two terms up to the
renaming of bound variables, we only have to concern ourselves with some way of
normalizing bound variables at abstraction sites. The typical approach, which we
will employ, is to recurse on the structure of expressions being compared in
parallel. If the structures differ (for example a variable vs an application),
the expressions cannot possibly be $\alpha$-equivalent. Otherwise, there are
three remaining cases of parallel forms.</p>
<p>For applications, we simply check $\alpha$-equivalence of corresponding subexpressions.</p>
<p>For abstractions, we normalize introduced bound variables in each expression by
creating a fresh id and mapping each bound variable to that id in a context
carried alongside each respective expression. The fresh id we create can be of
any form; in our implementation, we use type-level integers.</p>
<p>When comparing two variables, we check if both have mappings to some id in their
respective contexts. If they do, and the mapped ids are equal, then the
variables are equivalent up to $\alpha$-conversion of some enclosing
abstraction. If neither variable has a mapping in its respective context, then
both variables are free in all enclosing abstractions; for them to be
$\alpha$-equivalent, they must have the same name. Otherwise, one variable is
free and the other is bound in some enclosing abstraction, so they cannot be
$\alpha$-equivalent.</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0> = E1 extends Var&lt;infer X1> ? E2 extends Var&lt;infer X2> ? Find&lt;number, X1, L1> extends number ? Find&lt;number, X2, L2> extends number ? Find&lt;number, X1, L1> extends Find&lt;...> ? true : false : false : Find&lt;...> extends number ? false : X1 extends X2 ? true : false : false : E1 extends App&lt;...> ? E2 extends App&lt;...> ? AlphaEq&lt;...> extends true ? AlphaEq&lt;...> extends true ? true : false : false : false : E1 extends Abs&lt;...> ? E2 extends Abs&lt;...> ? TupToNum&lt;...> extends infer Fr1 ? Fr1 extends number ? AlphaEq&lt;...> : never : never : false : never' >AlphaEq</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1 in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >E1</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2 in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >E2</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000">,</span></div><div class='line'><span style="color: #000000">            </span><span style="color: #267F99"><data-lsp lsp='(type parameter) L1 in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >L1</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Ctx&lt;T> = [string, T][]' >Ctx</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99">number</span><span style="color: #000000">&gt; = [], </span><span style="color: #267F99"><data-lsp lsp='(type parameter) L2 in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >L2</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Ctx&lt;T> = [string, T][]' >Ctx</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99">number</span><span style="color: #000000">&gt; = [], </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Fr in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >Fr</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">number</span><span style="color: #000000"> = </span><span style="color: #098658">0</span><span style="color: #000000">&gt;</span></div><div class='line'><span style="color: #000000">    = </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1 in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >E1</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Var&lt;X extends string> = {&#10;    x: X;&#10;}' >Var</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) X1' >X1</data-lsp></span><span style="color: #000000">&gt; ? (</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2 in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >E2</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Var&lt;X extends string> = {&#10;    x: X;&#10;}' >Var</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) X2' >X2</data-lsp></span><span style="color: #000000">&gt;</span></div><div class='line'><span style="color: #000000">        ? (</span><span style="color: #267F99"><data-lsp lsp='type Find&lt;T, X extends string, L extends Ctx&lt;T>> = L extends [[infer Y, infer N], ...infer B] ? Y extends X ? N : B extends Ctx&lt;T> ? Find&lt;T, X, B> : never : NotFound' >Find</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99">number</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) X1' >X1</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) L1 in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >L1</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">number</span></div><div class='line'><span style="color: #000000">            ? (</span><span style="color: #267F99"><data-lsp lsp='type Find&lt;T, X extends string, L extends Ctx&lt;T>> = L extends [[infer Y, infer N], ...infer B] ? Y extends X ? N : B extends Ctx&lt;T> ? Find&lt;T, X, B> : never : NotFound' >Find</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99">number</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) X2' >X2</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) L2 in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >L2</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">number</span></div><div class='line'><span style="color: #000000">                ? </span><span style="color: #267F99"><data-lsp lsp='type Find&lt;T, X extends string, L extends Ctx&lt;T>> = L extends [[infer Y, infer N], ...infer B] ? Y extends X ? N : B extends Ctx&lt;T> ? Find&lt;T, X, B> : never : NotFound' >Find</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99">number</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) X1' >X1</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) L1 in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >L1</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Find&lt;T, X extends string, L extends Ctx&lt;T>> = L extends [[infer Y, infer N], ...infer B] ? Y extends X ? N : B extends Ctx&lt;T> ? Find&lt;T, X, B> : never : NotFound' >Find</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99">number</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) X2' >X2</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) L2 in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >L2</data-lsp></span><span style="color: #000000">&gt; ? </span><span style="color: #267F99">true</span><span style="color: #000000"> : </span><span style="color: #267F99">false</span></div><div class='line'><span style="color: #000000">                : </span><span style="color: #267F99">false</span><span style="color: #000000">)</span></div><div class='line'><span style="color: #000000">            : (</span><span style="color: #267F99"><data-lsp lsp='type Find&lt;T, X extends string, L extends Ctx&lt;T>> = L extends [[infer Y, infer N], ...infer B] ? Y extends X ? N : B extends Ctx&lt;T> ? Find&lt;T, X, B> : never : NotFound' >Find</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99">number</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) X2' >X2</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) L2 in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >L2</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">number</span></div><div class='line'><span style="color: #000000">                ? </span><span style="color: #267F99">false</span></div><div class='line'><span style="color: #000000">                : </span><span style="color: #267F99"><data-lsp lsp='(type parameter) X1' >X1</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) X2' >X2</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99">true</span><span style="color: #000000"> : </span><span style="color: #267F99">false</span><span style="color: #000000">))</span></div><div class='line'><span style="color: #000000">        : </span><span style="color: #267F99">false</span><span style="color: #000000">)</span></div><div class='line'><span style="color: #000000">    : </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1 in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >E1</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type App&lt;E1 extends Expr, E2 extends Expr> = {&#10;    e1: E1;&#10;    e2: E2;&#10;}' >App</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E11' >E11</data-lsp></span><span style="color: #000000">, </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E12' >E12</data-lsp></span><span style="color: #000000">&gt; ? (</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2 in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >E2</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type App&lt;E1 extends Expr, E2 extends Expr> = {&#10;    e1: E1;&#10;    e2: E2;&#10;}' >App</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E21' >E21</data-lsp></span><span style="color: #000000">, </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E22' >E22</data-lsp></span><span style="color: #000000">&gt; ?</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #267F99"><data-lsp lsp='type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0> = E1 extends Var&lt;infer X1> ? E2 extends Var&lt;infer X2> ? Find&lt;number, X1, L1> extends number ? Find&lt;number, X2, L2> extends number ? Find&lt;number, X1, L1> extends Find&lt;...> ? true : false : false : Find&lt;...> extends number ? false : X1 extends X2 ? true : false : false : E1 extends App&lt;...> ? E2 extends App&lt;...> ? AlphaEq&lt;...> extends true ? AlphaEq&lt;...> extends true ? true : false : false : false : E1 extends Abs&lt;...> ? E2 extends Abs&lt;...> ? TupToNum&lt;...> extends infer Fr1 ? Fr1 extends number ? AlphaEq&lt;...> : never : never : false : never' >AlphaEq</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E11' >E11</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E21' >E21</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) L1 in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >L1</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) L2 in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >L2</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Fr in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >Fr</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">true</span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #267F99"><data-lsp lsp='type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0> = E1 extends Var&lt;infer X1> ? E2 extends Var&lt;infer X2> ? Find&lt;number, X1, L1> extends number ? Find&lt;number, X2, L2> extends number ? Find&lt;number, X1, L1> extends Find&lt;...> ? true : false : false : Find&lt;...> extends number ? false : X1 extends X2 ? true : false : false : E1 extends App&lt;...> ? E2 extends App&lt;...> ? AlphaEq&lt;...> extends true ? AlphaEq&lt;...> extends true ? true : false : false : false : E1 extends Abs&lt;...> ? E2 extends Abs&lt;...> ? TupToNum&lt;...> extends infer Fr1 ? Fr1 extends number ? AlphaEq&lt;...> : never : never : false : never' >AlphaEq</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E12' >E12</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E22' >E22</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) L1 in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >L1</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) L2 in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >L2</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Fr in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >Fr</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">true</span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #267F99">true</span><span style="color: #000000"> : </span><span style="color: #267F99">false</span><span style="color: #000000"> : </span><span style="color: #267F99">false</span><span style="color: #000000"> : </span><span style="color: #267F99">false</span><span style="color: #000000">)</span></div><div class='line'><span style="color: #000000">    : </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1 in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >E1</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Abs&lt;S extends string, B extends Expr> = {&#10;    s: S;&#10;    b: B;&#10;}' >Abs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) S1' >S1</data-lsp></span><span style="color: #000000">, </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B1' >B1</data-lsp></span><span style="color: #000000">&gt; ? (</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2 in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >E2</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Abs&lt;S extends string, B extends Expr> = {&#10;    s: S;&#10;    b: B;&#10;}' >Abs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) S2' >S2</data-lsp></span><span style="color: #000000">, </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B2' >B2</data-lsp></span><span style="color: #000000">&gt; ?</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #267F99"><data-lsp lsp='type Incr&lt;N extends number> = [...NumToTup&lt;N, []>, unknown] extends {&#10;    length: infer N;&#10;} ? N : never' >Incr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) Fr in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >Fr</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Fr1' >Fr1</data-lsp></span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Fr1' >Fr1</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">number</span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #267F99"><data-lsp lsp='type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0> = E1 extends Var&lt;infer X1> ? E2 extends Var&lt;infer X2> ? Find&lt;number, X1, L1> extends number ? Find&lt;number, X2, L2> extends number ? Find&lt;number, X1, L1> extends Find&lt;...> ? true : false : false : Find&lt;...> extends number ? false : X1 extends X2 ? true : false : false : E1 extends App&lt;...> ? E2 extends App&lt;...> ? AlphaEq&lt;...> extends true ? AlphaEq&lt;...> extends true ? true : false : false : false : E1 extends Abs&lt;...> ? E2 extends Abs&lt;...> ? TupToNum&lt;...> extends infer Fr1 ? Fr1 extends number ? AlphaEq&lt;...> : never : never : false : never' >AlphaEq</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) B1' >B1</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) B2' >B2</data-lsp></span><span style="color: #000000">, [[</span><span style="color: #267F99"><data-lsp lsp='(type parameter) S1' >S1</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Fr1' >Fr1</data-lsp></span><span style="color: #000000">], ...</span><span style="color: #267F99"><data-lsp lsp='(type parameter) L1 in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >L1</data-lsp></span><span style="color: #000000">], [[</span><span style="color: #267F99"><data-lsp lsp='(type parameter) S2' >S2</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Fr1' >Fr1</data-lsp></span><span style="color: #000000">], ...</span><span style="color: #267F99"><data-lsp lsp='(type parameter) L2 in type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0>' >L2</data-lsp></span><span style="color: #000000">], </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Fr1' >Fr1</data-lsp></span><span style="color: #000000">&gt; : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">false</span><span style="color: #000000">)</span></div><div class='line'><span style="color: #000000">    : </span><span style="color: #267F99">never</span></div></code></div></pre>
<p>Here are some tests:</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type AlphaEqTest&lt;E1 extends string, E2 extends string> = ParseExpr&lt;E1> extends Var&lt;infer X1> ? ParseExpr&lt;E2> extends Var&lt;infer X2> ? X1 extends X2 ? true : false : false : ParseExpr&lt;E1> extends App&lt;...> ? ParseExpr&lt;...> extends App&lt;...> ? AlphaEq&lt;...> extends true ? AlphaEq&lt;...> extends true ? true : false : false : false : ParseExpr&lt;...> extends Abs&lt;...> ? ParseExpr&lt;...> extends Abs&lt;...> ? AlphaEq&lt;...> : false : never' >AlphaEqTest</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1 in type AlphaEqTest&lt;E1 extends string, E2 extends string>' >E1</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">string</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2 in type AlphaEqTest&lt;E1 extends string, E2 extends string>' >E2</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">string</span><span style="color: #000000">&gt; = </span><span style="color: #267F99"><data-lsp lsp='type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0> = E1 extends Var&lt;infer X1> ? E2 extends Var&lt;infer X2> ? Find&lt;number, X1, L1> extends number ? Find&lt;number, X2, L2> extends number ? Find&lt;number, X1, L1> extends Find&lt;...> ? true : false : false : Find&lt;...> extends number ? false : X1 extends X2 ? true : false : false : E1 extends App&lt;...> ? E2 extends App&lt;...> ? AlphaEq&lt;...> extends true ? AlphaEq&lt;...> extends true ? true : false : false : false : E1 extends Abs&lt;...> ? E2 extends Abs&lt;...> ? TupToNum&lt;...> extends infer Fr1 ? Fr1 extends number ? AlphaEq&lt;...> : never : never : false : never' >AlphaEq</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type ParseExpr&lt;T> = ParseAbs&lt;T> extends never ? ParseApp&lt;T> extends never ? ParseVar&lt;T> extends never ? never : ParseVar&lt;T> : ParseApp&lt;T> : ParseAbs&lt;...>' >ParseExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1 in type AlphaEqTest&lt;E1 extends string, E2 extends string>' >E1</data-lsp></span><span style="color: #000000">&gt;, </span><span style="color: #267F99"><data-lsp lsp='type ParseExpr&lt;T> = ParseAbs&lt;T> extends never ? ParseApp&lt;T> extends never ? ParseVar&lt;T> extends never ? never : ParseVar&lt;T> : ParseApp&lt;T> : ParseAbs&lt;...>' >ParseExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2 in type AlphaEqTest&lt;E1 extends string, E2 extends string>' >E2</data-lsp></span><span style="color: #000000">&gt;&gt;;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const alpha_eq_test1: true' >alpha_eq_test1</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type AlphaEqTest&lt;E1 extends string, E2 extends string> = ParseExpr&lt;E1> extends Var&lt;infer X1> ? ParseExpr&lt;E2> extends Var&lt;infer X2> ? X1 extends X2 ? true : false : false : ParseExpr&lt;E1> extends App&lt;...> ? ParseExpr&lt;...> extends App&lt;...> ? AlphaEq&lt;...> extends true ? AlphaEq&lt;...> extends true ? true : false : false : false : ParseExpr&lt;...> extends Abs&lt;...> ? ParseExpr&lt;...> extends Abs&lt;...> ? AlphaEq&lt;...> : false : never' >AlphaEqTest</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"(λx. x)"</span><span style="color: #000000">, </span><span style="color: #A31515">"(λy. y)"</span><span style="color: #000000">&gt; = </span><span style="color: #0000FF">true</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const alpha_eq_test2: true' >alpha_eq_test2</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type AlphaEqTest&lt;E1 extends string, E2 extends string> = ParseExpr&lt;E1> extends Var&lt;infer X1> ? ParseExpr&lt;E2> extends Var&lt;infer X2> ? X1 extends X2 ? true : false : false : ParseExpr&lt;E1> extends App&lt;...> ? ParseExpr&lt;...> extends App&lt;...> ? AlphaEq&lt;...> extends true ? AlphaEq&lt;...> extends true ? true : false : false : false : ParseExpr&lt;...> extends Abs&lt;...> ? ParseExpr&lt;...> extends Abs&lt;...> ? AlphaEq&lt;...> : false : never' >AlphaEqTest</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"(λx. z)"</span><span style="color: #000000">, </span><span style="color: #A31515">"(λy. z)"</span><span style="color: #000000">&gt; = </span><span style="color: #0000FF">true</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const alpha_eq_test3: true' >alpha_eq_test3</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type AlphaEqTest&lt;E1 extends string, E2 extends string> = ParseExpr&lt;E1> extends Var&lt;infer X1> ? ParseExpr&lt;E2> extends Var&lt;infer X2> ? X1 extends X2 ? true : false : false : ParseExpr&lt;E1> extends App&lt;...> ? ParseExpr&lt;...> extends App&lt;...> ? AlphaEq&lt;...> extends true ? AlphaEq&lt;...> extends true ? true : false : false : false : ParseExpr&lt;...> extends Abs&lt;...> ? ParseExpr&lt;...> extends Abs&lt;...> ? AlphaEq&lt;...> : false : never' >AlphaEqTest</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"(λz. (λx. (z x)))"</span><span style="color: #000000">, </span><span style="color: #A31515">"(λx. (λw. (x w)))"</span><span style="color: #000000">&gt; = </span><span style="color: #0000FF">true</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const alpha_eq_test4: true' >alpha_eq_test4</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type AlphaEqTest&lt;E1 extends string, E2 extends string> = ParseExpr&lt;E1> extends Var&lt;infer X1> ? ParseExpr&lt;E2> extends Var&lt;infer X2> ? X1 extends X2 ? true : false : false : ParseExpr&lt;E1> extends App&lt;...> ? ParseExpr&lt;...> extends App&lt;...> ? AlphaEq&lt;...> extends true ? AlphaEq&lt;...> extends true ? true : false : false : false : ParseExpr&lt;...> extends Abs&lt;...> ? ParseExpr&lt;...> extends Abs&lt;...> ? AlphaEq&lt;...> : false : never' >AlphaEqTest</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"(y (λx. (λz. (z x))))"</span><span style="color: #000000">, </span><span style="color: #A31515">"(y (λx. (λw. (w x))))"</span><span style="color: #000000">&gt; = </span><span style="color: #0000FF">true</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const alpha_eq_test5: false' >alpha_eq_test5</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type AlphaEqTest&lt;E1 extends string, E2 extends string> = ParseExpr&lt;E1> extends Var&lt;infer X1> ? ParseExpr&lt;E2> extends Var&lt;infer X2> ? X1 extends X2 ? true : false : false : ParseExpr&lt;E1> extends App&lt;...> ? ParseExpr&lt;...> extends App&lt;...> ? AlphaEq&lt;...> extends true ? AlphaEq&lt;...> extends true ? true : false : false : false : ParseExpr&lt;...> extends Abs&lt;...> ? ParseExpr&lt;...> extends Abs&lt;...> ? AlphaEq&lt;...> : false : never' >AlphaEqTest</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"(u (λx. (λz. (z x))))"</span><span style="color: #000000">, </span><span style="color: #A31515">"(y (λx. (λw. (w x))))"</span><span style="color: #000000">&gt; = </span><span style="color: #0000FF">false</span><span style="color: #000000">;</span></div></code></div></pre>
<h3 id="type-level-numbers" tabindex="-1"><a class="header-anchor" href="#type-level-numbers" aria-hidden="true"></a>Type-level numbers</h3>
<p>Our implementation of type-level numbers is backed by tuples for arithmetic. To
perform addition, we deserialize a number type <code>n</code> to an <code>n</code>-length tuple type,
add <code>m</code> entries to the tuple type, and serialize it back to an <code>n+m</code> number
type.</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type TupToNum&lt;T extends unknown[]> = T extends {&#10;    length: infer N;&#10;} ? N : never' >TupToNum</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type TupToNum&lt;T extends unknown[]>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">unknown</span><span style="color: #000000">[]&gt; = </span><span style="color: #267F99"><data-lsp lsp='(type parameter) T in type TupToNum&lt;T extends unknown[]>' >T</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> {</span><span style="color: #001080"><data-lsp lsp='(property) length: N' >length</data-lsp></span><span style="color: #000000">: </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) N' >N</data-lsp></span><span style="color: #000000">} ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) N' >N</data-lsp></span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type NumToTup&lt;N extends number, Tup extends unknown[] = []> = Tup extends {&#10;    length: N;&#10;} ? Tup : NumToTup&lt;N, [...Tup, unknown]>' >NumToTup</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) N in type NumToTup&lt;N extends number, Tup extends unknown[] = []>' >N</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">number</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Tup in type NumToTup&lt;N extends number, Tup extends unknown[] = []>' >Tup</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">unknown</span><span style="color: #000000">[] = []&gt; =</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Tup in type NumToTup&lt;N extends number, Tup extends unknown[] = []>' >Tup</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> {</span><span style="color: #001080"><data-lsp lsp='(property) length: N extends number' >length</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='(type parameter) N in type NumToTup&lt;N extends number, Tup extends unknown[] = []>' >N</data-lsp></span><span style="color: #000000">} ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) Tup in type NumToTup&lt;N extends number, Tup extends unknown[] = []>' >Tup</data-lsp></span><span style="color: #000000"> : </span><span style="color: #267F99"><data-lsp lsp='type NumToTup&lt;N extends number, Tup extends unknown[] = []> = Tup extends {&#10;    length: N;&#10;} ? Tup : NumToTup&lt;N, [...Tup, unknown]>' >NumToTup</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) N in type NumToTup&lt;N extends number, Tup extends unknown[] = []>' >N</data-lsp></span><span style="color: #000000">, [...</span><span style="color: #267F99"><data-lsp lsp='(type parameter) Tup in type NumToTup&lt;N extends number, Tup extends unknown[] = []>' >Tup</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99">unknown</span><span style="color: #000000">]&gt;;</span></div><div class='line'>&nbsp;</div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Incr&lt;N extends number> = [...NumToTup&lt;N, []>, unknown] extends {&#10;    length: infer N;&#10;} ? N : never' >Incr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) N in type Incr&lt;N extends number>' >N</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">number</span><span style="color: #000000">&gt; = </span><span style="color: #267F99"><data-lsp lsp='type TupToNum&lt;T extends unknown[]> = T extends {&#10;    length: infer N;&#10;} ? N : never' >TupToNum</data-lsp></span><span style="color: #000000">&lt;[...</span><span style="color: #267F99"><data-lsp lsp='type NumToTup&lt;N extends number, Tup extends unknown[] = []> = Tup extends {&#10;    length: N;&#10;} ? Tup : NumToTup&lt;N, [...Tup, unknown]>' >NumToTup</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) N in type Incr&lt;N extends number>' >N</data-lsp></span><span style="color: #000000">&gt;, </span><span style="color: #267F99">unknown</span><span style="color: #000000">]&gt;;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const incr_test: 12' >incr_test</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type Incr&lt;N extends number> = [...NumToTup&lt;N, []>, unknown] extends {&#10;    length: infer N;&#10;} ? N : never' >Incr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #098658">11</span><span style="color: #000000">&gt; = </span><span style="color: #098658">12</span><span style="color: #000000">;</span></div></code></div></pre>
<h3 id="%24%5Calpha%5Cbeta%24-equivalence" tabindex="-1"><a class="header-anchor" href="#%24%5Calpha%5Cbeta%24-equivalence" aria-hidden="true"></a>$\alpha\beta$-equivalence</h3>
<p>With implementations of evaluation to $\beta$ normal form and
$\alpha$-equivalence in place, checking for program equivalence under
$\beta$-reduction and $\alpha$-conversion is trivial. Since $\alpha$-conversion
cannot introduce new $\beta$-redexes, comparing two expressions consists of
normalization followed by a check for $\alpha$-equivalence.</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type ABEq&lt;E1 extends Expr, E2 extends Expr> = BetaNF&lt;E1> extends infer E1 ? E1 extends Expr ? BetaNF&lt;E2> extends infer E2 ? E2 extends Expr ? AlphaEq&lt;E1, E2, [], [], 0> : never : never : never : never' >ABEq</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1 in type ABEq&lt;E1 extends Expr, E2 extends Expr>' >E1</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2 in type ABEq&lt;E1 extends Expr, E2 extends Expr>' >E2</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000">&gt; =</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99"><data-lsp lsp='type BetaNF&lt;E extends Expr> = E extends App&lt;infer F, infer A> ? BetaNF&lt;F> extends infer F ? F extends Expr ? F extends Abs&lt;infer S, infer B> ? Subst_&lt;S, B, [[S, A]], Free&lt;A>> extends infer B1 ? B1 extends Expr ? BetaNF&lt;...> : never : never : BetaNF&lt;...> extends infer A1 ? A1 extends Expr ? App&lt;...> : never : never : never : never : E extends Abs&lt;...> ? BetaNF&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : E' >BetaNF</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1 in type ABEq&lt;E1 extends Expr, E2 extends Expr>' >E1</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1' >E1</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1' >E1</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99"><data-lsp lsp='type BetaNF&lt;E extends Expr> = E extends App&lt;infer F, infer A> ? BetaNF&lt;F> extends infer F ? F extends Expr ? F extends Abs&lt;infer S, infer B> ? Subst_&lt;S, B, [[S, A]], Free&lt;A>> extends infer B1 ? B1 extends Expr ? BetaNF&lt;...> : never : never : BetaNF&lt;...> extends infer A1 ? A1 extends Expr ? App&lt;...> : never : never : never : never : E extends Abs&lt;...> ? BetaNF&lt;...> extends infer B1 ? B1 extends Expr ? Abs&lt;...> : never : never : E' >BetaNF</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2 in type ABEq&lt;E1 extends Expr, E2 extends Expr>' >E2</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2' >E2</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2' >E2</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99"><data-lsp lsp='type AlphaEq&lt;E1 extends Expr, E2 extends Expr, L1 extends Ctx&lt;number> = [], L2 extends Ctx&lt;number> = [], Fr extends number = 0> = E1 extends Var&lt;infer X1> ? E2 extends Var&lt;infer X2> ? Find&lt;number, X1, L1> extends number ? Find&lt;number, X2, L2> extends number ? Find&lt;number, X1, L1> extends Find&lt;...> ? true : false : false : Find&lt;...> extends number ? false : X1 extends X2 ? true : false : false : E1 extends App&lt;...> ? E2 extends App&lt;...> ? AlphaEq&lt;...> extends true ? AlphaEq&lt;...> extends true ? true : false : false : false : E1 extends Abs&lt;...> ? E2 extends Abs&lt;...> ? TupToNum&lt;...> extends infer Fr1 ? Fr1 extends number ? AlphaEq&lt;...> : never : never : false : never' >AlphaEq</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1' >E1</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2' >E2</data-lsp></span><span style="color: #000000">&gt; : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000">;</span></div></code></div></pre>
<h3 id="proving-arithmetic-equivalences" tabindex="-1"><a class="header-anchor" href="#proving-arithmetic-equivalences" aria-hidden="true"></a>Proving arithmetic equivalences</h3>
<p>As a comprehensive application of all we've built up, let's show off what all
introductions to the lambda calculus show off - simple arithmetic.</p>
<p>There's no syntax for the natural numbers in the lambda calculus language we've
worked on, but there is a classic encoding of the naturals known as the Church numerals.
<a href="https://en.wikipedia.org/wiki/Church_encoding">Wikipedia</a> gives a very good
overview of the encoding and its presentation of various arithmetic operations.</p>
<p>In short, the idea is to encode the Peano axioms for natural numbers as
abstractions. The Peano axioms define a symbol
$0$ and a 1-parameter function $\S$ called the successor. We
take as axioms that $0$ is a natural number, and that if $n$ is a natural number,
$\S(n)$ is a natural number<span class="note"><label for="peano-axioms" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="peano-axioms" class="margin-toggle" /><span class="sidenote">There are many other
axioms, but they are not relevant here.</span>. We can interpret $\S(0)$ as $1$,
$\S(\S(\S(0)))$ as 3, and so on.</p>
<p>The church encoding represents the $n$th natural number as a second-order abstraction
that takes a &quot;successor function&quot; and a &quot;zero element&quot; and yields an $n$-ary
composition of the successor applied to the zero element, as in the Peano
axioms. Taking $s$ to bind the &quot;successor function&quot; and $z$ to bind the &quot;zero
element&quot;, we can represent the first few natural numbers as follows.</p>
<div class="mathblock"><script type="math/tex; mode=display">
\begin{align*}
0&\sim(\lam s. (\lam z. z))\\
1&\sim(\lam s. (\lam z. (s\ z)))\\
2&\sim(\lam s. (\lam z. (s\ (s\ z))))\\
\ldots&\phantom{ {}\sim{} }\ldots
\end{align*}
</script></div>
<p>It's important to note that, for example, $2$ is represented by the
<em>abstraction</em> $(\lam s. (\lam z. (s\ (s\ z))))$, not by its application to some
yet-unknown successor and zero arguments. Said another way, the $s$ and $z$
arguments here are only in name, axiomatized into existence.</p>
<p>However, applications to these numerals do come into play when we
want to perform arithmetic operations, like addition. Take the church encoding
of $m + n$, which is</p>
<div class="mathblock"><script type="math/tex; mode=display">
(\lam s. (\lam z. (\underbrace{s\ (\ldots\ (s}_{m}\ (\underbrace{s\ (\ldots (s}_{n}\ z))))))))
</script></div>
<p>If we apply a &quot;reverse $\beta$-reduction&quot;, known as a <strong>$\beta$-abstraction</strong>,
we can rewrite the above expression to the equivalent form</p>
<div class="mathblock"><script type="math/tex; mode=display">
(\lam s. (\lam z. \color{red}{(}\color{blue}(\lam n. (\underbrace{s\ (\ldots\ (s}_{m}\ (n))))\color{blue})\ \color{green}(\underbrace{s\ (\ldots (s}_{n}\ z))\color{green})\color{red}{)}))
</script></div>
<p>Now, we parameterize this expression on church numerals $m$ and $n$, where
$m\sim(\lam s. (\lam z. (\underbrace{s\ (\ldots\ (s}_{m}\ (z))))))$. This yields
an equation for the addition of $m$ and $n$.</p>
<div class="mathblock"><script type="math/tex; mode=display">
(\lam m. (\lam n. (\lam s. (\lam z. \color{red}{(}\color{blue}(m\ s\color{blue})\ \color{green}((n\ s)\ z\color{green})\color{red}{)}))))
</script></div>
<p>Our evaluator can <em>prove</em> the equality of certain expressions under addition, if we take
$\alpha\beta$-equivalence as equality. Below we demonstrate this for the proposed equivalence $1 + 1 \overset{\mbox{$\alpha\beta$}}{\equiv} 2$.</p>
<pre class="shiki light-plus twoslash lsp" style="background-color: #FFFFFF; color: #000000"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type ABEqTest&lt;E1 extends Expr, E2 extends Expr> = StringOfExpr&lt;E1> extends infer SE1 ? SE1 extends string ? StringOfExpr&lt;E2> extends infer SE2 ? SE2 extends string ? ABEq&lt;E1, E2> extends true ? `${SE1} \u2261 ${SE2}` : `${SE1} \u2262 ${SE2}` : never : never : never : never' >ABEqTest</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1 in type ABEqTest&lt;E1 extends Expr, E2 extends Expr>' >E1</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2 in type ABEqTest&lt;E1 extends Expr, E2 extends Expr>' >E2</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Expr = Var&lt;string> | Abs&lt;string, any> | App&lt;any, any>' >Expr</data-lsp></span><span style="color: #000000">&gt; =</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99"><data-lsp lsp='type StringOfExpr&lt;T extends Expr> = T extends Var&lt;string> ? `${T["x"]}` : T extends Abs&lt;string, any> ? StringOfExpr&lt;T["b"]> extends infer B ? B extends string ? `(\u03BB${T["s"]}. ${B})` : never : never : T extends App&lt;...> ? StringOfExpr&lt;...> extends infer E1 ? E1 extends string ? StringOfExpr&lt;...> extends infer E2 ? E2 extends string ? `(${E1} ${E2})` : never : never : never : never : never' >StringOfExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1 in type ABEqTest&lt;E1 extends Expr, E2 extends Expr>' >E1</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) SE1' >SE1</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) SE1' >SE1</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">string</span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99"><data-lsp lsp='type StringOfExpr&lt;T extends Expr> = T extends Var&lt;string> ? `${T["x"]}` : T extends Abs&lt;string, any> ? StringOfExpr&lt;T["b"]> extends infer B ? B extends string ? `(\u03BB${T["s"]}. ${B})` : never : never : T extends App&lt;...> ? StringOfExpr&lt;...> extends infer E1 ? E1 extends string ? StringOfExpr&lt;...> extends infer E2 ? E2 extends string ? `(${E1} ${E2})` : never : never : never : never : never' >StringOfExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2 in type ABEqTest&lt;E1 extends Expr, E2 extends Expr>' >E2</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #0000FF">infer</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='(type parameter) SE2' >SE2</data-lsp></span><span style="color: #000000"> ? </span><span style="color: #267F99"><data-lsp lsp='(type parameter) SE2' >SE2</data-lsp></span><span style="color: #000000"> </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">string</span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #267F99"><data-lsp lsp='type ABEq&lt;E1 extends Expr, E2 extends Expr> = BetaNF&lt;E1> extends infer E1 ? E1 extends Expr ? BetaNF&lt;E2> extends infer E2 ? E2 extends Expr ? AlphaEq&lt;E1, E2, [], [], 0> : never : never : never : never' >ABEq</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='(type parameter) E1 in type ABEqTest&lt;E1 extends Expr, E2 extends Expr>' >E1</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='(type parameter) E2 in type ABEqTest&lt;E1 extends Expr, E2 extends Expr>' >E2</data-lsp></span><span style="color: #000000">&gt; </span><span style="color: #0000FF">extends</span><span style="color: #000000"> </span><span style="color: #267F99">true</span><span style="color: #000000"> ?</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #A31515">`</span><span style="color: #0000FF">${</span><span style="color: #267F99"><data-lsp lsp='(type parameter) SE1' >SE1</data-lsp></span><span style="color: #0000FF">}</span><span style="color: #A31515"> ≡ </span><span style="color: #0000FF">${</span><span style="color: #267F99"><data-lsp lsp='(type parameter) SE2' >SE2</data-lsp></span><span style="color: #0000FF">}</span><span style="color: #A31515">`</span><span style="color: #000000"> : </span><span style="color: #A31515">`</span><span style="color: #0000FF">${</span><span style="color: #267F99"><data-lsp lsp='(type parameter) SE1' >SE1</data-lsp></span><span style="color: #0000FF">}</span><span style="color: #A31515"> ≢ </span><span style="color: #0000FF">${</span><span style="color: #267F99"><data-lsp lsp='(type parameter) SE2' >SE2</data-lsp></span><span style="color: #0000FF">}</span><span style="color: #A31515">`</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000"> : </span><span style="color: #267F99">never</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Zero = {&#10;    s: "s";&#10;    b: Abs&lt;"z", Var&lt;"z">>;&#10;}' >Zero</data-lsp></span><span style="color: #000000"> = </span><span style="color: #267F99"><data-lsp lsp='type ParseExpr&lt;T> = ParseAbs&lt;T> extends never ? ParseApp&lt;T> extends never ? ParseVar&lt;T> extends never ? never : ParseVar&lt;T> : ParseApp&lt;T> : ParseAbs&lt;...>' >ParseExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"(λs. (λz. z))"</span><span style="color: #000000">&gt;;</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type One = {&#10;    s: "s";&#10;    b: Abs&lt;"z", App&lt;Var&lt;"s">, Var&lt;"z">>>;&#10;}' >One</data-lsp></span><span style="color: #000000"> = </span><span style="color: #267F99"><data-lsp lsp='type ParseExpr&lt;T> = ParseAbs&lt;T> extends never ? ParseApp&lt;T> extends never ? ParseVar&lt;T> extends never ? never : ParseVar&lt;T> : ParseApp&lt;T> : ParseAbs&lt;...>' >ParseExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"(λs. (λz. (s z)))"</span><span style="color: #000000">&gt;;</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Two = {&#10;    s: "s";&#10;    b: Abs&lt;"z", App&lt;Var&lt;"s">, App&lt;Var&lt;"s">, Var&lt;"z">>>>;&#10;}' >Two</data-lsp></span><span style="color: #000000"> = </span><span style="color: #267F99"><data-lsp lsp='type ParseExpr&lt;T> = ParseAbs&lt;T> extends never ? ParseApp&lt;T> extends never ? ParseVar&lt;T> extends never ? never : ParseVar&lt;T> : ParseApp&lt;T> : ParseAbs&lt;...>' >ParseExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"(λs. (λz. (s (s z))))"</span><span style="color: #000000">&gt;;</span></div><div class='line'><span style="color: #0000FF">type</span><span style="color: #000000"> </span><span style="color: #267F99"><data-lsp lsp='type Add = {&#10;    s: "m";&#10;    b: Abs&lt;"n", Abs&lt;"s", Abs&lt;"z", App&lt;App&lt;Var&lt;"m">, Var&lt;"s">>, App&lt;App&lt;Var&lt;"n">, Var&lt;"s">>, Var&lt;"z">>>>>>;&#10;}' >Add</data-lsp></span><span style="color: #000000"> = </span><span style="color: #267F99"><data-lsp lsp='type Abs&lt;S extends string, B extends Expr> = {&#10;    s: S;&#10;    b: B;&#10;}' >Abs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"m"</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='type Abs&lt;S extends string, B extends Expr> = {&#10;    s: S;&#10;    b: B;&#10;}' >Abs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"n"</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='type Abs&lt;S extends string, B extends Expr> = {&#10;    s: S;&#10;    b: B;&#10;}' >Abs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"s"</span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='type Abs&lt;S extends string, B extends Expr> = {&#10;    s: S;&#10;    b: B;&#10;}' >Abs</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"z"</span><span style="color: #000000">,</span></div><div class='line'><span style="color: #000000">                </span><span style="color: #267F99"><data-lsp lsp='type App&lt;E1 extends Expr, E2 extends Expr> = {&#10;    e1: E1;&#10;    e2: E2;&#10;}' >App</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type ParseExpr&lt;T> = ParseAbs&lt;T> extends never ? ParseApp&lt;T> extends never ? ParseVar&lt;T> extends never ? never : ParseVar&lt;T> : ParseApp&lt;T> : ParseAbs&lt;...>' >ParseExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"(m s)"</span><span style="color: #000000">&gt;, </span><span style="color: #267F99"><data-lsp lsp='type App&lt;E1 extends Expr, E2 extends Expr> = {&#10;    e1: E1;&#10;    e2: E2;&#10;}' >App</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type ParseExpr&lt;T> = ParseAbs&lt;T> extends never ? ParseApp&lt;T> extends never ? ParseVar&lt;T> extends never ? never : ParseVar&lt;T> : ParseApp&lt;T> : ParseAbs&lt;...>' >ParseExpr</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"(n s)"</span><span style="color: #000000">&gt;, </span><span style="color: #267F99"><data-lsp lsp='type Var&lt;X extends string> = {&#10;    x: X;&#10;}' >Var</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #A31515">"z"</span><span style="color: #000000">&gt;&gt;&gt;&gt;&gt;&gt;&gt;;</span></div><div class='line'><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1"><data-lsp lsp='const abeq_test1: "(((λm. (λn. (λs. (λz. ((m s) ((n s) z)))))) (λs. (λz. (s z)))) (λs. (λz. (s z)))) ≡ (λs. (λz. (s (s z))))"' >abeq_test1</data-lsp></span><span style="color: #000000">: </span><span style="color: #267F99"><data-lsp lsp='type ABEqTest&lt;E1 extends Expr, E2 extends Expr> = StringOfExpr&lt;E1> extends infer SE1 ? SE1 extends string ? StringOfExpr&lt;E2> extends infer SE2 ? SE2 extends string ? ABEq&lt;E1, E2> extends true ? `${SE1} \u2261 ${SE2}` : `${SE1} \u2262 ${SE2}` : never : never : never : never' >ABEqTest</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type App&lt;E1 extends Expr, E2 extends Expr> = {&#10;    e1: E1;&#10;    e2: E2;&#10;}' >App</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type App&lt;E1 extends Expr, E2 extends Expr> = {&#10;    e1: E1;&#10;    e2: E2;&#10;}' >App</data-lsp></span><span style="color: #000000">&lt;</span><span style="color: #267F99"><data-lsp lsp='type Add = {&#10;    s: "m";&#10;    b: Abs&lt;"n", Abs&lt;"s", Abs&lt;"z", App&lt;App&lt;Var&lt;"m">, Var&lt;"s">>, App&lt;App&lt;Var&lt;"n">, Var&lt;"s">>, Var&lt;"z">>>>>>;&#10;}' >Add</data-lsp></span><span style="color: #000000">, </span><span style="color: #267F99"><data-lsp lsp='type One = {&#10;    s: "s";&#10;    b: Abs&lt;"z", App&lt;Var&lt;"s">, Var&lt;"z">>>;&#10;}' >One</data-lsp></span><span style="color: #000000">&gt;, </span><span style="color: #267F99"><data-lsp lsp='type One = {&#10;    s: "s";&#10;    b: Abs&lt;"z", App&lt;Var&lt;"s">, Var&lt;"z">>>;&#10;}' >One</data-lsp></span><span style="color: #000000">&gt;, </span><span style="color: #267F99"><data-lsp lsp='type Two = {&#10;    s: "s";&#10;    b: Abs&lt;"z", App&lt;Var&lt;"s">, App&lt;Var&lt;"s">, Var&lt;"z">>>>;&#10;}' >Two</data-lsp></span><span style="color: #000000">&gt;</span></div><div class='line'><span style="color: #000000">    = </span><span style="color: #A31515">"(((λm. (λn. (λs. (λz. ((m s) ((n s) z)))))) (λs. (λz. (s z)))) (λs. (λz. (s z)))) ≡ (λs. (λz. (s (s z))))"</span><span style="color: #000000">;</span></div></code></div></pre>
<p>With the notion of program equivalence and this example, we can start to see
glimmers of the <a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">Curry-Howard correspondence</a><span class="note"><label for="curry-Howard" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="curry-Howard" class="margin-toggle" /><span class="sidenote">But whatever correspondence we might interpret here is really
just a glimmer; we cannot get very far until we add types
on top of the lambda calculus. Dependent type theories in particular
provide a correspondence to all sorts of things in classical and intuitionist logic.
With a bit of knowledge about Cartesian closed categories and adjunctions, we
get even farther, to the <a href="https://ncatlab.org/nlab/show/computational+trilogy">trilogy</a>
we mentioned in the introduction.</span>. Also, Peano arithmetic is
Turing-complete, so if we wanted to, we could provide yet another proof that
TypeScript's type system is Turing-complete by modeling the rest of Peano
arithmetic in the lambda calculus (which is doable, if not tedious).</p>
<h2 id="notes" tabindex="-1"><a class="header-anchor" href="#notes" aria-hidden="true"></a>Notes</h2>
<p>The trickiest and &quot;ugliest&quot; part of our evaluator is the procedure of
substitution and $\alpha$-conversion. Indeed, it feels a bit unpleasant to have
to deal with collisions between variable names, which are a syntactic concern,
when performing substitution, which is a semantic concern. By using a nameless
representation of bound variables, like <a href="https://en.wikipedia.org/wiki/De_Bruijn_index">de Bruijn indices</a>,
we trade off the inconveniences of $\alpha$-conversion for the
semantically-more-appealing operation of &quot;shifting&quot; variable indices to account
for changes in enclosing abstractions. de Bruijn indices are a bit tricky to
internalize so we didn't use them here. For a good introduction on de Bruijn
indices and various typed extensions of the lambda calculus see
Pierce's classic <em>Types and Programming Languages</em>.</p>
<p>Besides $\alpha$ and $\beta$ reductions, there is a third common, fundamental
operation in the lambda calculus known as <strong>$\eta$-equivalence</strong>.
$\eta$-equivalence says that for all $f$, $(\lambda x. (f\ x)) \equiv f$. This
leads to the rewrite rule $(\lambda x. (f\ x)) \Ra f$, known as <strong>$\eta$-reduction</strong>,
and to the reverse rule $f \Ra (\lambda x. (f\ x))$, known as
<strong>$\eta$-abstraction</strong>.
$\eta$-reduction is useful for cleaning up code with lots of &quot;unnecessary&quot;
abstractions and converting lazy (thunked) code into eagerly-evaluated code.
Conversely, $\eta$-abstraction makes eager evaluation lazy.
Importantly, $\eta$-equivalence communicates the extensional equivalence of functions,
specifying that two functions are equivalent (more strictly, equal) iff they
yield equivalent (more strictly, equal) outputs for all inputs. This equivalence
is sometimes used for optimizations in compilers of functional languages.
An expression is said to be in <strong>$\beta\eta$ normal form</strong> when no $\beta$ or $\eta$ reductions
are possible. We did not explore $\eta$-reductions here because it does not
impact our notion of program equivalence (why?).</p>
<p>Lastly, an unpleasant implementation detail is our constant unwrapping of
recursive type constructors in the pattern of <code>Rec&lt;T&gt; extends Infer1 ? Infer1 extends Target</code>. As mentioned before, this verbose expansion is needed
to help guide the typechecker in computing type instantiation efficiently. I
could not find any way to get around this pattern except in a few places. If you
find a better implementation, please let me know.</p>


</article>

<section class="footer">
  
  <a href="/articles/21/type-inference-for-flow-typing"
    >&laquo; Type Inference for <Em>sound and Complete Flow Typing</em></a
  >
  
  <span
    ><img class='emoji' alt='notebook' src='https://gitlab.com/ayazhafiz/emoji-img/raw/master/public/emoji/unicode/1f4d3.png' height=20 width=20></img>&emsp;
    <span
      >&#8203;
      <script type="math/tex">
        (\lambda x. x x x)(\lambda x. x x x)
      </script></span
    >
  </span>
  
  <a href="/articles/22/why-dont-more-languages-offer-flow-typing">Why Don't More Languages Offer Flow Typing? &raquo;</a>
  
</section>

<script src="https://utteranc.es/client.js"
        repo="ayazhafiz/gww-utterances"
        issue-term="title"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

<script type="text/javascript">
  function $(query) {
    return document.querySelector(query);
  }

  function $$(query) {
    return Array.from(document.querySelectorAll(query));
  }

  function isFullWidth() {
    return $(".post").classList.contains("full");
  }

  function toggleFullWidth() {
    const isFull = isFullWidth();
    isFull
      ? $(".post").classList.remove("full")
      : $(".post").classList.add("full");
    toggleShowHideNotes(!isFull);
    toggleShowHideNotesSwitch(!isFull);
    return !isFull;
  }

  function toggleShowHideNotes(isFullWidth) {
    const notes = $$(".marginnote").concat($$(".sidenote"));
    notes.forEach(note => {
      isFullWidth
        ? note.classList.add("maybe-hide")
        : note.classList.remove("maybe-hide");
    });
  }

  document.addEventListener("DOMContentLoaded", () => {
    $$(".note").forEach(toggle =>
      toggle.addEventListener("click", () => {
        if (isFullWidth()) {
          toggleFullWidth();
        }
      })
    );
  });
</script>

        </div>
      </div>
    </div>

    <div class="bottom-bar">
    <details>
  <summary>Analytics</summary>
  By visiting this site, you agree to its use of <a href="https://www.cloudflare.com/analytics/"
    >Cloudflare Analytics</a
  >. No identifiable information is transmitted to Cloudflare. See
  <a href="https://www.cloudflare.com/web-analytics/">Cloudflare Analytics user privacy</a>.
</details>

</details>

    </div>
  </body>
</html>
