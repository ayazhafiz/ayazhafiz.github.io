

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?" />

<link rel="alternate" type="application/atom+xml" title="cc - Ayaz Hafiz" href="/feed-rss2.xml">


<title>
  
    A Simple Language With Flow Typing
  
</title>
<meta name="description" content="We discuss a simple language and type system that provides for flow typing with records and union types. We also present an extension that generalizes to near-arbitrary narrowing of types at the expense of greater runtime costs." />

<link
  rel="canonical"
  href="/articles/21/lang-narrow"
/>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    TeX: {
      Macros: {
        co: "\\colon",
        msf: "\\mathsf",
        Ra: "\\Rightarrow",
        Def: "\\text{Definition.}",
        Thm: "\\text{Theorem.}",
        Pf: "\\text{Proof.}",
        eps: "\\epsilon",
        lam: "\\lambda",
        lt: "<",
        
      },
    }
  });
  MathJax.Hub.Queue(function () {
    document.body.setAttribute('render-done', '');
  });
</script>

<script
  type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"
></script>

<link
  rel="stylesheet"
  type="text/css"
  href="/css/shiki.css?1719108628444865508"
/>




    <link
      rel="stylesheet"
      type="text/css"
      href="/css/post.css?1719108628444865508"
    />
  </head>

  <style></style>

  <body>
    <div class="container post">
      <div class="panel">
        <div class="column-right a simple language with flow typing-main">
          <section class="nav">
  <a class="nav-link" href="/about">about</a
  ><a class="nav-link" href="/cc">cc</a
  ><a class="nav-link" href="/visual">visual</a>
</section>
 <h1 class="title">A Simple Language With Flow Typing</h1>
<p class="byline">January 21, 2021</p>

<article class="post">
   <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#introduction">Introduction</a></li>
<li class="toc-entry toc-h2"><a href="#motivation">Motivation</a>
<ul>
<li class="toc-entry toc-h3"><a href="#the-merits-of-flow-typing">The merits of flow typing</a></li>
<li class="toc-entry toc-h3"><a href="#the-merits-of-our-union-types-compared-to-adts">The merits of our union types compared to ADTs</a>
<ul>
<li class="toc-entry toc-h4"><a href="#the-disadvantages-of-our-union-types-compared-to-adts">The disadvantages of our union types compared to ADTs</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#notation">Notation</a></li>
<li class="toc-entry toc-h2"><a href="#lang_narrow">lang_narrow</a>
<ul>
<li class="toc-entry toc-h3"><a href="#basic-types-and-their-rules">Basic types and their rules</a>
<ul>
<li class="toc-entry toc-h4"><a href="#record-types">Record types</a></li>
<li class="toc-entry toc-h4"><a href="#union-types">Union types</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#the-narrowed-type">The Narrowed type</a>
<ul>
<li class="toc-entry toc-h4"><a href="#interaction-with-branching-expressions">Interaction with branching expressions</a></li>
<li class="toc-entry toc-h4"><a href="#the-is-narrowing-expression">The is narrowing expression</a></li>
<li class="toc-entry toc-h4"><a href="#the-in-narrowing-expression">The in narrowing expression</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#a-runtime-implementation">A runtime implementation</a></li>
<li class="toc-entry toc-h3"><a href="#performance-concerns%2C-and-what-to-do-about-them">Performance concerns, and what to do about them</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#lang_extends">lang_extends</a>
<ul>
<li class="toc-entry toc-h3"><a href="#performance-concerns%2C-and-what-to-do-about-them-1">Performance concerns, and what to do about them</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#going-further%3A-an-algorithm-for-narrowed-contexts-in-imperative-programs">Going further: an algorithm for narrowed contexts in imperative programs</a></li>
<li class="toc-entry toc-h2"><a href="#summary">Summary</a></li>
</ul> 
  <h2 id="introduction" tabindex="-1"><a class="header-anchor" href="#introduction" aria-hidden="true"></a>Introduction</h2>
<blockquote>
<p>The full source code for the language described here is available at
<a href="https://github.com/ayazhafiz/lang_narrow">gh:ayazhafiz/lang_narrow</a>.</p>
<p>You can try out the language in <a href="https://ayazhafiz.com/lang_narrow">this playground</a>.</p>
</blockquote>
<p>In this cc, we will formulate <a href="#lang_narrow"><code>lang_narrow</code></a>, a language that supports flow typing
with record and union types<span class="note"><label for="union" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="union" class="margin-toggle" /><span class="sidenote">Union types are also known as sum types.</span>. Flow
typing empowers our language's type system to structurally narrow values' types
at branches in a program's control flow. To gain an intuition for what this means, let's take a look at a
simple example:<span class="note"><label for="ts" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="ts" class="margin-toggle" /><span class="sidenote">If you are familiar with the TypeScript type system, our language's semantics will feel very similar.</span></p>
<pre class="shiki light-plus" style="background-color: #FFFFFF; color: #000000"><div class='code-container'><code><div class='line'><span style="color: undefined">fn defaultNat(): nat {
  1729
}

fn readNat(n: nat|string): nat {
  if n is nat
     then n             // n is nat
     else defaultNat()  // n is string
}

fn narrowBToNat(p: nat|{a: bool, b: nat}|{b: string, c: nat}): nat {
  if b in p
     then readNat(p.b)  // p is {a: bool, b: nat}|{b: string, c: nat}
     else p             // p is nat
}

// narrowBToNat(10) // =&gt; 10
// narrowBToNat({a: true, b: 20}) // =&gt; 20
// narrowBToNat({b: "not a nat" , c: 9}) // =&gt; 1729</span></div></code></div></pre>
<p>The union type <code>T|U</code> denotes a type that is either <code>T</code> or <code>U</code>, and the
<code>is</code> and <code>in</code> expressions introduce a condition that constrains a union type to
a subtype in either branch. Hopefully it's easy to get an idea of what is
going; later, we'll define the language and its constructs more formally.</p>
<p>Even superficially, it is clear that our use of &quot;union types&quot; here is somewhat different from the
tagged union <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data types</a>
(ADTs) present in Haskell (via <code>data</code>), OCaml (via
<code>type</code>), or Rust (via <code>enum</code>). Our union types are structural rather than
nominal, and the variants of our union types are types in of themselves, rather
than simply tag names (or constructors). However, they are still tagged unions
in the sense that the the variants of the union are named by their types. As
mentioned, we'll give a proper definition our union types later on.</p>
<h2 id="motivation" tabindex="-1"><a class="header-anchor" href="#motivation" aria-hidden="true"></a>Motivation</h2>
<p>Before we delve into formalizations, it may be helpful give some motivation for why we might want to
explore <code>lang_narrow</code>. After all, why not use ADTs in place of the kinds
of unions we have here, and why would flow typing be useful when
we can pattern match on data constructors? I will give two reasons, though
there may be more.</p>
<h3 id="the-merits-of-flow-typing" tabindex="-1"><a class="header-anchor" href="#the-merits-of-flow-typing" aria-hidden="true"></a>The merits of flow typing</h3>
<p>In languages with ADTs, but without flow typing, we cannot employ the type system
to constrain the variants of an ADT based on invariants in a program control
flow. For example, consider some code like</p>
<pre class="shiki light-plus" style="background-color: #FFFFFF; color: #000000"><div class="language-id">rust</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">fn</span><span style="color: #000000"> </span><span style="color: #795E26">send_recv</span><span style="color: #000000">(</span><span style="color: #001080">req</span><span style="color: #000000">: </span><span style="color: #267F99">Request</span><span style="color: #000000">): </span><span style="color: #267F99">Data</span><span style="color: #000000"> {</span></div><div class='line'><span style="color: #000000">   </span><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #001080">resp</span><span style="color: #000000"> = </span><span style="color: #795E26">send</span><span style="color: #000000">(</span><span style="color: #001080">req</span><span style="color: #000000">);</span></div><div class='line'><span style="color: #000000">   </span><span style="color: #AF00DB">if</span><span style="color: #000000"> </span><span style="color: #0000FF">let</span><span style="color: #000000"> </span><span style="color: #267F99">Some</span><span style="color: #000000">(</span><span style="color: #267F99">Status</span><span style="color: #000000">::</span><span style="color: #267F99">Ok</span><span style="color: #000000">) = </span><span style="color: #001080">resp</span><span style="color: #000000">.status {</span></div><div class='line'><span style="color: #000000">      </span><span style="color: #AF00DB">return</span><span style="color: #000000"> </span><span style="color: #001080">resp</span><span style="color: #000000">.data;</span></div><div class='line'><span style="color: #000000">   }</span></div><div class='line'></div><div class='line'><span style="color: #000000">   </span><span style="color: #0000FF">let</span><span style="color: #000000"> </span><span style="color: #001080">req</span><span style="color: #000000"> = </span><span style="color: #795E26">expensive_refresh_request</span><span style="color: #000000">(</span><span style="color: #001080">req</span><span style="color: #000000">);</span></div><div class='line'><span style="color: #000000">   </span><span style="color: #0000FF">let</span><span style="color: #000000"> </span><span style="color: #001080">req</span><span style="color: #000000"> = </span><span style="color: #795E26">expensive_validate_request</span><span style="color: #000000">(</span><span style="color: #001080">req</span><span style="color: #000000">);</span></div><div class='line'><span style="color: #000000">   </span><span style="color: #AF00DB">match</span><span style="color: #000000"> </span><span style="color: #001080">resp</span><span style="color: #000000">.status {</span></div><div class='line'><span style="color: #000000">      </span><span style="color: #267F99">Status</span><span style="color: #000000">::</span><span style="color: #267F99">RateLimited</span><span style="color: #000000"> =&gt; </span><span style="color: #795E26">send_recv_with_backoff</span><span style="color: #000000">(</span><span style="color: #001080">req</span><span style="color: #000000">),</span></div><div class='line'><span style="color: #000000">      </span><span style="color: #267F99">Status</span><span style="color: #000000">::</span><span style="color: #267F99">Timeout</span><span style="color: #000000"> =&gt; </span><span style="color: #795E26">send_recv_with_proxy</span><span style="color: #000000">(</span><span style="color: #001080">req</span><span style="color: #000000">),</span></div><div class='line'><span style="color: #000000">      </span><span style="color: #267F99">Status</span><span style="color: #000000">::</span><span style="color: #267F99">Ok</span><span style="color: #000000"> =&gt; </span><span style="color: #795E26">unreachable!</span><span style="color: #000000">(),</span></div><div class='line'><span style="color: #000000">   }</span></div><div class='line'><span style="color: #000000">}</span></div></code></div></pre>
<p>This is a toy, but I hope it inspires a realistic situation. You have
some happy path you want to return from quickly, and a more expensive path to
go down otherwise. However, even though <code>Status::Ok</code> is not a variant that could
constitute <code>resp.status</code> in the last <code>match</code> expression, the type system doesn't
know that; we have to inform it that this is so, somewhat unergonomically.</p>
<p>With flow typing, the type system could remove <code>Status::Ok</code> from the possible
variants of <code>resp.status</code> after the first branch.</p>
<h3 id="the-merits-of-our-union-types-compared-to-adts" tabindex="-1"><a class="header-anchor" href="#the-merits-of-our-union-types-compared-to-adts" aria-hidden="true"></a>The merits of our union types compared to ADTs</h3>
<p>ADTs are closed. This means that whenever we add a new variant to an ADT, we
have to handle that variant everywhere the ADT is used.<span class="note"><label for="adt-haskell" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="adt-haskell" class="margin-toggle" /><span class="sidenote">This is not entirely true in Haskell, as
Haskell permits partial functions. But supposing that we would like our
functions to be total, this holds.</span></p>
<pre class="shiki light-plus" style="background-color: #FFFFFF; color: #000000"><div class="language-id">rust</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">enum</span><span style="color: #000000"> </span><span style="color: #267F99">Animal</span><span style="color: #000000"> = { </span><span style="color: #795E26">Cat</span><span style="color: #000000">(</span><span style="color: #267F99">Cat</span><span style="color: #000000">), </span><span style="color: #795E26">Dog</span><span style="color: #000000">(</span><span style="color: #267F99">Dog</span><span style="color: #000000">) }</span></div><div class='line'></div><div class='line'><span style="color: #0000FF">fn</span><span style="color: #000000"> </span><span style="color: #795E26">get_sound</span><span style="color: #000000">(</span><span style="color: #001080">a</span><span style="color: #000000">: </span><span style="color: #267F99">Animal</span><span style="color: #000000">): </span><span style="color: #267F99">String</span><span style="color: #000000"> { </span><span style="color: #008000">/* impl */</span><span style="color: #000000"> }</span></div><div class='line'><span style="color: #0000FF">fn</span><span style="color: #000000"> </span><span style="color: #795E26">get_name</span><span style="color: #000000">(</span><span style="color: #001080">a</span><span style="color: #000000">: </span><span style="color: #267F99">Animal</span><span style="color: #000000">): </span><span style="color: #267F99">String</span><span style="color: #000000"> { </span><span style="color: #008000">/* impl */</span><span style="color: #000000"> }</span></div></code></div></pre>
<p>If I want to handle getting just the name for another animal, say <code>Zebra</code>, I
need to add <code>Zebra</code> to the <code>Animal</code> ADT and handle the case of <code>Zebra</code> when
unpacking <code>Animal</code> in both <code>getSound</code> and <code>getName</code>. Of course, there are
ways around this: we could split up the <code>Animal</code> ADT into separate types to
be used for <code>getSound</code> and <code>getName</code>, but then there is no easy way to
convert between the separate types without writing even more code (at least
if the ADTs are treated nominally, as they generally are).</p>
<p>On the other hand, with union types this is easy:</p>
<pre class="shiki light-plus" style="background-color: #FFFFFF; color: #000000"><div class='code-container'><code><div class='line'><span style="color: undefined">fn getSound(a: Cat|Dog|Zebra): string { /* impl */ }
fn getSound(a: Cat|Dog): string { /* impl */ }</span></div></code></div></pre>
<p>Since the variants of the union are types in themselves, we can
include and exclude them freely. Furthermore, <code>Cat|Dog</code> can be subsumed by
<code>Cat|Dog|Zebra</code> immediately<span class="note"><label for="subsumed-nominal" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="subsumed-nominal" class="margin-toggle" /><span class="sidenote">As long as union types
are treated structurally, the subsumption would hold whether <code>Cat</code> and <code>Dog</code> are treated nominally or structurally.</span>;
we will formalize this subtyping relationship when developing the language in
the sections below.</p>
<h4 id="the-disadvantages-of-our-union-types-compared-to-adts" tabindex="-1"><a class="header-anchor" href="#the-disadvantages-of-our-union-types-compared-to-adts" aria-hidden="true"></a>The disadvantages of our union types compared to ADTs</h4>
<p>I certainly don't wish to claim life is greener on one side.
There are several disadvantages of using union types in the manner we will
develop in this language, including</p>
<ul>
<li><strong>A lack of uniform tag names:</strong> as we will see later, the <code>is</code> expression
requires that we attach to
every value used in such an expression a runtime type tag. This means
that the compiler must either employ some non-trivial machinery to determine all reachable
values to which it should attach type tags, or attach a
type tag to all runtime values. The cost of this work only increases with the <code>extends</code>
narrowing expression we introduce in <a href="#lang-extends"><code>lang_extends</code></a>, which
effectively requires a
typechecker in the program runtime. With ADTs, the costs associated with the
addition of type tags can be made
local and minimal -- tags are constructed and read at syntax-directed sites, making it
obvious to a compiler where they should be inserted.</li>
<li><strong>Recursive types are more difficult to formalize:</strong> given that our type system is
structural rather than nominal, it is more difficult to typecheck recursive
type definitions<span class="note"><label for="equi" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="equi" class="margin-toggle" /><span class="sidenote">It actually wouldn't be terrible with the
use of equirecursive types, but that's beyond the scope of this cc.</span>. To
keep things simple, our language has neither a notion of type variables nor
type inference, so there is no way to introduce recursive types.</li>
</ul>
<p>All this is to say, if I were implementing flow typing in a production
language, I would likely use ADTs and perform narrowing on data constructors. But open unions
are easier to bookkeep than ADTs, so we prefer them for the purposes of our small
language. It should be pretty straightforward to translate our approach to
a language with closed, nominal ADTs.</p>
<h2 id="notation" tabindex="-1"><a class="header-anchor" href="#notation" aria-hidden="true"></a>Notation</h2>
<p><span>​<script type="math/tex">\Gamma</script></span> signifies a typing context, with some number of
variable-to-type bindings. For example, <span>​<script type="math/tex">\Gamma =
\left\{\text{t}:\text{T}\right\}</script></span> is a typing context wherein the variable
$\text{t}$ has type $\text{T}$.</p>
<p><span>​<script type="math/tex">\Gamma\vdash \text{t} : \text{T}</script></span> means that under the context $\Gamma$, the expression $\text{t}$ has type $\text{T}$.
For example,</p>
<div class="mathblock"><script type="math/tex; mode=display">
\begin{align*}
\left\{ \text{a}: {\tt nat}, \text{id}: {\tt (nat): nat} \right\} \vdash \text{id}\left(\text{a}\right) : {\tt nat}
\end{align*}
</script></div>
is sound.
<p>A type derivation rule $\text{R}$ has the form <span>​<script type="math/tex">\frac{\left[\text{condition}\right]*}{\text{result}}</script></span>
and can be read as, &quot;when the conditions of $\text{R}$ hold, the result holds.&quot;
As an example, here is a derivation rule stipulating that the
addition of two expressions whose types under <span>​<script type="math/tex">\Gamma</script></span> are <code>nat</code>s
yields a <code>nat</code>:</p>
<div class="mathblock"><script type="math/tex; mode=display">
\begin{equation*}
\frac{\Gamma\vdash \text{a}: \text{$\tt{nat}$} \quad \Gamma\vdash \text{b}: \tt{nat}}
{\Gamma\vdash \text{a} + \text{b} : \tt{nat}}
\end{equation*}
</script></div>
<p>$\text{S} &lt;: \text{T} % &gt;$ states that $\text{S}$ is a subtype of $\text{T}$.
$\require{cancel}\text{S} \cancel{&lt;:} \text{T} % &gt;$ states that $\text{S}$ is
not a subtype of $\text{T}$.</p>
<h2 id="lang_narrow" tabindex="-1"><a class="header-anchor" href="#lang_narrow" aria-hidden="true"></a><code>lang_narrow</code></h2>
<p>Having discussed some motivation and notation, we will now begin to formalize
<code>lang_narrow</code>. We will derive its type system, discuss what is needed to
provide for flow typing, and go over a runtime for <code>lang_narrow</code> when compiled to C.</p>
<p>Although we will present most of the interesting typing rules necessary to glue
the system together, I don't attempt to cover all that would be
necessary to prove the correctness of this language's type system<span class="note"><label for="correctness" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="correctness" class="margin-toggle" /><span class="sidenote">In fact, I am not sure the type system is sound and complete,
though &quot;intuitively&quot; it may be seen to be.</span>.</p>
<h3 id="basic-types-and-their-rules" tabindex="-1"><a class="header-anchor" href="#basic-types-and-their-rules" aria-hidden="true"></a>Basic types and their rules</h3>
<p>Our language contains the primitive types <code>nat</code> (a natural number), <code>string</code>,
<code>bool</code>, <code>unknown</code> (the top type<span class="note"><label for="top" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="top" class="margin-toggle" /><span class="sidenote">The top type is
inhabited by all values; it is the supertype of all types.</span>), and <code>never</code>
(the bottom type<span class="note"><label for="bottom" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="bottom" class="margin-toggle" /><span class="sidenote">The bottom type is inhabited by no values; it is the
subtype of all types.</span>).</p>
<p><code>lang_narrow</code> supports functions and types them; for example,</p>
<pre class="shiki light-plus" style="background-color: #FFFFFF; color: #000000"><div class='code-container'><code><div class='line'><span style="color: undefined">fn add(a: nat, b: nat): nat { /* impl */ }</span></div></code></div></pre>
<p>has the type <code>(nat, nat): nat</code>. However, this syntactic representation
of function types is not admitted by the <a href="https://github.com/ayazhafiz/lang_narrow/blob/base/src/parser.mlyhttps://github.com/ayazhafiz/lang_narrow/blob/base/src/parser.mly">language front-end</a>;
that is, no value
can be explicitly typed as a function. Since all parameters must be typed by the user,
this restriction effectively means that there are no higher-order functions in
our language. Adding language support for higher-order functions would be
straightforward (support for type influencing less so<span class="note"><label for="subtype-inference" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="subtype-inference" class="margin-toggle" /><span class="sidenote">Historically, type inference in the presence of subtypes has presented serious
implementation difficulties. In general, an efficient implementation of such
systems requires careful design of a language with syntax-directed typing rules.
For efficient implementations, see <a href="https://hal.inria.fr/inria-00073205/document">Pottier's 1998 thesis</a>
and <a href="https://www.cs.tufts.edu/~nr/cs257/archive/stephen-dolan/thesis.pdf">Dolan's 2017 thesis</a>. Dolan's
thesis solves the even larger problem of type inference in the presence of subtyping and
polymorphism by treating types foremost as an algebra. A simpler, yet just-as-powerful version of Dolan's work is
described in <a href="https://lptk.github.io/files/%5Bv1.8%5D%20simple-essence-algebraic-subtyping.pdf">Parreaux 2020</a>.
Thanks to Ben Siraphob for introducing me to the latter two publications.</span>).</p>
<h4 id="record-types" tabindex="-1"><a class="header-anchor" href="#record-types" aria-hidden="true"></a>Record types</h4>
<p>Our language supports records; <code>{a: 1, b: true}</code> is a record with fields <code>a</code> and <code>b</code>, and has the type
<code>{a: nat, b: bool}</code>. Records can be projected by field name; <code>{a: 1, b: true}.b</code>
yields <code>true</code>. Here are the typing rules for record construction and
projection<span class="note"><label for="record-union" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="record-union" class="margin-toggle" /><span class="sidenote">After reading about <a href="#union-types">union types</a>, you may notice that neither $\ref{Record-Proj}$ nor any other rule
permits the projection of a value of type <code>{a: nat, b: nat}|{b: string}</code> on the field <code>b</code>. As an exercise for you,
suppose we would like such a projection to yield the type <code>nat|string</code> (in fact, the full <code>lang_narrow</code> type system does so). What
modifications to $\ref{Record-Proj}$ must be made to support this? (You can also
add additional rules, but doing so is not necessary).</span>:</p>
<div class="mathblock"><script type="math/tex; mode=display">
\begin{equation}\label{Record-Ctor}\tag{Record-Ctor}
\frac{\Gamma\vdash\text{t}_i:\text{T}_i \quad \forall i = 1, \dots, n}
{\Gamma\vdash \left\{\text{f}_1: \text{t}_1, \dots, \text{f}_n: \text{t}_n\right\}
:\left\{\text{f}_1: \text{T}_1, \dots, \text{f}_n: \text{T}_n\right\}}
\end{equation}
</script></div>
<div class="mathblock"><script type="math/tex; mode=display">
\begin{equation}\label{Record-Proj}\tag{Record-Proj}
\frac{\Gamma\vdash\text{t}:\left\{\text{f}_1: \text{T}_1, \dots, \text{f}_n: \text{T}_n\right\}}
{\Gamma\vdash\text{t}.\text{f}_i:\text{T}_i \quad i=1, \dots, n}
\end{equation}
</script></div>
<p>We also define a subtyping rule for records:</p>
<div class="mathblock"><script type="math/tex; mode=display">
\begin{equation}\label{Subtype-Record}\tag{Subtype-Record}
\frac{
\begin{gather*}
\text{S}=\left\{ \text{f}_1: \text{S}_1, \dots, \text{f}_n: \text{S}_n \right\} \quad
\text{T}=\left\{ \text{g}_1: \text{T}_1, \dots, \text{g}_m: \text{T}_m \right\} \\
\forall i=1,\dots,m \;\; \exists j \text{ s.t. } \text{f}_j = \text{g}_i \text{ and } \text{S}_j <: \text{T}_i % >
\end{gather*}
}{\text{S} <: \text{T}} % >
\end{equation}
</script></div>
<p>Notice that in the subtyping relation, the order of record fields does not
matter;
<span>​<script type="math/tex"> \left\{\text{c}: {\tt nat}, \text{b}: {\tt nat}, \text{a}: {\tt nat}\right\} \lt: \left\{\text{a}: {\tt nat}, \text{b}: {\tt nat}\right\} </script></span>
holds.</p>
<h4 id="union-types" tabindex="-1"><a class="header-anchor" href="#union-types" aria-hidden="true"></a>Union types</h4>
<p>A union type (also known as a sum type) is a type that may be inhabited by
values of several different types. As an example, in our language union types
are written like <code>{a: bool}|nat|string</code>, of which <code>{a: true}</code>, <code>1</code>, and <code>&quot;hi&quot;</code>
are all valid inhabitants. In <code>lang_narrow</code>, variants of a union type <code>U</code> are
subtypes of <code>U</code> and are tagged by their type name.</p>
<p>All values of a type <code>T</code> are also of the singleton union type consisting of <code>T</code>;
we make no distinction between these two notions. Unions types containing no
type variants are equivalent to the <code>never</code> type; we make no distinction between
these two either.</p>
<p>Notice that it is
impractical for us to deduce that a value of type <code>T</code> is of a union type that is a
strict supertype of <code>T</code> without explicit annotations. For example, we would
certainly prefer to type the literal <code>1</code> as a <code>nat</code>, rather than <code>nat|string</code> or any other
number of union types - indeed, the only two reasonable choices here are <code>nat</code> or <code>top</code>.
Nevertheless, we would like to express the fact that a <code>nat</code> is a <code>nat|string</code>; for example</p>
<pre class="shiki light-plus" style="background-color: #FFFFFF; color: #000000"><div class='code-container'><code><div class='line'><span style="color: undefined">fn id(a: nat|string): nat|string { a }
id(1)</span></div></code></div></pre>
<p>should be well-typed. Thus, we have the following subtyping rule for unions:</p>
<div class="mathblock"><script type="math/tex; mode=display">
\begin{equation}\label{Subtype-Union}\tag{Subtype-Union}
\frac{
\begin{gather*}
\text{S}=\text{S}_1 ~|~ \dots ~|~ \text{S}_n \quad
\text{T}=\text{T}_1 ~|~ \dots ~|~ \text{T}_m \\
\forall i=1,\dots,n \;\; \exists \text{T}_j \text{ s.t. } \text{S}_i <: \text{T}_j
\end{gather*}
}{\text{S} <: \text{T}} % >
\end{equation}
</script></div>
<p>As with <span>​<script type="math/tex">\ref{Subtype-Record}</script></span>, the order of union variants does
not matter;
<span>​<script type="math/tex">
\text{nat}|\text{string} \lt: \text{string}|\text{bool}|\text{nat}
</script></span>
holds.</p>
<p>There are also a few convenience rules we may want to introduce<span class="note"><label for="convenience" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="convenience" class="margin-toggle" /><span class="sidenote">There are more than the two we present here; for example we could also have an
&quot;unfold&quot; rule that makes <code>string|(bool|nat)</code> equivalent to <code>string|bool|nat</code>.</span>. For one,
notice that the type <code>string|nat|string</code> is equivalent to <code>string|nat</code>.</p>
<div class="mathblock"><script type="math/tex; mode=display">
\begin{equation}\label{Union-dup}\tag{Union-dup}
\frac{
\begin{gather*}
\text{T} = \text{T}_1 ~|~ \dots ~|~ \text{T}_i ~|~ \dots
~|~ \text{T}_{j-1} ~|~ \text{T}_j ~|~ \text{T}_{j+1}
~|~ \dots ~|~ \text{T}_n \\
\text{T}_i = \text{T}_j
\end{gather*}
}{
\text{T} = \text{T}_1 ~|~ \dots ~|~ \text{T}_i ~|~ \dots
~|~ \text{T}_{j-1} ~|~ \text{T}_{j+1} ~|~ \dots ~|~ \text{T}_n
}
\end{equation}
</script></div>
<p>Furthermore, notice that <code>string|never</code> is equivalent to <code>string</code>, as <code>never</code> is
inhabited by no values and therefore contributes nothing to the domain of the
union type.</p>
<div class="mathblock"><script type="math/tex; mode=display">
\begin{equation}\label{Union-never}\tag{Union-never}
\frac{
\begin{gather*}
\text{T} = \text{T}_1 ~|~ \dots
~|~ \text{T}_{i-1} ~|~ \text{T}_i ~|~ \text{T}_{i+1}
~|~ \dots ~|~ \text{T}_n \\
\text{T}_i = \tt{never}
\end{gather*}
}{
\text{T} = \text{T}_1 ~|~ \dots
~|~ \text{T}_{i-1} ~|~ \text{T}_{i+1} ~|~ \dots ~|~ \text{T}_n
}
\end{equation}
</script></div>
<h3 id="the-narrowed-type" tabindex="-1"><a class="header-anchor" href="#the-narrowed-type" aria-hidden="true"></a>The <code>Narrowed</code> type</h3>
<p>Next, let's formalize the semantics of flow typing in <code>lang_narrow</code> and discuss
what data structures we need to represent these semantics.</p>
<p>As we saw in our initial example, the main idea of flow typing is to introduce a
condition at branch sites that narrows a value of type <code>T</code> to a type <code>U</code> in
one branch (let's call this the left branch), and to the type of <code>T</code> &quot;without&quot;
<code>U</code> in the other branch (let's call this the right branch).
In our language, we only provide <code>if</code> expressions for branching, for which this
idea might look something like</p>
<pre class="shiki light-plus" style="background-color: #FFFFFF; color: #000000"><div class='code-container'><code><div class='line'><span style="color: undefined">// suppose Γ = {a: T}
if &lt;some check to see if a is a U&gt;
  then ... // a is a subtype of U in this branch
  else ... // a is a subtype of (T "without" U) in this branch</span></div></code></div></pre>
<p>We'll use a type constructor called <code>Narrowed</code> to encapsulate the relationship
between an expression and its narrowed types in left and right branches. In the
example above, the <code>&lt;some check&gt;</code> condition would yield the type
<code>Narrowed⟨a, U, T-U⟩</code>, where <code>T-U</code> signifies a type inhabited by values that
inhabit <code>T</code> but do not inhabit <code>U</code><span class="note"><label for="subtract" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="subtract" class="margin-toggle" /><span class="sidenote">This is one
interpretation of what we described as <code>T</code> &quot;without&quot; <code>U</code> above, but there are many
others. We have to be careful though, because only a few interpretations can be
proven sound!</span>.</p>
<p>We have two things to figure out regarding <code>Narrowed</code> types:</p>
<ul>
<li>figure out how to construct them</li>
<li>figure out how they influence the types of branching expressions</li>
</ul>
<p>Let's do the latter first.</p>
<h4 id="interaction-with-branching-expressions" tabindex="-1"><a class="header-anchor" href="#interaction-with-branching-expressions" aria-hidden="true"></a>Interaction with branching expressions</h4>
<p>Take a look at the derivation rule for an <code>if</code> expression with a boolean
condition:</p>
<div class="mathblock"><script type="math/tex; mode=display">
\begin{equation}\label{If-bool}\tag{If-bool}
\frac{
\begin{gather*}
\Gamma\vdash \text{c}:\text{bool} \\
\Gamma\vdash \text{left}:\text{T} \\
\Gamma\vdash \text{right}:\text{U}
\end{gather*}
}{
\Gamma\vdash \text{$\tt{if}$ c $\tt{then}$ left $\tt{else}$ right} :
\text{T} \vee \text{U}
}
\end{equation}
</script></div>
<p>For those unfamiliar, <span>​<script type="math/tex">\text{T} \vee \text{U}</script></span> is called the <strong>join</strong> of $\text{T}$ and $\text{U}$,
and represents their least upper bound (or least common supertype). As a derivation
rule,</p>
<div class="mathblock"><script type="math/tex; mode=display">
\begin{equation}\label{Join}\tag{Join}
\frac{
\begin{gather*}
\text{T} <: \text{J} \quad \text{U} <: \text{J} \\ % >
\forall \text{K} \text{ s.t. } \text{T} <: \text{K}, \text{U} <: \text{K} % >
\implies \text{J} <: \text{K} % >
\end{gather*}
}{
\text{T} \vee \text{U} = \text{J}
}
\end{equation}
</script></div>
<p>The only modification we need to make for the derivation rule of <code>if</code> with a
<code>Narrowed</code> condition is how the narrowed expression should be typed in the left
and right branches.</p>
<div class="mathblock"><script type="math/tex; mode=display">
\require{cancel}
\begin{equation}\label{If-narrowed}\tag{If-narrowed}
\frac{
\begin{gather*}
\text{t} : \text{T} \in \Gamma \\
\Gamma\vdash \text{c} : \text{Narrowed}\langle \text{t}, \text{U}, \text{W}\rangle \\
% TODO: why do i need this hack for never?
\text{U} \ne \text{$\tt{never}$} \ne \text{W} \\
\Gamma_{\bcancel{\text{t}}} = \Gamma \setminus \left\{\text{t : T}\right\} \\
\Gamma_{\bcancel{\text{t}}}, \text{t} : \text{U} \vdash \text{left} : \text{L} \\
\Gamma_{\bcancel{\text{t}}}, \text{t} : \text{W} \vdash \text{right} : \text{R}
\end{gather*}
}{
\Gamma\vdash \text{$\tt{if}$ c $\tt{then}$ left $\tt{else}$ right} :
\text{L} \vee \text{R}
}
\end{equation}
</script></div>
<p>First, we verify that the narrowed term <code>t</code> is in the typing context. If it
is not (for example, if it is a literal) the expression would not be
referenceable in either branch anyway; we assume this is a programming error.
Next, we validate that neither narrowed type of <code>t</code> is <code>never</code>; if it were, the
branch associated with that narrowed type would never be taken, and hence the
branch is vacuous; we assume this also is a programming error.</p>
<p>Then, we remove the binding for <code>t</code> from
the typing context, determine the type of each branch with the addition of
the relevant narrowed type of <code>t</code> to its context, and yield the type of the <code>if</code> expression as the
join of both branches' types. Notice that the context of the resulting type
contains the unnarrowed type of <code>t</code>.</p>
<p>The restrictions we have imposed, namely that <code>t</code> must be a variable
and that neither narrowed type can evaluate to <code>never</code>, are not actually
necessary for the soundness of the derivation rule. However, their inclusion
helps catch programming mistakes, and the restriction against
<code>never</code>-narrowed branches effectively makes <span>​<script type="math/tex">\ref{If-narrowed}</script></span>
applicable only when <code>T</code> is a union type. This can simplify a typechecking
implementation significantly.</p>
<p>And that's all for <code>Narrowed</code> types in branches. Now, onto how to construct
<code>Narrowed</code> types!</p>
<h4 id="the-is-narrowing-expression" tabindex="-1"><a class="header-anchor" href="#the-is-narrowing-expression" aria-hidden="true"></a>The <code>is</code> narrowing expression</h4>
<p>In our language, the <code>is</code> expression constructs a <code>Narrowed</code> type from an
expression and a subtype of the expression type. For example, the expression</p>
<pre class="shiki light-plus" style="background-color: #FFFFFF; color: #000000"><div class='code-container'><code><div class='line'><span style="color: undefined">// suppose Γ = {a: string|nat|bool}
a is string|bool</span></div></code></div></pre>
<p>has the type <code>Narrowed⟨a, string|bool, nat⟩</code>. We define the derivation rule for
<code>is</code> expressions the following way:</p>
<div class="mathblock"><script type="math/tex; mode=display">
\begin{equation}\label{Is}\tag{Is}
\frac{
\begin{gather*}
\text{W} = \text{T} - \text{U} \\
\end{gather*}
}{
\Gamma \vdash \text{t $\tt{is}$ T}: \text{Narrowed}\langle\text{t}, \text{U}, \text{W}\rangle
}
\end{equation}
</script></div>
<p>where the subtraction rule $\text{T} - \text{U}$ is given by</p>
<div class="mathblock"><script type="math/tex; mode=display">
\begin{equation}\label{Union-subtract}\tag{Union-subtract}
\frac{
\begin{gather*}
\text{T} = \text{T}_1 ~|~ \dots ~|~ \text{T}_n \\
\text{U} = \text{U}_1 ~|~ \dots ~|~ \text{U}_m \\
\text{W} = \text{W}_1 ~|~ \dots ~|~ \text{W}_p \\
\text{W } <: \text{T} \\ % >
\bbox[border: 1px solid grey]{
   \begin{gather*}
   \forall i=1,\dots,n \text{ s.t. } \forall j=1,\dots,m \\
   \text{T}_i \ne \text{U}_j \implies
   \exists \text{W}_k = \text{T}_i
   \end{gather*}
}
\end{gather*}
}{
\text{T} - \text{U} = \text{W}
}
\end{equation}
</script></div>
<p>Notice that <span>​<script type="math/tex">\ref{Union-subtract}</script></span> elides from <code>T</code> only those
types that equivalent to a variant of <code>U</code> (up to permutation of record
fields). For example, <code>{a: nat, b: bool} - {a: nat}</code> yields <code>{a: nat, b: bool}</code>,
not <code>never</code>.</p>
<p>If the restrictions of <span>​<script type="math/tex">\ref{Union-subtract}</script></span> seem a bit limiting or unnecessary, we will discuss a
language that avoids them at the expense of greater runtime costs in <a href="#lang_extends"><code>lang_extends</code></a>.
However, I suspect these restrictions are reasonable for most general-purpose programming,
as it is always possible to refine a union type annotation with a type variant
that one may later want to narrow.</p>
<h4 id="the-in-narrowing-expression" tabindex="-1"><a class="header-anchor" href="#the-in-narrowing-expression" aria-hidden="true"></a>The <code>in</code> narrowing expression</h4>
<p>Consider the function</p>
<pre class="shiki light-plus" style="background-color: #FFFFFF; color: #000000"><div class='code-container'><code><div class='line'><span style="color: undefined">fn readBOrC(obj: {a: nat, b: nat}|{a: nat, c: nat}|{b: nat, d: nat}|{c: nat, d: nat}): nat {
  if obj is {a: nat, b: nat}|{b: nat, d: nat}
     then obj.b
     else obj.c
}</span></div></code></div></pre>
<p>This works, but is a bit bulky; we don't care that <code>obj</code> is a union of records
possibly containing <code>a</code> or <code>d</code>, we just care whether or not it's a subtype of
<code>{b: nat}</code>. Because <span>​<script type="math/tex">\ref{Union-subtract}</script></span> excludes types by
equivalence rather than subtyping relation, if we were to try <code>obj is {b: nat}</code>,
the left narrowing type would be <code>never</code>. So to elegantly handle narrowing of
records, we can reformulate <span>​<script type="math/tex">\ref{Union-subtract}</script></span> accordingly, as we do for <a href="#lang_extends"><code>lang_extends</code></a>, or introduce
a special case for records, as we will do here with the <code>in</code> expression.</p>
<p><code>in</code> takes a field name <code>f</code> and an expression of type <code>T</code>,
constructing a <code>Narrowed</code> instance with subtypes of <code>T</code> that are records containing <code>f</code> on the left
and all other subtypes of <code>T</code> on the right. For example,</p>
<pre class="shiki light-plus" style="background-color: #FFFFFF; color: #000000"><div class='code-container'><code><div class='line'><span style="color: undefined">// suppose: obj :: {a: nat, b: nat}|{a: nat, c: nat}|{b: nat, d: nat}|{c: nat, d: nat}
b in obj</span></div></code></div></pre>
<p>has the type</p>
<pre class="shiki light-plus" style="background-color: #FFFFFF; color: #000000"><div class='code-container'><code><div class='line'><span style="color: undefined">Narrowed⟨obj, {a: nat, b: nat}|{b: nat, d: nat}, {a: nat, c: nat}|{c: nat, d: nat}⟩</span></div></code></div></pre>
<p>We define the derivation rule for <code>in</code> expressions the following way:</p>
<div class="mathblock"><script type="math/tex; mode=display">
\require{bbox}
\begin{equation}\label{In}\tag{In}
\frac{
\begin{gather*}
\Gamma\vdash \text{t} : \text{T}_1 ~|~ \dots ~|~ \text{T}_n \\
\text{U} = \text{U}_1 ~|~ \dots ~|~ \text{U}_m \\
\text{U } <: \text{T} \\ % >
\bbox[border: 1px solid grey]{
   \begin{gather*}
   \forall i=1,\dots,n \text{ s.t. } \text{T}_i = \left\{\text{f}_1: \text{T}_{i1}, \dots, \text{f}_j : \text{T}_{ij} \right\} \\
   \text{and } \exists \text{f}_k = \text{f} \implies \exists \text{U}_l = \text{T}_i
   \end{gather*}
} \\
\text{W} = \text{T} - \text{U} \\
\end{gather*}
}{\Gamma \vdash \text{f $\tt{in}$ t}: \text{Narrowed}\langle\text{t}, \text{U}, \text{W}\rangle}
\end{equation}
</script></div>
<p>Notice that the extraction of record types containing the field $\text{f}$ distributes over
the union type $\text{T}$, rather than operating on the type as a whole. This is
similar to the behavior of TypeScript's <a href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types">distributed conditional types</a>.</p>
<h3 id="a-runtime-implementation" tabindex="-1"><a class="header-anchor" href="#a-runtime-implementation" aria-hidden="true"></a>A runtime implementation</h3>
<p>A <a href="https://github.com/ayazhafiz/lang_narrow/blob/base/src/typecheck.ml">typechecking implementation</a>
of <code>lang_narrow</code> is a pretty straightforward encoding of the presented
typing rules. What is more interesting is the implementation of expressions like
<code>is</code> in the evaluation of a <code>lang_narrow</code> program, as these require auxiliary
type information.</p>
<p>Actually, if the language is <a href="https://github.com/ayazhafiz/lang_narrow/blob/base/src/eval.ml">interpreted</a>,
evaluating type-dependent expressions is straightforward -- we reduce the expression-to-be-checked to a
value, invoke the typechecker, and get our result.</p>
<p>But if the language is <a href="https://github.com/ayazhafiz/lang_narrow/blob/base/src/codegenC.ml">compiled</a>,
we have a bit more work to do in encoding type tags and measuring type compatibility.
In the rest of this section, we will discuss this work for <code>lang_narrow</code>
programs compiled to C.</p>
<p>A sufficiently advanced compiler could determine precisely which values are used
in expressions that read type tags, and attach tags only to those. For the ease of
implementation, we generate C code with all values having type tags.</p>
<p>In our <a href="https://github.com/ayazhafiz/lang_narrow/blob/base/src/codegenC.ml">code generator</a>,
we encode every value as an instance of a <code>tagged_any</code> struct.
The struct includes a type tag that discerns a value's true type to
runtime functions, and <code>val</code> field that contains the raw, type-safe value.</p>
<pre class="shiki light-plus" style="background-color: #FFFFFF; color: #000000"><div class="language-id">c</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">typedef</span><span style="color: #000000"> </span><span style="color: #0000FF">struct</span><span style="color: #000000"> tagged_any tagged_any;</span></div><div class='line'><span style="color: #0000FF">typedef</span><span style="color: #000000"> </span><span style="color: #0000FF">struct</span><span style="color: #000000"> record {</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #0000FF">int</span><span style="color: #000000"> numFields;</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0000FF">char</span><span style="color: #000000">** fields;</span></div><div class='line'><span style="color: #000000">  tagged_any* values;</span></div><div class='line'><span style="color: #000000">} record;</span></div><div class='line'><span style="color: #0000FF">union</span><span style="color: #000000"> any {</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #0000FF">int</span><span style="color: #000000"> nat;</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0000FF">char</span><span style="color: #000000">* string;</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #0000FF">int</span><span style="color: #000000"> </span><span style="color: #0000FF">bool</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #000000">  record record;</span></div><div class='line'><span style="color: #000000">} any;</span></div><div class='line'><span style="color: #0000FF">struct</span><span style="color: #000000"> tagged_any {</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0000FF">char</span><span style="color: #000000">* tag;</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #0000FF">union</span><span style="color: #000000"> any val;</span></div><div class='line'><span style="color: #000000">};</span></div></code></div></pre>
<p>The most interesting runtime function using <code>tagged_any</code>s is the pseudo-polymorphic
<code>print</code>:<span class="note"><label for="print" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="print" class="margin-toggle" /><span class="sidenote"><code>_print</code> writes values without a newline, and is useful for recurring when
printing a record. <code>print</code> is a user-facing entry point that terminates a printed
value with a newline.</span></p>
<pre class="shiki light-plus" style="background-color: #FFFFFF; color: #000000"><div class="language-id">c</div><div class='code-container'><code><div class='line'><span style="color: #0000FF">void</span><span style="color: #000000"> </span><span style="color: #795E26">_print</span><span style="color: #000000">(tagged_any </span><span style="color: #001080">any</span><span style="color: #000000">) {</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #AF00DB">if</span><span style="color: #000000"> (</span><span style="color: #795E26">is</span><span style="color: #000000">(any, NAT)) {</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #795E26">printf</span><span style="color: #000000">(</span><span style="color: #A31515">"</span><span style="color: #001080">%d</span><span style="color: #A31515">"</span><span style="color: #000000">, </span><span style="color: #001080">any</span><span style="color: #000000">.</span><span style="color: #001080">val</span><span style="color: #000000">.</span><span style="color: #001080">nat</span><span style="color: #000000">);</span></div><div class='line'><span style="color: #000000">  } </span><span style="color: #AF00DB">else</span><span style="color: #000000"> </span><span style="color: #AF00DB">if</span><span style="color: #000000"> (</span><span style="color: #795E26">is</span><span style="color: #000000">(any, STRING)) {</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #795E26">printf</span><span style="color: #000000">(</span><span style="color: #A31515">"</span><span style="color: #001080">%s</span><span style="color: #A31515">"</span><span style="color: #000000">, </span><span style="color: #001080">any</span><span style="color: #000000">.</span><span style="color: #001080">val</span><span style="color: #000000">.</span><span style="color: #001080">string</span><span style="color: #000000">);</span></div><div class='line'><span style="color: #000000">  } </span><span style="color: #AF00DB">else</span><span style="color: #000000"> </span><span style="color: #AF00DB">if</span><span style="color: #000000"> (</span><span style="color: #795E26">is</span><span style="color: #000000">(any, BOOL)) {</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #795E26">printf</span><span style="color: #000000">(</span><span style="color: #A31515">"</span><span style="color: #001080">%s</span><span style="color: #A31515">"</span><span style="color: #000000">, </span><span style="color: #001080">any</span><span style="color: #000000">.</span><span style="color: #001080">val</span><span style="color: #000000">.</span><span style="color: #0000FF">bool</span><span style="color: #000000"> == </span><span style="color: #098658">1</span><span style="color: #000000"> ? </span><span style="color: #A31515">"true"</span><span style="color: #000000"> : </span><span style="color: #A31515">"false"</span><span style="color: #000000">);</span></div><div class='line'><span style="color: #000000">  } </span><span style="color: #AF00DB">else</span><span style="color: #000000"> </span><span style="color: #AF00DB">if</span><span style="color: #000000"> (</span><span style="color: #795E26">is</span><span style="color: #000000">(any, RECORD)) {</span></div><div class='line'><span style="color: #000000">    record r = </span><span style="color: #001080">any</span><span style="color: #000000">.</span><span style="color: #001080">val</span><span style="color: #000000">.</span><span style="color: #001080">record</span><span style="color: #000000">;</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #795E26">printf</span><span style="color: #000000">(</span><span style="color: #A31515">"{"</span><span style="color: #000000">);</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #AF00DB">for</span><span style="color: #000000"> (</span><span style="color: #0000FF">int</span><span style="color: #000000"> i = </span><span style="color: #098658">0</span><span style="color: #000000">; i &lt; </span><span style="color: #001080">r</span><span style="color: #000000">.</span><span style="color: #001080">numFields</span><span style="color: #000000">; ++i) {</span></div><div class='line'><span style="color: #000000">      </span><span style="color: #795E26">printf</span><span style="color: #000000">(</span><span style="color: #A31515">"</span><span style="color: #001080">%s</span><span style="color: #A31515">: "</span><span style="color: #000000">, </span><span style="color: #001080">r</span><span style="color: #000000">.</span><span style="color: #001080">fields</span><span style="color: #000000">[i]);</span></div><div class='line'><span style="color: #000000">      </span><span style="color: #795E26">_print</span><span style="color: #000000">(</span><span style="color: #001080">r</span><span style="color: #000000">.</span><span style="color: #001080">values</span><span style="color: #000000">[i]);</span></div><div class='line'><span style="color: #000000">      </span><span style="color: #AF00DB">if</span><span style="color: #000000"> (i != </span><span style="color: #001080">r</span><span style="color: #000000">.</span><span style="color: #001080">numFields</span><span style="color: #000000"> - </span><span style="color: #098658">1</span><span style="color: #000000">) {</span></div><div class='line'><span style="color: #000000">        </span><span style="color: #795E26">printf</span><span style="color: #000000">(</span><span style="color: #A31515">", "</span><span style="color: #000000">);</span></div><div class='line'><span style="color: #000000">      }</span></div><div class='line'><span style="color: #000000">    }</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #795E26">printf</span><span style="color: #000000">(</span><span style="color: #A31515">"}"</span><span style="color: #000000">);</span></div><div class='line'><span style="color: #000000">  } </span><span style="color: #AF00DB">else</span><span style="color: #000000"> {</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #795E26">fprintf</span><span style="color: #000000">(stderr, </span><span style="color: #A31515">"Runtime error: no matching tag </span><span style="color: #001080">%s</span><span style="color: #EE0000">\n</span><span style="color: #A31515">"</span><span style="color: #000000">, </span><span style="color: #001080">any</span><span style="color: #000000">.</span><span style="color: #001080">tag</span><span style="color: #000000">);</span></div><div class='line'><span style="color: #000000">    </span><span style="color: #795E26">exit</span><span style="color: #000000">(</span><span style="color: #098658">1</span><span style="color: #000000">);</span></div><div class='line'><span style="color: #000000">  }</span></div><div class='line'><span style="color: #000000">}</span></div><div class='line'><span style="color: #0000FF">void</span><span style="color: #000000"> </span><span style="color: #795E26">print</span><span style="color: #000000">(tagged_any </span><span style="color: #001080">any</span><span style="color: #000000">) {</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #795E26">_print</span><span style="color: #000000">(any);</span></div><div class='line'><span style="color: #000000">  </span><span style="color: #795E26">printf</span><span style="color: #000000">(</span><span style="color: #A31515">"</span><span style="color: #EE0000">\n</span><span style="color: #A31515">"</span><span style="color: #000000">);</span></div><div class='line'><span style="color: #000000">}</span></div></code></div></pre>
<p>Having encoded all values as <code>tagged_any</code>s, performing <code>is</code> and <code>in</code> checks
becomes trivial. In the case of <code>is</code>, we take an array of type tags
(constituting a union) and check if a value's type tag is in that array. If we
need to check a record, we verify that all field names coincide and
recurse on checking corresponding field values. In the case of <code>in</code>, if a value is not a record the check is
immediately false; otherwise, we walk the fields of the record and check if one
corresponds with the predicated field.</p>
<h3 id="performance-concerns%2C-and-what-to-do-about-them" tabindex="-1"><a class="header-anchor" href="#performance-concerns%2C-and-what-to-do-about-them" aria-hidden="true"></a>Performance concerns, and what to do about them</h3>
<p>The introduction of type tags and runtime typecheckers introduces
costs that may not be immediately obvious to users of the language, and are
something that we would like to avoid. Type tags on their own aren't
so bad to deal with; since they are constant, one can inline them and the
downstream C compiler will likely replace identical tags with a common
reference to a static; if not, an interner can be added without much difficulty.</p>
<p>On the other hand, the costs incurred by evaluating <code>is</code> expressions are harder
to deal with, primarily because of the explosive cost of checking deeply nested
records for equivalence.</p>
<p>To avoid this, perhaps the best strategy is to employ flow typing
in a language with nominal types, rather than the structural ones we have
presented in this language. This way, checks for type equivalence are simply the
comparison of two type names (or even better, two memory addresses).</p>
<h2 id="lang_extends" tabindex="-1"><a class="header-anchor" href="#lang_extends" aria-hidden="true"></a><code>lang_extends</code></h2>
<p>As mentioned earlier, it may appear that the restrictions imposed by <span>​<script type="math/tex">\ref{Is}</script></span> and <span>​<script type="math/tex">\ref{In}</script></span>
are superfluous. In some sense they are; we can generalize over
both with a rule that constructs a <code>Narrowed</code> type by testing against an
arbitrary subtype of a union.
Let's direct such a rule with an expression called <code>extends</code>:</p>
<div class="mathblock"><script type="math/tex; mode=display">
\begin{equation}\label{Extends}\tag{Extends}
\frac{
\begin{gather*}
\Gamma\vdash \text{t} : \text{T} \\
\text{W} = \text{T} \setminus \text{U}
\end{gather*}
}{
\Gamma \vdash \text{t $\tt{extends}$ U}: \text{Narrowed}\langle\text{t}, \text{U}, \text{W}\rangle
}
\end{equation}
</script></div>
<p>We'll define the exclusion <span>​<script type="math/tex">\text{T}\setminus\text{U}</script></span> the following
way:</p>
<div class="mathblock"><script type="math/tex; mode=display">
\begin{equation}\label{Union-exclude-ST}\tag{Union-exclude-ST}
\frac{
\begin{gather*}
\text{T} = \text{T}_1 ~|~ \dots ~|~ \text{T}_n \\
\text{U} = \text{U}_1 ~|~ \dots ~|~ \text{U}_m \\
\text{U } <: \text{T} \\ % >
\text{W} = \text{W}_1 ~|~ \dots ~|~ \text{W}_p \\
\bbox[border: 1px solid grey]{
   \begin{gather*}
   \forall i=1,\dots,n \text{ s.t. } \forall j=1,\dots,m \\
   \text{T}_i \cancel{<:} \text{U}_j \implies
   \exists \text{W}_k = \text{T}_i % >
   \end{gather*}
}
\end{gather*}
}{
\text{T}\setminus\text{U} = \text{W}
}
\end{equation}
</script></div>
<p>Now we can write the well-typed function</p>
<pre class="shiki light-plus" style="background-color: #FFFFFF; color: #000000"><div class='code-container'><code><div class='line'><span style="color: undefined">fn go(p: nat|bool|{a: nat, b: nat}|{b: nat, c: nat}): nat {
  if p extends {b: nat}
     then p.b
     else if p extends bool
          then if p then 1 else 0
          else p
}</span></div></code></div></pre>
<p>using a single <code>extends</code> expression where we would have had to use a combination
of <code>in</code> and <code>is</code> expressions in <code>lang_narrow</code>.</p>
<h3 id="performance-concerns%2C-and-what-to-do-about-them-1" tabindex="-1"><a class="header-anchor" href="#performance-concerns%2C-and-what-to-do-about-them-1" aria-hidden="true"></a>Performance concerns, and what to do about them</h3>
<p>Of course, the flexibility of <span>​<script type="math/tex">\ref{Extends}</script></span> does
not come without its costs. Like <code>lang_narrow</code>, a <code>lang_extends</code> runtime needs
to check type tags and read record fields, but the conditions of <span>​<script type="math/tex">\ref{Union-exclude-ST}</script></span>
also suggests that the runtime needs to carry around a subtyping checker!</p>
<p>Obviously, having both a compile-time and runtime subtyping checker is not ideal, and
the runtime penalties can be severe especially in the presence of large union,
record, or recursive types (if we had introduced them).</p>
<p>There are several techniques to mitigate the runtime penalties; one approach may
be to populate, at compile time, a table of type relations amongst all known
types in the program, and perform subtyping queries by searching the table.
Costs of searches can be further reduced by storing the type relations in a tree
and making queries union-finds.</p>
<p>My impression is that, in general, the power of a typing rule like <span>​<script type="math/tex">\ref{Extends}</script></span>
is not worth the additional runtime complexity, cost, and code size its
implementation must introduce.</p>
<h2 id="going-further%3A-an-algorithm-for-narrowed-contexts-in-imperative-programs" tabindex="-1"><a class="header-anchor" href="#going-further%3A-an-algorithm-for-narrowed-contexts-in-imperative-programs" aria-hidden="true"></a>Going further: an algorithm for narrowed contexts in imperative programs</h2>
<p>The implementation of typing contexts in <code>lang_narrow</code> (and <code>lang_extends</code>) is
straightforward; since each program is one large
continuation, we never end up &quot;jumping out&quot; of the control flow (and the typing
context) we are currently in. Contrast this to an imperative version of
<code>lang_narrow</code>, wherein we may write a program like</p>
<pre class="shiki light-plus" style="background-color: #FFFFFF; color: #000000"><div class='code-container'><code><div class='line'><span style="color: undefined">fn is_number_like(p: bool|{numberish: nat|string}|nat|string): bool {
   if p is bool then {
      return false;
   }

   var n: nat|string = if numberish in p then { // (1)
      p.numberish
   } else {
      p
   };

   return if p is number then {
      true // (2)
   } else {
      String.regex_matches(RE_NUMBER, p) // (3)
   };
}</span></div></code></div></pre>
<p>At <code>(1)</code> we would like the typing context to associate <code>p: {numberish: nat|string}|nat|string</code>,
at <code>(2)</code> associate <code>p: number</code>, and at <code>(3)</code> associate <code>p: string</code>.</p>
<p>It may not be obvious how to design an efficient algorithm to update
the typing context in a control flow with the presence of
jumps (like that of the first branch, which immediately returns). But
actually, it's not so bad; I will give a quick sketch of a couple things
you may want to consider, and leave you to fill out the algorithm if you are
interested.</p>
<ul>
<li>First, define what it means for the typing context when the program hits a
local termination point (like a <code>return</code> statement, which jumps out of the local function);
one idea is to then mark everything in the local context as uninhabited.</li>
<li>Keep track of the typing context after the completion of each statement in the
program. For example, if a statement <code>I</code> is of the form <code>if Cond then L else R</code>,
and the typing contexts of <code>L</code> and <code>R</code> as induced by <code>Cond</code> are $\Gamma_{\tt L}$ and $\Gamma_{\tt R}$,
respectively, what are $\Gamma_{\text{post}({\tt L})}$ and $\Gamma_{\text{post}({\tt R})}$?
What is the the typing context $\Gamma_{\text{post}({\tt I})}$ in relation to $\Gamma_{\text{post}({\tt L})}$ and $\Gamma_{\text{post}({\tt R})}$?</li>
</ul>
<h2 id="summary" tabindex="-1"><a class="header-anchor" href="#summary" aria-hidden="true"></a>Summary</h2>
<p>In this cc, we derived a simple language with support for structural type
narrowing of record and union types via flow typing. Our language and its type system are small
and intuitive enough to design and implement in an afternoon, but additional
work not presented here is needed to formulate soundness and completeness of the
type system.</p>
<p>To learn more about flow typing, you may be interested in the <a href="https://en.wikipedia.org/wiki/Flow-sensitive_typing">Wikipedia entry</a> and
<a href="https://ecs.wgtn.ac.nz/foswiki/pub/Main/TechnicalReportSeries/ECSTR12-20.pdf">Pearce's 2012 paper</a> on
a flow calculus with proofs of correctness.</p>
<p>As always, thanks for reading. I hope you had fun, and that this cc inspires
you to design more interesting type systems.</p>


</article>

<section class="footer">
  
  <a href="/articles/21/hot-code-reloading"
    >&laquo; Hot Code Reloading, With Libc or in the Browser</a
  >
  
  <span
    ><img class='emoji' alt='door' src='https://gitlab.com/ayazhafiz/emoji-img/raw/master/public/emoji/unicode/1f6aa.png' height=20 width=20></img>&emsp;
    <span
      >&#8203;
      <script type="math/tex">
        \tt{>>=}\;\cong\;\tt{<*>}
      </script></span
    >
  </span>
  
  <a href="/articles/21/representability-coproducts-reflective-subcategories">Representability, Coproducts, and Reflective Subcategories &raquo;</a>
  
</section>

<script src="https://utteranc.es/client.js"
        repo="ayazhafiz/gww-utterances"
        issue-term="title"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

<script type="text/javascript">
  function $(query) {
    return document.querySelector(query);
  }

  function $$(query) {
    return Array.from(document.querySelectorAll(query));
  }

  function isFullWidth() {
    return $(".post").classList.contains("full");
  }

  function toggleFullWidth() {
    const isFull = isFullWidth();
    isFull
      ? $(".post").classList.remove("full")
      : $(".post").classList.add("full");
    toggleShowHideNotes(!isFull);
    toggleShowHideNotesSwitch(!isFull);
    return !isFull;
  }

  function toggleShowHideNotes(isFullWidth) {
    const notes = $$(".marginnote").concat($$(".sidenote"));
    notes.forEach(note => {
      isFullWidth
        ? note.classList.add("maybe-hide")
        : note.classList.remove("maybe-hide");
    });
  }

  document.addEventListener("DOMContentLoaded", () => {
    $$(".note").forEach(toggle =>
      toggle.addEventListener("click", () => {
        if (isFullWidth()) {
          toggleFullWidth();
        }
      })
    );
  });
</script>

        </div>
      </div>
    </div>

    <div class="bottom-bar"><details>
  <summary>Analytics</summary>
  By visiting this site, you agree to its use of <a href="https://www.cloudflare.com/analytics/"
    >Cloudflare Analytics</a
  >. No identifiable information is transmitted to Cloudflare. See
  <a href="https://www.cloudflare.com/web-analytics/">Cloudflare Analytics user privacy</a>.
</details>

</details>
</div>
  </body>
</html>
